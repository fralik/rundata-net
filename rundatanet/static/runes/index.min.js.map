{"version":3,"file":"index.min.js","sources":["../../runes/js/index_scripts.js","../../runes/js/index_multiselect.js","../../runes/js/index_map.js","../../runes/js/index_query_builder.js","../../runes/js/index_search.js","../../runes/js/index_view_model.js","../../runes/js/index_import_utils.js","../../runes/js/index.js"],"sourcesContent":["export const schemaFieldsInfo = [\n  {\n    schemaName: 'signature_text',\n    text: {\n      'en': 'Inscription'\n    },\n  },\n  {\n    schemaName: 'full_address',\n    text: {\n      'en': 'Any location',\n    },\n  },\n  {\n    schemaName: 'found_location',\n    text: {\n      'en': 'Found location',\n    },\n  },\n  {\n    schemaName: 'parish',\n    text: {\n      'en': 'Parish',\n    },\n  },\n  {\n    schemaName: 'district',\n    text: {\n      'en': 'District',\n    },\n  },\n  {\n    schemaName: 'municipality',\n    text: {\n      'en': 'Municipality',\n    },\n  },\n  {\n    schemaName: 'current_location',\n    text: {\n      'en': 'Current location',\n    },\n  },\n  {\n    schemaName: 'original_site',\n    text: {\n      en: 'Original site',\n    },\n  },\n  {\n    schemaName: 'parish_code',\n    text: {\n      en: 'Parish code',\n    }\n  },\n  {\n    schemaName: 'rune_type',\n    text: {\n      en: 'Rune type',\n    }\n  },\n  {\n    schemaName: 'dating',\n    text: {\n      en: 'Dating',\n    }\n  },\n  {\n    schemaName: 'year_from',\n    text: {\n      en: 'Year (from)',\n    },\n  },\n  {\n    schemaName: 'year_to',\n    text: {\n      en: 'Year (to)',\n    },\n  },\n  {\n    schemaName: 'style',\n    text: {\n      en: 'Style',\n    }\n  },\n  {\n    schemaName: 'carver',\n    text: {\n      en: 'Carver',\n    }\n  },\n  {\n    schemaName: 'material',\n    text: {\n      en: 'Material',\n    },\n  },\n  {\n    schemaName: 'material_type',\n    text: {\n      en: 'Material type',\n    },\n  },\n  {\n    schemaName: 'objectInfo',\n    text: {\n      en: 'Object information',\n    },\n  },\n  {\n    schemaName: 'reference',\n    text: {\n      en: 'References',\n    },\n  },\n  {\n    schemaName: 'additional',\n    text: {\n      en: 'Other information',\n    },\n  },\n  {\n    schemaName: 'normalisation_norse',\n    text: {\n      en: 'Normalization to Old West Norse',\n    },\n    css: 'normalization',\n    highlight: true,\n  },\n  {\n    schemaName: 'normalisation_scandinavian',\n    text: {\n      en: 'Normalisation to Old Scandinavian',\n    },\n    css: 'normalization',\n    highlight: true,\n  },\n  {\n    schemaName: 'english_translation',\n    text: {\n      en: 'Translation to English',\n    },\n  },\n  {\n    schemaName: 'swedish_translation',\n    text: {\n      en: 'Translation to Swedish',\n    }\n  },\n  {\n    schemaName: 'transliteration',\n    text: {\n      en: 'Transliterated runic text',\n    },\n    css: 'transliteration',\n    highlight: true,\n  },\n  {\n    schemaName: 'num_crosses',\n    text: {\n      en: 'Number of crosses',\n    },\n  },\n  {\n    schemaName: 'cross_form',\n    text: {\n      en: 'Cross form',\n    },\n  },\n  {\n    schemaName: 'crosses',\n    text: {\n      en: 'Cross',\n    },\n  },\n  {\n    schemaName: 'images',\n    text: {\n      en: 'Images',\n    }\n  },\n];\n\nconst allButNames = /[\\$\\[\\]\\{\\}\\(\\)\\?<>\\^`´\\|¬°·:×¤\\+÷']|¶+,\\./g;\nconst punctuation = /[\\.,;]/g;\n\n// Two tables below are true for DB 20240910. Assembled manually.\nconst normalizationWordsToSkip = {\n  'U 166': [3, 7],\n  'Sm 1': [24, 28],\n  'U 637': [10, 12],\n  'U 1036': [14, 16],\n  'M 11': [16, 35],\n  'G 280': [5, 7],\n  'GR 56': [8],\n  'N KJ72': [22],\n  'N B625': [69],\n  'N B311': [4],\n  'N B265': [25],\n  'N B259': [1],\n  'N B255': [20],\n  'N B27': [3],\n  'N A197': [3],\n  'N A5': [1],\n  'N A144': [1],\n  'N 603': [5],\n  'N 362': [2],\n  'N 208': [8],\n  'N 171': [13],\n  'N 124': [2],\n  'N 114': [3],\n  'N 26': [8],\n  'N 19': [12],\n  'DR NOR2004;7': [18],\n  'DR NOR1999;21': [47],\n  \"G 306\": [3],\n  \"G 129\": [11],\n  \"G 119\": [24],\n  \"Gs 8\": [7],\n  \"Vs 27\": [10],\n  \"Vs 22\": [6],\n  \"Vs 3\": [15],\n  \"U THS10;58\": [15],\n  \"U NOR1998;25\": [19],\n  \"U Fv1976;104\": [3],\n  \"U Fv1953;263\": [18],\n  \"U Fv1948;168\": [16],\n  \"U 1168\": [6],\n  \"U 1162\": [11],\n  \"U 1158\": [10],\n  \"U 1132\": [13],\n  \"U 1111\": [11],\n  \"U 1097\": [3],\n  \"U 1060\": [5],\n  \"U 1042\": [10],\n  \"U 1005\": [12],\n  \"U 968\": [3],\n  \"U 952\": [16],\n  \"U 917\": [3],\n  \"U 896\": [10],\n  \"U 805\": [40],\n  \"U 662\": [1],\n  \"U 618\": [12],\n  \"U 545\": [24],\n  \"U 459\": [11],\n  \"U 423\": [11],\n  \"U 351\": [14],\n  \"Vg 219\": [13],\n  \"Vg 67\": [25],\n  \"Sö Fv1986;218\": [8],\n  \"Sö 344\": [3],\n  \"Sö 320\": [5],\n  \"Sö 256\": [10],\n  \"Sö 205\": [3],\n  \"Sö 130\": [20],\n  \"Sö 109\": [13],\n  \"Sö 105\": [5],\n  \"Sö 82\": [9],\n  \"Sö 46\": [19],\n  \"Sö 21\": [6],\n  \"Ög 180\": [4],\n\n};\nconst transliterationWordsToSkip = {\n  \"IS IR;166\": [12],\n  'N 157': [4],\n  \"DR NOR2002;7\": [9],\n  \"G 325\": [8],\n  \"Nä 20\": [6],\n  \"U Sl115\": [1],\n  \"U Fv1992;156\": [7],\n  \"U Fv1986;84\": [1, 14],\n  \"U 775\": [13],\n  \"U 558\": [6],\n  \"U 431\": [12],\n  \"U 29\": [29],\n  \"Sö 196\": [34],\n  \"Ög 51\": [4],\n};\n\n\nlet gRenderInProgress = false;\n\n/**\n * Retrieves a human-readable name for a schema field in the specified language.\n *\n * @param {string} schemaName - The machine name of the schema field.\n * @param {string} [lang='en'] - The language code to get the translation for (defaults to 'en').\n * @returns {string} The translated human-readable name if available, otherwise returns the schemaName.\n */\nexport function getHumanName(schemaName, lang = 'en') {\n  const field = schemaFieldsInfo.find(field => field.schemaName === schemaName);\n  if (!field) {\n    return schemaName; // Return the schemaName as is if not found\n  }\n  return field.text[lang] || schemaName; // Return the human name or schemaName if translation is missing\n}\n\n/**\n * Checks if a given word is a personal name.\n * @param {string} word - The word to check.\n * @returns {boolean} - True if the word is a personal name, false otherwise.\n */\nexport function isPersonalName(word) {\n  return word.startsWith('\"') || word.startsWith(\"&quot;\")\n    || word.includes('/\"') || word.includes('/&quot;');\n}\n\n\n// Extracts word boundaries from inscription texts. These texts\n// have multiple separators (whitespaces, punctuation) that often\n// go together, i.e. space,punctuation,space\n// returns array of objects. Each object:\n// {start: num, end: num, text: string, isPersonal: 0|1}\n// Arguments:\n//   str - search string\nfunction getWordBoundaries(str, sourceIsEscaped = false) {\n  // regex used to detect word boundaries\n  const wordBoundariesSource = \"((\\\\s+|^(·|:|×|¤|'|\\\\+|÷|¶))(·|:|×|¤|'|\\\\+|÷|¶){0,1}\\\\s*)\";\n  // the reason it is written so complex via | is because we can do html escaping on that string\n  const punctuationSource = \"(·|:|×|¤|'|\\\\||\\\\+|÷|¶|\\\\(|\\\\)|\\\\[|\\\\])+\"\n  //const punctuationSource = \"([·|:×¤'+÷¶()|[\\]\\\\])+\";\n  const reg = new RegExp(sourceIsEscaped ? escapeHtml(wordBoundariesSource) : wordBoundariesSource, 'g');\n  // regex used to check if detected word is pure punctuation\n  const purePunctuation = new RegExp(sourceIsEscaped ? escapeHtml(punctuationSource) : punctuationSource);\n\n  const words = [];\n  let wordBegin = 0;\n\n  function processWord(wordBegin, wordEnd) {\n    const wordText = str.slice(wordBegin, wordEnd);\n\n    // Skip double sides character\n    if (str.slice(wordBegin, wordBegin + 2) === '¶¶') {\n      return null;\n    }\n    // skip {÷\n    if (str.slice(wordBegin, wordBegin+2) === \"{÷\") {\n      return null;\n    }\n\n    // Check if the word is pure punctuation\n    const punctuationCheck = purePunctuation.exec(wordText);\n    if (punctuationCheck && punctuationCheck[0].length === wordText.length) {\n      return null;\n    }\n\n    // skip ^\n    if (wordText == \"^\") {\n      return null;\n    }\n\n\n    const oneWord = {\n      start: wordBegin,\n      end: wordEnd,\n      text: wordText,\n      isPersonal: 0,\n    };\n\n    // Check if the word is personal\n    oneWord.isPersonal = isPersonalName(wordText) ? 1 : 0;\n\n    return oneWord;\n  }\n\n  let arr;\n  while ((arr = reg.exec(str)) !== null) {\n    if (wordBegin === arr.index) {\n      wordBegin += arr[0].length;\n      continue;\n    }\n    const oneWord = processWord(wordBegin, arr.index);\n    if (oneWord) {\n      words.push(oneWord);\n    }\n    wordBegin = arr.index + arr[0].length;\n  }\n\n  // Process any remaining text after the last regex match\n  if (wordBegin < str.length) {\n    const oneWord = processWord(wordBegin, str.length);\n    if (oneWord) {\n      words.push(oneWord);\n    }\n  }\n\n  return words;\n}\n\n/**\n * Convert a database object to a key map.\n * @param {Object} db - The database object that can be used to run queries.\n * @returns {Object} - The key map object. Key - signature ID, value - all signature info.\n */\nexport function convertDbToKeyMap(db) {\n  let content = db.exec(\"SELECT all_data.*, signatures_with_aliases.aliases FROM all_data LEFT JOIN signatures_with_aliases ON all_data.signature_id = signatures_with_aliases.signature_id\");\n  const columns = content[0].columns;\n  const allRows = content[0].values;\n  const signatureIdColumn = columns.indexOf(\"signature_id\");\n  const numCrossesColumn = columns.indexOf(\"num_crosses\");\n  const latitudeColumn = columns.indexOf('latitude');\n  const longitudeColumn = columns.indexOf('longitude');\n  const presentLatitudeColumn = columns.indexOf('present_latitude');\n  const presentLongitudeColumn = columns.indexOf('present_longitude');\n  const metaColumn = columns.indexOf('id');\n  const wordColumns = ['transliteration', 'normalisation_norse', 'normalisation_scandinavian'];\n\n  const allDbImages = fetchAllImages(db);\n  let numDiffers = 0;\n\n  const dbArray = allRows.map(row => {\n    let objSignature = {};\n    const metaId = row[metaColumn];\n    for (let j = 0; j < row.length; j++) {\n      const columnName = columns[j];\n\n      objSignature[columnName] = row[j];\n      // handle NULL values\n      if (row[j] === null) {\n        objSignature[columnName] = \"\";\n      }\n\n      /////////////////////////////////////\n      // pre-split words and store arrays\n      if (wordColumns.includes(columnName)) {\n        objSignature[`${columnName}_html`] = escapeHtml(row[j]);\n        objSignature[`${columnName}_word_boundaries`] = getWordBoundaries(objSignature[`${columnName}_html`], true);\n      }\n    }\n\n    /////////////////////////////////////////\n    // Handle exceptions for word searches\n\n    // special treatment for \"Sö 145\"\n    if (objSignature.signature_text === \"Sö 145\") {\n      // treat `ata i` as a single word\n      objSignature['transliteration_html'] = escapeHtml(objSignature.transliteration.replace(\": ata i ::\", \": ata_i ::\"));\n      objSignature['transliteration_word_boundaries'] = getWordBoundaries(objSignature['transliteration_html'], true);\n      // replace it back\n      objSignature['transliteration_word_boundaries'][22].text = 'ata i';\n    }\n    if (normalizationWordsToSkip.hasOwnProperty(objSignature.signature_text)) {\n      const wordsToSkip = normalizationWordsToSkip[objSignature.signature_text];\n      objSignature.normalisation_norse_word_boundaries = objSignature.normalisation_norse_word_boundaries.filter((_, i) => !wordsToSkip.includes(i));\n      objSignature.normalisation_scandinavian_word_boundaries = objSignature.normalisation_scandinavian_word_boundaries.filter((_, i) => !wordsToSkip.includes(i));\n    }\n    if (transliterationWordsToSkip.hasOwnProperty(objSignature.signature_text)) {\n      const wordsToSkip = transliterationWordsToSkip[objSignature.signature_text];\n      objSignature.transliteration_word_boundaries = objSignature.transliteration_word_boundaries.filter((_, i) => !wordsToSkip.includes(i));\n    }\n    // End of exception handling\n    /////////////////////////////////////\n\n    // Adjust small mismatches\n    if (objSignature.transliteration_word_boundaries.length == 0 && objSignature.normalisation_norse_word_boundaries.length == 1) {\n      if (objSignature.normalisation_norse_word_boundaries[0].text == '...') {\n        // reset the normalisation_norse_word_boundaries\n        objSignature.normalisation_norse_word_boundaries = [];\n        objSignature.normalisation_scandinavian_word_boundaries = [];\n      }\n    }\n\n    wordColumns.forEach(name => {\n      // `${name}_word_boundaries` is a list of objects with keys: start, end, text\n      // create a new array out of it with only the text\n      objSignature[`${name}_words`] = objSignature[`${name}_word_boundaries`].map(boundary => {\n        return boundary.text;\n      });\n    });\n    numDiffers += objSignature.transliteration_word_boundaries.length !== objSignature.normalisation_norse_word_boundaries.length ? 1 : 0;\n\n    objSignature[\"signature_display\"] = prepareSignumForDisplay(objSignature);\n    if (objSignature[\"aliases\"]) {\n      objSignature[\"signature_header\"] = objSignature[\"signature_text\"] + \" (\" + objSignature[\"aliases\"] + \")\";\n    } else {\n      objSignature[\"signature_header\"] = objSignature[\"signature_text\"];\n    }\n\n    /////////////////////////////////////\n    // fill in images\n    if (allDbImages.hasOwnProperty(metaId)) {\n      const imagesMarkup = makeImagesMarkup(allDbImages[metaId]);\n      objSignature[\"directImages\"] = imagesMarkup.directImages;\n      objSignature[\"indirectImages\"] = imagesMarkup.indirectImages;\n    } else {\n      objSignature[\"directImages\"] = \"\";\n      objSignature[\"indirectImages\"] = \"No images.\";\n    }\n\n    /////////////////////////////////////\n    // fill in crosses\n    let numCrosses = row[numCrossesColumn];\n    if (numCrosses > 0) {\n      objSignature['crosses'] = crossesForMeta(db, row[metaColumn]);\n    } else {\n      objSignature['crosses'] = [];\n    }\n\n    return objSignature;\n  });\n  const dbAsJson = new Map();\n  dbArray.forEach(inscription => {\n    dbAsJson.set(inscription.id, inscription);\n  });\n\n  console.log(`Number of signatures with different word boundaries (it should be 0): ${numDiffers}`);\n\n  return dbAsJson;\n}\n\nexport function prepareSignumForDisplay({signature_text, lost, new_reading}) {\n  let additional = \"\";\n  if (lost) {\n    additional += \"†\"\n  }\n  if (new_reading) {\n    additional += \"$\"\n  }\n  if (additional.length > 0) {\n    additional = \" \" + additional;\n  }\n\n  return signature_text + additional;\n}\n\nexport function fetchAllImages(db) {\n  const content = db.exec(\"SELECT meta_id, link_url, direct_url FROM runes_imagelink\");\n  const allRows = content[0].values;\n\n  let allImages = {};\n\n  for (let i = 0; i < allRows.length; i++) {\n    const row = allRows[i];\n    const metaId = row[0];\n    if (!allImages.hasOwnProperty(metaId)) {\n      allImages[metaId] = {links: []};\n    }\n    allImages[metaId].links.push({indirect: row[1], direct: row[2]});\n  }\n  return allImages;\n}\n\nexport function makeImagesMarkup(signatureImageLinks) {\n  let directImages = \"\";\n  let indirectImages = \"No images.\";\n\n  // make image gallery of direct image links\n  const galleryLinks = signatureImageLinks.links.slice(0, 9);\n  const offsetIndirectImages = galleryLinks.length;\n\n  directImages = '<div class=\"container-fluid\"><div class=\"row\">';\n  galleryLinks.map(function (v, i) {\n    if (i % 3 == 0 && i !== 0) {\n      directImages += \"</div><div class='row'>\";\n    }\n    directImages += `<div class=\"col-md-4\"><a href=\"${v.indirect}\" contentEditable=\"false\" target=\"_blank\"><img src=\"${v.direct}\" class=\"img-responsive\"></a></div>`;\n  });\n  directImages += '</div></div>';\n\n  const indirectImagesLinks = signatureImageLinks.links.slice(offsetIndirectImages);\n  if (indirectImagesLinks.length > 0) {\n    indirectImages = '<ul>';\n    indirectImagesLinks.map(function (v, i) {\n      indirectImages += `<li><a href=\"${v.indirect}\" contentEditable=\"false\" target=\"_blank\">${v.indirect}</a></li>`;\n    });\n    indirectImages += '</ul>';\n  }\n\n  return {directImages, indirectImages};\n}\n\n/* Find all crosses related to particular metaId.\n * Returned variable is a multidimensional array. Dimensions:\n * 1. First dimension contains individual crosses.\n * 2. Second dimension denotes cross form group. There could only be 8 groups.\n * 3. Third dimension contains objects with 2 data fields (name, isCertain). Each object represents a particular cross form in a group.\n *    Note that some groups can be empty.\n */\nexport function crossesForMeta(db, metaId) {\n  // we do not check that this meta contains any crosses. This should be done in parent call\n  //let cc = db.exec(\"SELECT id FROM crosses WHERE meta_id = '\" + metaId + \"'\");\n  const contents = db.exec(\"SELECT cross_id, cross_forms.id, cross_forms.name, cross_forms.group_id, cross_definitions.is_certain FROM cross_definitions INNER JOIN cross_forms ON (cross_definitions.form_id = cross_forms.id) WHERE cross_id IN (SELECT id FROM crosses WHERE meta_id = '\" + metaId + \"') ORDER BY cross_id\");\n  if (!contents)\n    return [];\n\n  let lastCrossId = -1;\n  let crosses = [];\n\n  for (let i = 0; i < contents[0].values.length; i++) {\n    let crossId = parseInt(contents[0].values[i][0], 10);\n    if (crossId != lastCrossId) {\n      lastCrossId = crossId;\n      crosses.push(Array.apply(null, Array(8)).map(function() {return [];}));\n    }\n\n    let formName = contents[0].values[i][2];\n    let groupId = contents[0].values[i][3];\n    let isCertain = contents[0].values[i][4];\n\n    crosses[crosses.length - 1][parseInt(groupId, 10)].push({name: formName, isCertain: isCertain});\n  }\n  return crosses;\n}\n\n/**\n * Convert list/map of inscriptions to tree nodes suitable for jsTree.\n *\n * @param {*} inscriptions - Either a list of objects or a map. If map is provided, it will be converted to a list of map values.\n */\nexport function inscriptions2treeNodes(inscriptions) {\n  const values = inscriptions instanceof Map ? Array.from(inscriptions.values()) : inscriptions;\n\n  return values.map(inscription => {\n    return {\n      id: inscription.id.toString(),\n      text: inscription.signature_display,\n      normalizedText: inscription.signature_text.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\"),\n      icon: false,\n      signature: inscription.signature_text,\n    };\n  });\n}\n\nexport function selectFirstSignature() {\n  let root = $('#jstree').jstree(true).get_node('#');\n  $('#jstree').jstree(true).select_node(root.children[0]);\n}\n\n/**\n * Convert list of inscriptions to a list of select options in html format.\n */\nexport function inscriptions2Select(container, dbMap) {\n  // clear container\n  container.innerHTML = \"\";\n\n  dbMap.forEach((inscription, id) => {\n    const option = document.createElement(\"option\");\n    option.value = id;\n    option.text = inscription.signature_display;\n\n    container.appendChild(option);\n  });\n}\n\n/**\n * Show tooltip message on a DOM element.\n *\n * @param {object} el DOM element, e.g. document.getElementById(\"myBtn\")\n * @param {string} message Tooltip message\n */\nfunction setTooltip(el, message) {\n  const that = $(el);\n  that.attr('data-bs-title', message).tooltip('show');\n  // do not care about multiple calls to setTimeout\n  setTimeout(function() {\n    that.tooltip('hide');\n  }, 900);\n}\n\nexport function initClipboardButtons() {\n  /**\n   * There is a collection of buttons that represent various tricky symbols, like umlauts.\n   * Clicking on them should copy the relevant symbol to the clipboard.\n   */\n  const clipboardButtons = document.querySelectorAll('.clip');\n  clipboardButtons.forEach(button => {\n    button.addEventListener('click', function() {\n      const symbol = button.innerText;\n      navigator.clipboard.writeText(symbol).then(function() {\n        setTooltip(button, 'Copied to clipboard!');\n      }).catch(function(err) {\n        setTooltip(button, 'Failed to copy!');\n      });\n    });\n  });\n}\n\nexport function arraysEqual(a, b) {\n  if (a === b) return true;\n  if (a == null || b == null) return false;\n  if (a.length != b.length) return false;\n\n  for (var i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\nexport function displaySignatureInfo() {\n  const indices = $('#jstree').jstree(true).get_selected();\n  if (indices.length == 0) {\n    return;\n  }\n\n  if (gRenderInProgress) {\n    gRenderInProgress = false;\n    setTimeout(displaySignatureInfo, 300);\n    return;\n  }\n  document.getElementById('mainDisplay').innerHTML = \"<img src='https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.7/themes/default-dark/throbber.gif'><br>\";\n  gRenderInProgress = true;\n  setTimeout(renderSignatures, 100);\n}\n\nfunction renderSignatures() {\n  if (!gRenderInProgress)\n    return;\n\n  try {\n    const selectedSignatureIds = $('#jstree').jstree(true).get_selected();\n    const selectedSignatures = gViewModel.getInscriptions(selectedSignatureIds);\n\n    const html = inscriptions2markup(selectedSignatures);\n    document.getElementById('mainDisplay').innerHTML = html.join('');\n  } catch (e) {\n    console.error(`Error rendering signatures: ${e}`);\n  } finally {\n    gRenderInProgress = false;\n  }\n}\n\nfunction escapeHtml(string) {\n  const entityMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '/': '&#x2F;',\n    '`': '&#x60;',\n    '=': '&#x3D;'\n  };\n\n  return String(string).replace(/[&<>\"'`=\\/]/g, function (s) {\n    return entityMap[s];\n  });\n}\n\nexport function inscriptions2markup(inscriptions) {\n  // array of selected inscription IDs\n  //const selectedSignatureIds = $('#jstree').jstree(true).get_selected();\n  const lang = 'en';\n  const paragraphSymbol = '§';\n  const sidesHeader = \"Sides or/and reading variants:\"\n\n  const showHeaders = $('#chkDisplayHeaders').is(\":checked\");\n  const userSelectedFields =  getUserSelectedFields();\n  let markupData = [];\n  for (let i = 0; i < inscriptions.length; i++) {\n\n    const inscriptionData = inscriptions[i];\n    const signatureId = inscriptionData.id;\n    const signatureName = inscriptionData.signature_text;\n\n    let paragraph = `<article signature=\"${signatureName}\" id=\"${signatureName}\" rundata-db-id=\"${signatureId}\" class=\"inscription-section\">`;\n    for (let j = 0; j < userSelectedFields.length; j++) {\n      const field = userSelectedFields[j];\n      const columnName = field.schemaName == \"signature_text\" ? \"signature_header\" : field.schemaName;\n      const humanName = field.text[lang];\n      const cssStyle = field.css || \"\";\n      const shouldHighlight = field.highlight || false;\n\n      let columnData = \"\";\n      if (columnName in inscriptionData) {\n        columnData = inscriptionData[columnName].toString();\n      }\n      if (showHeaders) {\n        paragraph += `<h4>${humanName}</h4>`;\n      } else if (paragraph.length > 0 && columnData !== \"\") {\n        paragraph += \"<br>\";\n      }\n\n      // Smiley is a special symbol: word substitute when word is not present\n      // We do not need to show it.\n      columnData = columnData.replace(/ ☺ /g, ' ');\n\n      if (columnName === 'images') {\n        if (inscriptionData['directImages'].length == 0) {\n          paragraph += inscriptionData['indirectImages'];\n          continue;\n        }\n        paragraph += inscriptionData['directImages'];\n        if (inscriptionData['indirectImages'].length > 0) {\n          // add image links as they have not been added yet\n          paragraph += '<br>' + inscriptionData['indirectImages'];\n        }\n\n        continue;\n      }\n\n      if ((columnData == '' || columnData == null) && showHeaders) {\n        paragraph += '<i>Absent, not in the database.</i>';\n        continue;\n      }\n\n      if (columnName === \"crosses\") {\n        if (inscriptionData['num_crosses'] == 0) {\n          paragraph += '<i>No crosses.</i>';\n          continue;\n        }\n\n        paragraph += '<table class=\"crosses\" border=\"1\">';\n        paragraph += '<thead><tr>';\n        paragraph += '<th>A</th>';\n        paragraph += '<th>B</th>';\n        paragraph += '<th>C</th>';\n        paragraph += '<th>D</th>';\n        paragraph += '<th>E</th>';\n        paragraph += '<th>F</th>';\n        paragraph += '<th>G</th>';\n        paragraph += '</th></thead>';\n        paragraph += '<tbody>';\n\n        const allCrosses = inscriptionData['crosses'];\n        for (let k = 0; k < allCrosses.length; k++) {\n          if (allCrosses[k][0].length > 0) {\n            // this is a cross from an undefined group\n            paragraph += '<tr><td colspan=\"7\">' + allCrosses[k][0][0].name + '</td></tr>';\n            continue;\n          }\n          paragraph += '<tr>';\n          // we have 8 groups in total, 0 being free-text and not a real group\n          for (let gr = 1; gr < 8; gr++) {\n            if (allCrosses[k][gr].length == 0) {\n              paragraph += '<td><span class=\"null\">&#8709;</span></td>';\n              continue;\n            }\n            paragraph += '<td>';\n            paragraph += allCrosses[k][gr].map(function (v, i) {\n              let res = '<img src=\"' + getCrossUrl(v.name) + '\" alt=\"'+v.name+'\" title=\"'+v.name+'\" width=\"32\" height=\"32\">';\n              if (v.isCerain == 0) {\n                res += '?';\n              }\n              return res;\n            }).join(', ');\n            paragraph += '</td>';\n          }\n        }\n        paragraph += '</tbody></table>';\n        continue;\n      }\n\n      columnData = escapeHtml(columnData);\n\n      if (shouldHighlight && inscriptionData.hasOwnProperty('matchDetails') && inscriptionData.matchDetails !== null && inscriptionData.matchDetails.hasOwnProperty('wordIndices')) {\n        const entryWordBoundaries = inscriptionData[`${columnName}_word_boundaries`];\n        const matchedWords = inscriptionData.matchDetails.wordIndices;\n        const matchedWordBoundaries = entryWordBoundaries.filter((_, i) => matchedWords.includes(i));\n        columnData = highlightWordsFromWordBoundaries(columnData, matchedWordBoundaries);\n      }\n\n      if (columnData.indexOf(paragraphSymbol) !== -1) {\n        const parts = columnData.split(paragraphSymbol);\n        paragraph += sidesHeader + \"<ul>\";\n        parts.forEach(part => {\n          if (!part.trim()) {\n            return;\n          }\n\n          paragraph += `<li><span class=\"${cssStyle}\">${paragraphSymbol} ${part}</span></li>`;\n        });\n        paragraph += \"</ul>\";\n      } else {\n        paragraph += `<span class=\"${cssStyle}\">${columnData}</span>`;\n      }\n    }\n    paragraph += '</article>';\n    markupData.push(paragraph);\n  }\n  return markupData;\n}\n\n/**\n * Handle message from export worker\n */\nexport function onExportWorkerMessage(e) {\n  gExportInProgress = false;\n\n  if (e.data.error) {\n    onExportError({message: e.data.message});\n    return;\n  }\n\n  try {\n    // Create a download for the XLSX file\n    if (e.data.buffer) {\n      // Convert ArrayBuffer to Blob with the correct MIME type\n      const blob = new Blob([e.data.buffer], {\n        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n      });\n\n      // Create a download link and trigger the download\n      const link = document.createElement('a');\n      link.href = URL.createObjectURL(blob);\n      link.download = 'rundata-net_results.xlsx';\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n\n      // Close the modal after successful export\n      closeResultsIoModal();\n    }\n  } catch (error) {\n    onExportError(error);\n  } finally {\n    hideLoading();\n  }\n}\n\n/**\n * Handle export errors\n */\nexport function onExportError(error) {\n  console.error('Export error:', error);\n  hideLoading();\n  gExportInProgress = false;\n\n  // Display error to user\n  showAlert(\"Export error: \" + (error.message || 'Unknown error'));\n}\n\nexport function showAlert(message) {\n  const alertObj = document.getElementById('alertObj');\n  alertObj.textContent = message;\n  alertObj.style.display = 'block';\n\n  // Hide the alert after 5 seconds\n  setTimeout(() => {\n    alertObj.style.display = 'none';\n  }, 5000);\n}\n\n/**\n * Helper function to show loading indicator\n * @param {string} [description] - Optional loading description text\n */\nexport function showLoading(description) {\n  const defaultDescription = \"It can take up to a minute.\";\n  const txtLoadingDescription = document.getElementById('txtLoadingDescription');\n\n  if (txtLoadingDescription) {\n    txtLoadingDescription.textContent = description || defaultDescription;\n  }\n  $('#loading').show();\n}\n\n/**\n * Helper function to hide loading indicator\n */\nexport function hideLoading() {\n  $('#loading').hide();\n}\n\nexport function closeResultsIoModal() {\n  $('#modalResultsIo').modal('hide');\n}\n\n","// Key in the local storage under which users display options are saved.\n// display options are information which is displayed per inscription.\nconst gUserSelectedDisplayKey = \"userSelectedDisplay\";\nconst gShowHeadersKey = \"showHeaders\";\n\nfunction storageAvailable(type) {\n  let storage;\n  try {\n    storage = window[type];\n    const x = '__storage_test__';\n    storage.setItem(x, x);\n    storage.removeItem(x);\n    return true;\n  }\n  catch(e) {\n    return e instanceof DOMException && (\n      // everything except Firefox\n      e.code === 22 ||\n      // Firefox\n      e.code === 1014 ||\n      // test name field too, because code might not be present\n      // everything except Firefox\n      e.name === 'QuotaExceededError' ||\n      // Firefox\n      e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\n      // acknowledge QuotaExceededError only if there's something already stored\n      (storage && storage.length !== 0);\n  }\n}\n\nexport function getUserSelectedDisplay() {\n  const defaults = ['signature_text', 'transliteration', 'english_translation', 'found_location',\n    'parish', 'municipality', 'district', 'current_location', 'images'];\n\n  if (!storageAvailable('localStorage')) {\n    return defaults;\n  }\n\n  try {\n    const storage = window['localStorage'];\n    if (storage.getItem(gUserSelectedDisplayKey)) {\n      return JSON.parse(storage.getItem(gUserSelectedDisplayKey));\n    }\n  } catch (e) {\n    console.error('Error while reading user selected display from local storage:', e);\n  }\n\n  return defaults;\n}\n\nexport function saveUserSelectedDisplay(selectedValues = null) {\n  if (!storageAvailable('localStorage')) {\n    return;\n  }\n  const storage = window['localStorage'];\n\n  //var selectedValues = $('#multiselect_to option').map((index, el) => $(el).val()).toArray();\n  // ensure it is an array and encode it as json string, because local storage can work with string only.\n  const selectedValuesArray = JSON.stringify(selectedValues ? [].concat(selectedValues) : []);\n\n  storage.setItem(gUserSelectedDisplayKey, selectedValuesArray);\n}\n\nexport function getUserSelectedFields() {\n  const selectedValues = getUserSelectedDisplay();\n  return selectedValues.map(value => schemaFieldsInfo.find(prop => prop.schemaName === value));\n}\n\n\nfunction setMultiselectOptions(selectedValues, showHeaders) {\n  let sortValue = 0;\n  $('#multiselect_to').empty();\n  $('#multiselect').empty();\n\n  // Populate the list of already selected display options\n  selectedValues.forEach(value => {\n    const schemaField = schemaFieldsInfo.find(prop => prop.schemaName === value);\n    if (schemaField) {\n      $('#multiselect_to').append($('<option>', {\n        value: schemaField.schemaName,\n        text : schemaField.text['en'],\n        sortValue: sortValue++,\n      }));\n    }\n  });\n\n  // Populate the list of available display options\n  schemaFieldsInfo.forEach(schemaField => {\n    if (selectedValues.indexOf(schemaField.schemaName) === -1) {\n      $('#multiselect').append($('<option>', {\n        value: schemaField.schemaName,\n        text : schemaField.text['en'],\n        sortValue: sortValue++,\n      }));\n    }\n  });\n\n  if (typeof showHeaders !== 'boolean') {\n    showHeaders = showHeaders === 'true';\n  }\n  $('#chkDisplayHeaders').prop('checked', showHeaders);\n}\n\nexport function initMultiselect() {\n  const defaultSelectedValues = [\n    'signature_text', 'transliteration', 'normalisation_scandinavian', 'normalisation_norse',\n    'english_translation', 'swedish_translation', 'found_location', 'parish', 'municipality', 'district', 'current_location',\n    'original_site', 'images', 'rune_type', 'carver', 'num_crosses', 'crosses', 'dating', 'style',\n    'material_type', 'material', 'objectInfo', 'reference', 'additional'\n  ];\n\n  const savedSelected = localStorage.getItem(gUserSelectedDisplayKey);\n  const selectedValues = savedSelected ? JSON.parse(savedSelected) : defaultSelectedValues;\n  const savedShowHeaders = localStorage.getItem(gShowHeadersKey);\n  const showHeaders = savedShowHeaders ? savedShowHeaders === 'true' : true;\n\n  setMultiselectOptions(selectedValues, showHeaders);\n \n  $('#multiselect').multiselect({\n    keepRenderingSortRight: false,\n    skipInitSortRight: false,\n    sort: {\n      left: function (a, b) {\n        const aValue = parseInt($(a).attr('sortValue'));\n        const bValue = parseInt($(b).attr('sortValue'));\n\n        return aValue > bValue ? 1 : -1;\n      },\n      right: function (a, b) {\n        const aValue = parseInt($(a).attr('sortValue'));\n        const bValue = parseInt($(b).attr('sortValue'));\n\n        return aValue > bValue ? 1 : -1;\n      }\n    },\n  });\n\n  $('#formatDialogAlertObj').hide();\n\n  document.getElementById('btnApplyDisplayFormat').addEventListener('click', onDisplayFormatClicked);\n  document.getElementById('btnDismissDisplayFormat').addEventListener('click', () => {\n    // revert the changes\n    const savedShowHeaders = localStorage.getItem(gShowHeadersKey);\n    const showHeaders = savedShowHeaders ? savedShowHeaders === 'true' : true;\n    const savedSelected = localStorage.getItem(gUserSelectedDisplayKey);\n    const selectedValues = savedSelected ? JSON.parse(savedSelected) : defaultSelectedValues;\n    setMultiselectOptions(selectedValues, showHeaders);\n  });\n\n  const formatDialogEl = document.getElementById('divFormatDialog')\n  formatDialogEl.addEventListener('shown.bs.modal', event => {\n    $('#formatDialogAlertObj').hide();\n\n    // preserve current display options in a local storage, so that we may compare it later to detect user edit\n    const lastShowHeaders = $('#chkDisplayHeaders').is(\":checked\");\n    const userSelectedDisplay = $('#multiselect_to option').map((index, el) => $(el).val()).toArray();\n    saveUserSelectedDisplay(userSelectedDisplay);\n    localStorage.setItem(gShowHeadersKey, lastShowHeaders);\n  });\n}\n\nfunction onDisplayFormatClicked(e) {\n  e.preventDefault();\n\n  const alertObj = $('#formatDialogAlertObj');\n  const selectedValues = $('#multiselect_to option').map((index, el) => $(el).val()).toArray();\n\n  if (selectedValues === null || selectedValues.length == 0) {\n    alertObj.html('Nothing is selected for display! Please select at least one property.');\n    alertObj.show();\n    return;\n  }\n  alertObj.hide();\n\n  // read old values from the local storage\n  const lastShowHeaders = localStorage.getItem(gShowHeadersKey);\n  const lastUserSelectedValues = JSON.parse(localStorage.getItem(gUserSelectedDisplayKey));\n\n  const showHeaders = $('#chkDisplayHeaders').is(\":checked\");\n  if (!arraysEqual(lastUserSelectedValues, selectedValues) || lastShowHeaders != showHeaders) {\n    saveUserSelectedDisplay(selectedValues);\n    localStorage.setItem(gShowHeadersKey, showHeaders);\n\n    // display signature info\n    $('#multiselect').trigger('displayUpdated', {message: 'hello'});\n  }\n\n  $(this).prev().click();\n}\n","/*\n This script assumes that you reference leaflet.js and leaflet.css in your HTML file.\n It allows relies on defined `isSafari` function.\n*/\n\n// Initialize the map on the user-provided div with a given center and zoom level\n// Default center is [56.607512, 16.439838] and default zoom is 8.\nexport function initMap(divId, center = [56.607512, 16.439838], zoom = 8) {\n  const map = L.map(divId, {\n    fullscreenControl: true,\n  }).setView(center, zoom);\n  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n    maxZoom: 19,\n    attribution: '© <a href=\"https://openstreetmap.org\">OpenStreetMap</a> contributors'\n  }).addTo(map);\n\n  // add location control to global name space for testing only\n  // on a production site, omit the \"lc = \"!\n  L.control.locate({\n    strings: {\n      title: \"My location\"\n    }\n  })\n  .addTo(map);\n\n  const markers = L.markerClusterGroup({\n    showCoverageOnHover: true,\n    chunkedLoading: true,\n    maxClusterRadius: 60,\n  });\n  markers.on('click', function (e) {\n    scrollToInscription(e.layer.options.signature, e.layer.options.id);\n  });\n  markers.addTo(map);\n\n  return {map, markers};\n}\n\nexport function onHideMapClicked(mapContainerId, menuItemId) {\n  const mapContainerJquery = `#${mapContainerId}`;\n  const menuItemJquery = `#${menuItemId}`;\n\n  $(mapContainerJquery).toggle();\n  if ($(mapContainerJquery).is(\":visible\")) {\n    $(menuItemJquery).html('Hide map');\n  } else {\n    $(menuItemJquery).html('Show map');\n  }\n}\n\nfunction isMobileDevice() {\n  try {\n    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction getGeoIntentURL(lat, lng) {\n  if (typeof isSafari !== 'function') {\n    console.error('isSafari function is not defined');\n    throw new Error('isSafari function is not defined');\n  }\n  \n  if (isSafari()) {\n    return `http://maps.apple.com/?daddr=${lat},${lng}`;\n  }\n  else {\n    return `geo:${lat},${lng}?q=${lat},${lng}`;\n  }\n}\n\nfunction inscription2marker(inscriptionData, lat, lon, leaflet=L) {\n  // Inscriptions have two sets of latitude and longitude values: one for the\n  // original location and one for the present location. We will always create two\n  // markers for each inscription. This means that even if the present location is\n  // the same as the original location, we will still create two markers.\n\n  if (lat === 0.0 || lon === 0.0) {\n    return null;\n  }\n  let marker = leaflet.marker([lat, lon], {\n    signature: inscriptionData.signature_text,\n    id: inscriptionData.id,\n  });\n  let popupText = `${inscriptionData.signature_text}<br>`;\n  if (isMobileDevice()) {\n    popupText += `<a href=\"${getGeoIntentURL(lat, lon)}\" target=\"_self\">Drive here!</a>`;\n  }\n  // Tooltip is simple and is always on, popup supports HTML and is opened  /closed by user\n  if (isMobileDevice()) {\n    marker.bindPopup(popupText, {autoClose: false});\n  }\n  marker.bindTooltip(inscriptionData.signature_text, {permanent: true}).openTooltip();\n\n  return marker;\n}\n\n/**\n * Converts inscription data to map markers and returns a collection of markers.\n *\n * @param {Map} dbMap - A map containing inscription data with keys as unique identifiers.\n * @param {Object} [leaflet=L] - The Leaflet library instance to use for creating markers.\n * @returns {Map} A map where each key corresponds to an inscription and the value is an object\n *                containing 'found' and 'present' markers. The key is the same as in dbMap.\n */\nexport function inscriptions2markers(dbMap, leaflet=L) {\n  const mapMarkers = new Map(); // Collection of all created map markers. This is used\n  // in order to create markers only once.\n\n  dbMap.forEach((inscriptionData, key) => {\n    const signatureName = inscriptionData.signature_text;\n\n    const found_lat = parseFloat(inscriptionData.latitude) || 0.0;\n    const found_lon = parseFloat(inscriptionData.longitude) || 0.0;\n    const present_lat = parseFloat(inscriptionData.present_latitude) || 0.0;\n    const present_lon = parseFloat(inscriptionData.present_longitude) || 0.0;\n    const marker_found = inscription2marker(inscriptionData, found_lat, found_lon, leaflet);\n    if (!marker_found) {\n      return;\n    }\n    if (!mapMarkers.has(key)) {\n      mapMarkers.set(key, {found: null, present: null});\n    }\n    mapMarkers.get(key).found = marker_found;\n\n    const marker_present = inscription2marker(inscriptionData, present_lat, present_lon, leaflet);\n    mapMarkers.get(key).present = marker_present ? marker_present : marker_found;\n  });\n  return mapMarkers;\n}\n\n\n/**\n * Displays markers on the map based on the provided parameters.\n *\n * @param {Object} options - The options for displaying markers.\n * @param {boolean} [options.preserveMapArea=false] - If true, the map area will not be adjusted to fit the markers.\n * @param {boolean} [options.showOriginalLocation=false] - If true, markers will be shown for the original (found) location of inscriptions, otherwise for the present location.\n * @param {Array<string>} [options.inscriptionIds=[]] - An array of inscription IDs to display markers for.\n * @param {Map<string, Object>} [options.allMarkers=new Map()] - A map containing all markers, keyed by inscription ID.\n * @param {Object} [options.mapObject=null] - The Leaflet map object.\n * @param {Object} [options.markersLayer=null] - The Leaflet layer group to which markers will be added.\n */\nexport function showMarkers({\n  preserveMapArea = false,\n  showOriginalLocation = false,\n  inscriptionIds = [],\n  allMarkers = new Map(),\n  mapObject = null,\n  markersLayer = null,\n} = {}) {\n  // array of all marker's lat/lon. Used to calculate new bounds.\n  let markersLatLon = [];\n  \n  if (!markersLayer || !mapObject) {\n    console.log('No markers layer or map object provided');\n    return;\n  }\n\n  // clear any markers from the map\n  markersLayer.clearLayers();\n\n  for (let i = 0; i < inscriptionIds.length; i++) {\n    const key = inscriptionIds[i];\n    if (!allMarkers.has(key)) {\n      continue;\n    }\n    const inscriptionMarkers = allMarkers.get(key);\n    const markerToShow = showOriginalLocation ? inscriptionMarkers.found : inscriptionMarkers.present;\n    markersLayer.addLayers(markerToShow);\n    markersLatLon.push(markerToShow.getLatLng());\n  }\n\n  if (markersLatLon.length > 0 && !preserveMapArea) {\n    mapObject.fitBounds(markersLatLon);\n  }\n}\n\n","/*\nThis file contains code to work with jquery query builder. The query builder must be\nincluded in your code prior to using this file.\n*/\n\n\nconst queryBuilderPlugins = {\n  'bt-tooltip-errors': null,\n  'sortable': null,\n  'not-group': null,\n  // 'case-rule': null,\n};\n\nconst optGroups = {\n  \"gr_signature\": {\n    \"en\": \"Inscription\",\n    \"sv\": \"Signatura\",\n  },\n  \"gr_texts\": \"Texts\",\n  \"gr_location\": \"Location\",\n  \"other\": \"---\",\n};\n\n// QueryBuilder plugin for case-(in)sensitive search\n$.fn.queryBuilder.define('case-rule', function(options) {\n  let self = this;\n\n  // Bind events\n  this.on('afterInit', function() {\n    self.$el.on('click.queryBuilder', '[data-case=rule]', function () {\n      let $rule = $(this).closest($.fn.queryBuilder.constructor.selectors.rule_container);\n      let rule = self.getModel($rule);\n      rule.ignoreCase = !rule.ignoreCase;\n      // console.log(`afterInit: ${rule.id}, ignoreCase: ${rule.ignoreCase}`);\n      // print rule configuration\n      // console.log(rule);\n    });\n\n    self.model.on('update', function(e, node, field) {\n      if (node instanceof $.fn.queryBuilder.constructor.Rule && field === 'ignoreCase') {\n        // console.log(`update: ${node.id}, ignoreCase: ${node.ignoreCase}`);\n        self.updateRuleCaseIgnore(node);\n      }\n    });\n  });\n\n  // Init case-sensitivity property\n  this.on('afterAddRule', function(e, rule) {\n    rule.__.ignoreCase = false;\n  });\n\n  this.on('afterCreateRuleInput.filter', function(e, rule) {\n    // Show plugin's button only for text fields\n    if (!rule.filter || typeof rule.filter.input !== 'string') {\n      rule.$el.find(cssSelectorPluginCaseRule).hide();\n      return;\n    }\n\n    if (rule.filter.input.indexOf('text') === -1) {\n      rule.$el.find(cssSelectorPluginCaseRule).hide();\n    } else {\n      rule.$el.find(cssSelectorPluginCaseRule).show();\n    }\n  });\n\n  // Modify templates\n  if (!options.disable_template) {\n    this.on('getRuleTemplate.filter', function(h) {\n      var $h = $($.parseHTML(h.value));\n      $h.find($.fn.queryBuilder.constructor.selectors.rule_actions).prepend(\n          '\\n<button type=\"button\" class=\"btn btn-xs btn-default\" active data-case=\"rule\">' +\n          '<i class=\"' + options.icon_checked + '\"></i> ' +\n          '<span class=\"case-rule-text\">' + self.translate('Match case') + '</span>' +\n          '</button>'\n      );\n      h.value = $h.prop('outerHTML');\n    });\n  }\n\n  // Export \"case-rule\" to JSON\n  this.on('ruleToJson.filter', function(e, rule) {\n    e.value.ignoreCase = rule.ignoreCase;\n  });\n\n  // Read \"case-rule\" from JSON\n  this.on('jsonToRule.filter', function(e, json) {\n    e.value.ignoreCase = !!json.ignoreCase;\n  });\n\n  // Export case selector to SQL\n  this.on('ruleToSQL.filter', function(e, rule, value, sqlFn) {\n    console.log(`ruleToSQL.filter: ${rule.id}, ignoreCase: ${rule.ignoreCase}`);\n    if (rule.ignoreCase) {\n      e.value = 'NOCASE ( ' + e.value + ' )';\n    }\n  });\n}, {\n  icon_checked: 'bi bi-check2-square',\n  disable_template: false\n});\n\n$.fn.queryBuilder.constructor.utils.defineModelProperties($.fn.queryBuilder.constructor.Rule, ['ignoreCase']);\n\nconst cssSelectorPluginCaseRule = $.fn.queryBuilder.constructor.selectors.rule_actions + ' [data-case=rule]';\n\n$.fn.queryBuilder.extend({\n  /**\n   * Performs actions when a rule's case selector changes\n   * @param {Rule} rule\n   * @fires module:plugins.CaseSelector.updateRuleCaseIgnore\n   * @private\n   */\n  updateRuleCaseIgnore: function(rule) {\n      // console.log(`updateRuleCaseIgnore: ${rule.id}, ignoreCase: ${rule.ignoreCase}`);\n      rule.$el.find(cssSelectorPluginCaseRule + \"> .case-rule-text\")\n          .text(this.translate(rule.ignoreCase ? 'Ignore case' : 'Match case'));\n\n      /**\n       * After the rule's case selector has been modified\n       * @event afterUpdateRuleCaseSelector\n       * @memberof module:plugins.CaseSelector\n       * @param {Rule} rule\n       */\n      this.trigger('afterUpdateRuleCaseSelector', rule);\n\n      this.trigger('rulesChanged');\n  }\n});\n\n\nexport function sortGroupsByOrder(items, groupOrder) {\n  const key = 'optgroup'; // The key in items to group by\n\n  // Create priority map\n  const priorityMap = {};\n  groupOrder.forEach((group, index) => {\n    priorityMap[group] = index;\n  });\n\n  // Group items by their key\n  const groups = {};\n  items.forEach(item => {\n    const groupKey = item[key] || '';\n    if (!groups[groupKey]) groups[groupKey] = [];\n    groups[groupKey].push(item);\n  });\n\n  // Sort each group alphabetically by label\n  Object.keys(groups).forEach(groupKey => {\n    groups[groupKey].sort((a, b) => {\n      const labelA = a.label || '';\n      const labelB = b.label || '';\n      return labelA.localeCompare(labelB);\n    });\n  });\n\n  // Create result array by concatenating groups in specified order\n  let result = [];\n  groupOrder.forEach(groupKey => {\n    if (groups[groupKey]) {\n      result = result.concat(groups[groupKey]);\n      delete groups[groupKey];\n    }\n  });\n\n  // Add any remaining groups not specified in groupOrder\n  Object.values(groups).forEach(group => {\n    result = result.concat(group);\n  });\n\n  return result;\n}\n\n/**\n * Gets the minimum and maximum values of a numerical field from a data source\n *\n * @param {Map|Array} dataSource - Either a Map containing database records or an array of items\n * @param {string} fieldName - The name of the field to analyze\n * @returns {Object} Object containing min and max values, or null if field doesn't exist or has no numeric values\n */\nexport function getMinMaxValues(dataSource, fieldName) {\n  if (!dataSource) {\n    throw new Error(\"dataSource parameter is required\");\n  }\n\n  if (!fieldName || typeof fieldName !== 'string') {\n    throw new Error(\"fieldName parameter is required and must be a string\");\n  }\n\n  let min = null;\n  let max = null;\n  let hasValues = false;\n\n  // Function to process each item\n  const processItem = (item) => {\n    // Skip if item doesn't have the field or value isn't numeric\n    if (!item || item[fieldName] === undefined || item[fieldName] === null) {\n      return;\n    }\n\n    // Convert to number if it's a string\n    const value = typeof item[fieldName] === 'string' ?\n      parseFloat(item[fieldName]) : item[fieldName];\n\n    // Skip if not a valid number\n    if (isNaN(value)) {\n      return;\n    }\n\n    // Initialize min/max on first valid value\n    if (!hasValues) {\n      min = value;\n      max = value;\n      hasValues = true;\n      return;\n    }\n\n    // Update min/max\n    if (value < min) min = value;\n    if (value > max) max = value;\n  };\n\n  // Handle different data source types\n  if (dataSource instanceof Map) {\n    // Process Map values\n    for (const item of dataSource.values()) {\n      processItem(item);\n    }\n  } else if (Array.isArray(dataSource)) {\n    // Process array items\n    for (const item of dataSource) {\n      processItem(item);\n    }\n  } else {\n    throw new Error(\"dataSource must be either a Map or an Array\");\n  }\n\n  return hasValues ? { min, max } : null;\n}\n\nexport function getValuesFromAllData(term, suggest, fieldName, dbMap, isTomSelect = false) {\n  // Get all unique values from dbMap for the specified fieldName\n  let allValues = [];\n  const uniqueTracker = new Set();\n  let nextArtificialId = 20000; // Starting ID for aliases\n\n  Array.from(dbMap.values()).forEach(item => {\n    const visited = uniqueTracker.has(item[fieldName]);\n    if (item[fieldName] && item[fieldName] !== '' && !visited) {\n      uniqueTracker.add(item[fieldName]);\n      allValues.push({\n        text: item[fieldName],\n        id: item[fieldName],\n        score: item.id || 0\n      });\n      if (fieldName === 'signature_text' && item.aliases) {\n        const aliases = item.aliases.split('|').map(a => a.trim()).filter(a => a);\n\n        // Add each alias with an artificial ID\n        aliases.forEach(alias => {\n          if (!uniqueTracker.has(alias)) {\n            uniqueTracker.add(alias);\n            allValues.push({\n              text: alias,\n              id: alias,\n              score: nextArtificialId++,\n            });\n          }\n        });\n      }\n    }\n  });\n\n  allValues.sort((a, b) => a.score - b.score);\n\n  // Comparison without diacritics:\n  if (term !== '') {\n    // Normalize strings to remove diacritics\n    const normalizedTerm = term.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').toLowerCase();\n    allValues = allValues.filter(item => {\n      const normalizedText = item.text.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').toLowerCase();\n      return normalizedText.includes(normalizedTerm);\n    });\n  }\n\n  if (isTomSelect) {\n    suggest(allValues);\n    return allValues;\n  }\n\n  const values = allValues.map(item => item.text);\n  suggest(values);\n  return values;\n}\n\n\n/**\n * Creates an autocomplete configuration object for QueryBuilder.\n *\n * @param {string} ruleId - The unique identifier for the rule.\n * @param {Map} dbMap - A Map containing the database values for autocomplete.\n * @param {Function} humanNameGetter - Function that returns a human-readable name for the given rule ID.\n * @param {Object} [opt={}] - Optional configuration parameters.\n * @param {string} [opt.fieldId] - The field ID to use (defaults to ruleId if not provided).\n * @param {string[]} [opt.operators] - Array of operators to use with this field.\n * @param {string} [opt.type='string'] - The data type for the field.\n * @param {number} [opt.size=100] - The display size of the field.\n * @param {string} [opt.optgroup='other'] - The option group to which this field belongs.\n * @returns {Object} Configuration object for QueryBuilder autocomplete field.\n * @throws {Error} If required parameters are missing or invalid.\n */\nfunction prepareAutoComplete(ruleId, dbMap, humanNameGetter, opt = {}) {\n  // Check required arguments\n  if (ruleId === undefined) {\n    throw new Error(\"prepareAutoComplete: 'ruleId' parameter is required\");\n  }\n  if (!dbMap || !(dbMap instanceof Map)) {\n    throw new Error(\"prepareAutoComplete: 'dbMap' parameter is required and must be a Map\");\n  }\n  if (!humanNameGetter || typeof humanNameGetter !== 'function') {\n    throw new Error(\"prepareAutoComplete: 'humanNameGetter' parameter is required and must be a function\");\n  }\n\n  const fieldId = opt.fieldId || ruleId;\n  const operators = opt.operators || [\"contains\", \"not_contains\",\n        'equal', 'not_equal', 'begins_with', \"not_begins_with\",\n        \"ends_with\", \"not_ends_with\", \"is_empty\", 'is_not_empty'];\n  const type = opt.type || 'string';\n  const size = opt.size || 100;\n  const optgroup = opt.optgroup || \"other\";\n\n  return {\n    id: ruleId,\n    field: fieldId,\n    optgroup: optgroup,\n    label: humanNameGetter(ruleId),\n    type: type,\n    plugin: 'autoComplete',\n    plugin_config: {\n      minChars: 0,\n      delay: 100,\n      source: function (term, suggest) {\n        getValuesFromAllData(term, suggest, fieldId, dbMap);\n      },\n      menuClass: ' clusterize-content ',\n      attachToParent: true,\n    },\n    size: size,\n    operators: operators,\n  }\n}\n\n/**\n * Creates a jQuery QueryBuilder filter configuration for integer rules\n *\n * @param {string} ruleId - ID for the rule/filter\n * @param {Map} dbMap - A Map containing the database values for autocomplete.\n * @param {Function} humanNameGetter - Function that returns a human-readable name for the given rule ID.\n * @param {Object} opt - Optional configuration parameters\n * @param {string} opt.fieldId - Field name in data (defaults to ruleId if not provided)\n * @param {Array} opt.operators - Array of operators to use for this filter\n * @param {number} opt.size - Size attribute for the input field\n * @param {string} opt.optgroup - Group to which this filter belongs\n * @param {number} opt.min - Minimum allowed value (optional)\n * @param {number} opt.max - Maximum allowed value (optional)\n * @param {number} opt.step - Step value for input (optional)\n * @param {number} opt.default_value - Default value for the field (optional)\n * @returns {Object} Filter configuration object for QueryBuilder\n */\nfunction prepareIntegerRule(ruleId, dbMap, humanNameGetter, opt) {\n  // Check required arguments\n  if (ruleId === undefined) {\n    throw new Error(\"prepareIntegerRule: 'ruleId' parameter is required\");\n  }\n  if (!dbMap || !(dbMap instanceof Map)) {\n    throw new Error(\"prepareIntegerRule: 'dbMap' parameter is required and must be a Map\");\n  }\n  if (!humanNameGetter || typeof humanNameGetter !== 'function') {\n    throw new Error(\"prepareIntegerRule: 'humanNameGetter' parameter is required and must be a function\");\n  }\n  if (!opt) opt = {};\n  const fieldId = opt.fieldId || ruleId;\n  const operators = opt.operators || ['equal', 'not_equal', 'less', 'less_or_equal', 'greater', 'greater_or_equal', 'between', 'not_between'];\n  const size = opt.size || 10;\n  const optgroup = opt.optgroup || \"other\";\n\n  let config = {\n    id: ruleId,\n    field: fieldId,\n    optgroup: optgroup,\n    label: humanNameGetter(fieldId),\n    type: 'integer',\n    size: size,\n    operators: operators,\n    input: 'number'\n  };\n  const dataLimitValues = getMinMaxValues(dbMap, fieldId);\n  opt.min = opt.min || (dataLimitValues && dataLimitValues.min);\n  opt.max = opt.max || (dataLimitValues && dataLimitValues.max);\n\n  // Add validation if any constraints are specified\n  if (opt.min !== undefined || opt.max !== undefined || opt.step !== undefined) {\n    config.validation = {\n      allow_empty_value: true\n    };\n\n    if (opt.min !== undefined) config.validation.min = opt.min;\n    if (opt.max !== undefined) config.validation.max = opt.max;\n    if (opt.step !== undefined) config.validation.step = opt.step;\n  }\n\n  // Add default value if provided\n  if (opt.default_value !== undefined) {\n    config.default_value = opt.default_value;\n  }\n\n  return config;\n}\n\n\n/**\n * Adjusts the input element in a query rule by applying either TomSelect or AutoComplete plugin\n * based on the rule's operator type.\n *\n * @param {Object} rule - The query rule object containing the element and operator information\n * @param {Object} [tomSelectConfig={}] - Configuration options for TomSelect plugin\n * @param {Object} [autoCompleteConfig={}] - Configuration options for AutoComplete plugin\n *\n * @description This function first cleans up any existing TomSelect or AutoComplete plugins\n * attached to the input element, then initializes the appropriate plugin based on the\n * operator type. If the operator is 'in' or 'not_in', TomSelect is applied; otherwise,\n * AutoComplete is used.\n */\nfunction adjustTomSelectAndAutoComplete(rule, tomSelectConfig = {}, autoCompleteConfig = {}) {\n  var $input = rule.$el.find('.rule-value-container input');\n  const operator = rule.operator.type;\n\n  // Clean up existing plugins\n  if ($input.data('tomSelect') !== undefined) {\n    $input.tomSelect('destroy');\n  }\n  if ($input.hasClass('autocomplete')) {\n    $input.autoComplete('destroy');\n  }\n\n  // Initialize the appropriate plugin based on operator\n  if (operator === 'in' || operator === 'not_in') {\n    $input.tomSelect(tomSelectConfig);\n  } else {\n    $input.autoComplete(autoCompleteConfig);\n  }\n}\n\n/**\n * Creates a rule for word search in runic texts\n *\n * @param {Object} config Configuration object\n * @param {string} config.id Rule ID\n * @param {string} config.field Field name in data\n * @param {string} config.label Human-readable label\n * @param {string} config.optgroup Option group\n * @param {string[]} config.operators Array of supported operators\n * @returns {Object} Configured QueryBuilder rule\n */\nfunction createWordSearchRule(config) {\n  const input1Label = \"Normalization\";\n  const input2Label = \"Transliteration\";\n  return {\n    id: config.id,\n    field: config.field,\n    label: config.label,\n    type: 'string',\n    optgroup: config.optgroup || 'gr_texts',\n    data: {\n      multiField: true,\n    },\n    input: function(rule, name) {\n      return `\n        <div class=\"form-group\">\n          <div class=\"input-group mb-3 pt-2\">\n            <span class=\"input-group-text\" id=\"${name}_normalization_input_span\">${input1Label}</span>\n            <input type=\"text\" id=\"${name}_normalizationInput\" class=\"form-control\" placeholder=\"\" aria-label=\"${input1Label}\" aria-describedby=\"${name}_normalization_input_span\">\n          </div>\n          <div class=\"input-group\">\n            <span class=\"input-group-text\" id=\"${name}_transliteration_input_span\">${input2Label}</span>\n            <input type=\"text\" id=\"${name}_transliterationInput\" class=\"form-control\" placeholder=\"\" aria-label=\"${input2Label}\" aria-describedby=\"${name}_transliteration_input_span\">\n          </div>\n          <div class=\"mt-2\">\n            <div class=\"form-check form-check-inline\">\n              <input class=\"form-check-input\" type=\"radio\" name=\"${name}_personalNamesMode\" value=\"includeAll\" id=\"${name}_includeAddInput\" checked>\n              <label class=\"form-check-label\" for=\"${name}_includeAddInput\">Include personal names</label>\n            </div>\n            <div class=\"form-check form-check-inline\">\n              <input class=\"form-check-input\" type=\"radio\" name=\"${name}_personalNamesMode\" value=\"excludeNames\" id=\"${name}_excludeNamesInput\">\n              <label class=\"form-check-label\" for=\"${name}_excludeNamesInput\">Exclude personal names</label>\n            </div>\n            <div class=\"form-check form-check-inline\">\n              <input class=\"form-check-input\" type=\"radio\" name=\"${name}_personalNamesMode\" value=\"namesOnly\" id=\"${name}_namesOnlyInput\">\n              <label class=\"form-check-label\" for=\"${name}_namesOnlyInput\">Personal names only</label>\n            </div>\n          </div>\n        </div>\n      `;\n    },\n    operators: config.operators || ['contains', 'equal', 'begins_with', 'ends_with'],\n    valueGetter: function(rule) {\n      var $container = rule.$el.find('.rule-value-container');\n      return {\n        normalization: $container.find('[id$=_normalizationInput]').val(),\n        transliteration: $container.find('[id$=_transliterationInput]').val(),\n        names_mode: $container.find('[name$=_personalNamesMode]:checked').val()\n      };\n    },\n    valueSetter: function(rule, value) {\n      const names_mode = value.names_mode || 'includeAll';\n      var $container = rule.$el.find('.rule-value-container');\n      $container.find('[id$=_normalizationInput]').val(value.normalization || '');\n      $container.find('[id$=_transliterationInput]').val(value.transliteration || '');\n      $container.find('[name$=_personalNamesMode][value=\"' + names_mode + '\"]').prop('checked', true);\n    }\n  };\n}\n\n/*export const rundataOperators = [\n  { type: 'texts_contains', nb_inputs: 2, multiple: false, apply_to: ['string'] },\n  { type: 'texts_equal', nb_inputs: 2, multiple: false, apply_to: ['string'] },\n  { type: 'texts_begins_with', nb_inputs: 2, multiple: false, apply_to: ['string'] },\n  { type: 'texts_ends_with', nb_inputs: 2, multiple: false, apply_to: ['string'] },\n];*/\n\nexport function initQueryBuilder(containerId, viewModel, getHumanName) {\n  const dbMap = viewModel.getAllInscriptions();\n  const queryBuilder = $(`#${containerId}`);\n\n  const qbOperators = $.fn.queryBuilder.constructor.DEFAULTS.operators.concat([\n    // Add to default operators\n    { type: 'in_separated_list', nb_inputs: 1, multiple: false, apply_to: ['string'] },\n    { type: 'cross_form', nb_inputs: 1, multiple: false, apply_to: ['string'] },\n  ]);\n  const qbLang = {\n    operators: {\n      'in_separated_list': \"is in |-separated list\",\n      'cross_form': \" \",\n    }\n  };\n  const qbSqlOperators = {\n    'in_separated_list': { 'op': 'IN', mod: '{0}' },\n    'cross_form': { 'op': 'IN' },\n  };\n\n  const signature_text_autocomplete_cfg = {\n    minChars: 0,\n    delay: 100,\n    source: function(term, suggest) {\n      getValuesFromAllData(term, suggest, 'signature_text', dbMap);\n    },\n    menuClass: 'clusterize-content',\n    attachToParent: true,\n  };\n\n  const signature_text_tomselect_cfg = {\n    plugins: ['remove_button'],\n    // options: getValuesFromAllData('', undefined, 'signature_text', dbMap),\n    load: function(query, callback) {\n      let self = this;\n      getValuesFromAllData(query, callback, 'signature_text', dbMap, true);\n      // prevent further loading\n      self.settings.load = null;\n    },\n    // invoke data loading at once\n    preload: true,\n    valueField: 'id',\n    hideSelected: true,\n    delimiter: '|',\n  };\n\n  let queryBuilderFilters = [\n    {\n      id: 'inscription_id',\n      optgroup: 'gr_signature',\n      field: 'signature_text',\n      label: getHumanName('signature_text'),\n      type: 'string',\n      multiple: true,\n      data: {\n        multiField: true,\n      },\n      operators: [\n        'in', 'in_separated_list', 'begins_with', 'not_begins_with',\n        'ends_with', 'not_ends_with', 'contains', 'not_contains',\n      ],\n      valueSetter: function (rule, value) {\n        const $input = rule.$el.find('.rule-value-container input');\n        $input.val(value);\n        adjustTomSelectAndAutoComplete(rule, signature_text_tomselect_cfg, signature_text_autocomplete_cfg);\n      },\n      plugin: 'tomSelect',\n      plugin_config: signature_text_tomselect_cfg,\n    },\n    prepareAutoComplete('carver', dbMap, getHumanName),\n    {\n      id: 'inscription_country',\n      optgroup: \"gr_signature\",\n      field: 'signature_text',\n      label: 'Country or Swedish province',\n      type: 'string',\n      input: 'select',\n      multiple: true,\n      data: {\n        multiField: true,\n      },\n      operators: ['in'],\n      plugin: 'tomSelect',\n      plugin_config: {\n        plugins: ['remove_button'],\n        options: [\n          {text: 'Sweden, whole', value: 'all_sweden'},\n          {text: 'Öland (Öl)', value: 'Öl '}, {text: 'Östergötland (Ög)', value: 'Ög '}, {text: 'Södermanland (Sö)', value: 'Sö '},\n          {text: 'Småland (Sm)', value: 'Sm '}, {text: 'Västergötland (Vg)', value: 'Vg '}, {text: 'Uppland (U)', value: 'U '},\n          {text: 'Västmanland (Vs)', value: 'Vs '}, {text: 'Närke (Nä)', value: 'Nä '}, {text: 'Värmland (Vr)', value: 'Vr '},\n          {text: 'Gästrikland (Gs)', value: 'Gs '}, {text: 'Hälsingland (Hs)', value: 'Hs '}, {text: 'Medelpad (M)', value: 'M '},\n          {text: 'Ångermanland (Ån)', value: 'Ån '}, {text: 'Dalarna (D)', value: 'D '}, {text: 'Härjedalen (Hr)', value: 'Hr '},\n          {text: 'Jämtland (J)', value: 'J '}, {text: 'Lappland (Lp)', value: 'Lp '}, {text: 'Dalsland (Ds)', value: 'Ds '},\n          {text: 'Bohuslän (Bo)', value: 'Bo '}, {text: 'Gotland (G)', value: 'G '}, {text: 'Sweden, other (SE)', value: 'SE '},\n          {text: 'Denmark (DR)', value: 'DR '}, {text: 'Norway (N)', value: 'N '}, {text: 'Faroe Islands (FR)', value: 'FR '},\n          {text: 'Greenland (GR)', value: 'GR '}, {text: 'Iceland (IS)', value: 'IS '}, {text: 'Finland (FI)', value: 'FI '},\n          {text: 'Shetland (Sh)', value: 'Sh '}, {text: 'Orkney (Or)', value: 'Or '}, {text: 'Scotland (Sc)', value: 'Sc '},\n          {text: 'England (E)', value: 'E '}, {text: 'Isle of Man (IM)', value: 'IM '}, {text: 'Ireland (IR)', value: 'IR '},\n          {text: 'France (F)', value: 'F '}, {text: 'Netherlands (NL)', value: 'NL '}, {text: 'Germany (DE)', value: 'DE '},\n          {text: 'Poland (PL)', value: 'PL '}, {text: 'Latvia (LV)', value: 'LV '}, {text: 'Russia (RU)', value: 'RU '},\n          {text: 'Ukraine (UA)', value: 'UA '}, {text: 'Byzantium (By)', value: 'By '}, {text: 'Italy (IT)', value: 'IT '},\n          {text: 'Other areas (X)', value: 'X '}\n        ],\n        hideSelected: true,\n      },\n      valueSetter: function (rule, value) {\n        const $input = rule.$el.find('.rule-value-container select');\n        $input.tomSelect('setValue', value);\n      }\n    },\n    createWordSearchRule({\n      id: 'normalization_norse_to_transliteration',\n      field: 'normalization_norse',\n      label: 'Normalization Norse to Transliteration',\n      optgroup: 'gr_texts',\n    }),\n    createWordSearchRule({\n      id: 'normalization_scandinavian_to_transliteration',\n      field: 'normalisation_scandinavian',\n      label: 'Normalization Scandinavian to Transliteration',\n      optgroup: 'gr_texts',\n    }),\n    prepareAutoComplete('english_translation', dbMap, getHumanName, { optgroup: 'gr_texts' }),\n    prepareAutoComplete('swedish_translation', dbMap, getHumanName, { optgroup: 'gr_texts' }),\n\n    prepareAutoComplete('full_address', dbMap, getHumanName, { optgroup: 'gr_location', operators: ['contains'] }),\n    prepareAutoComplete('found_location', dbMap, getHumanName, { optgroup: 'gr_location' }),\n    prepareAutoComplete('parish', dbMap, getHumanName, { optgroup: 'gr_location' }),\n    prepareAutoComplete('district', dbMap, getHumanName, { optgroup: 'gr_location' }),\n    prepareAutoComplete('municipality', dbMap, getHumanName, { optgroup: 'gr_location' }),\n    prepareAutoComplete('current_location', dbMap, getHumanName, { optgroup: 'gr_location' }),\n    prepareAutoComplete('original_site', dbMap, getHumanName),\n    prepareAutoComplete('parish_code', dbMap, getHumanName, { optgroup: 'gr_location' }),\n    prepareAutoComplete('rune_type', dbMap, getHumanName),\n    prepareAutoComplete('dating', dbMap, getHumanName),\n    prepareIntegerRule('year_from', dbMap, getHumanName, { operators: ['equal', 'less', 'greater', 'between'] }),\n    prepareIntegerRule('year_to', dbMap, getHumanName, { operators: ['equal', 'less', 'greater', 'between'] }),\n    prepareAutoComplete('style', dbMap, getHumanName),\n    prepareAutoComplete('material', dbMap, getHumanName),\n    prepareAutoComplete('material_type', dbMap, getHumanName),\n    prepareAutoComplete('objectInfo', dbMap, getHumanName),\n    prepareAutoComplete('reference', dbMap, getHumanName),\n    prepareAutoComplete('additional', dbMap, getHumanName),\n    prepareIntegerRule('num_crosses', dbMap, getHumanName, { operators: ['equal', 'less', 'greater', 'between'] }),\n    {\n      id: 'cross_form',\n      field: 'crosses',\n      label: getHumanName('cross_form'),\n      operators: ['cross_form'],\n      optgroup: 'other',\n      input: function (rule, name) {\n        // this is a bit of a hack as getValuesFromAllData function is intended for other use\n        const allCrossForms = viewModel.getAllCrossForms().map(item => {\n          return `<option value=\"${item}\">${item}</option>`;\n        }).join('');\n        return `\n          <select name=\"${name}_1\" class=\"form-select\" aria-label=\"Cross form\">${allCrossForms}</select>\n          <div>Certain?\n            <div class=\"form-check form-check-inline\">\n              <input type=\"radio\" name=\"${name}_2\" value=\"0\" class=\"form-check-input\" id=\"${name}_2_0\">\n              <label for=\"${name}_2_0\" class=\"form-check-label\">No</label>\n            </div>\n\n            <div class=\"form-check form-check-inline\">\n              <input type=\"radio\" name=\"${name}_2\" value=\"1\" class=\"form-check-input\" id=\"${name}_2_1\">\n              <label for=\"${name}_2_1\" class=\"form-check-label\">Yes</label>\n            </div>\n\n            <div class=\"form-check form-check-inline\">\n              <input type=\"radio\" name=\"${name}_2\" value=\"2\" class=\"form-check-input\" id=\"${name}_2_2\" checked>\n              <label for=\"${name}_2_2\" class=\"form-check-label\">Doesn't matter</label>\n            </div>\n          </div>`;\n      },\n      valueGetter: function (rule) {\n        const val1 = rule.$el.find('.rule-value-container [name$=_1]').val();\n        const val2 = rule.$el.find('.rule-value-container [name$=_2]:checked').val();\n        return {form: val1, is_certain: val2};\n      },\n      valueSetter: function (rule, value) {\n        $(rule.$el.find('.rule-value-container [name$=_1]')[0]).val(value.form);\n        rule.$el.find(`.rule-value-container [name$=_2][value=${value.is_certain}]`).prop('checked', true);\n      },\n    },\n    {\n      id: 'has_personal_name',\n      label: \"Has personal name(s)?\",\n      field: 'num_names',\n      optgroup: 'other',\n      type: 'integer',\n      input: 'radio',\n      values: [\n        {0: 'No'},\n        {1: 'Yes'},\n      ],\n      default_value: 1,\n      operators: ['equal'],\n    }\n  ];\n\n  const my_rule_template = ({ rule_id, icons, settings, translate, builder }) => {\n    return `\n  <div id=\"${rule_id}\" class=\"rule-container d-flex align-items-center w-100\">\n    <div class=\"rule-header\">\n    </div>\n    ${settings.display_errors ? `\n      <div class=\"error-container flex-shrink-0\"><i class=\"${icons.error}\"></i></div>\n    ` : ''}\n    <div class=\"rule-filter-container flex-shrink-0\"></div>\n    <div class=\"rule-operator-container flex-shrink-0\"></div>\n    <div class=\"rule-value-container flex-grow-1 me-2\"></div>\n    <div class=\"rule-footer d-flex align-items-center ms-auto\">\n      <div class=\"btn-group flex-shrink-0 rule-actions\">\n        <button type=\"button\" class=\"btn btn-sm btn-danger\" data-delete=\"rule\">\n          <i class=\"${icons.remove_rule}\"></i> ${translate(\"delete_rule\")}\n        </button>\n      </div>\n    </div>\n  </div>`;\n  };\n\n  // sort groups\n  queryBuilderFilters = sortGroupsByOrder(queryBuilderFilters, Object.keys(optGroups));\n\n  // swap two first filters, so that signature is on the first place!\n  const tmp = queryBuilderFilters[0];\n  queryBuilderFilters[0] = queryBuilderFilters[1];\n  queryBuilderFilters[1] = tmp;\n\n  queryBuilder.queryBuilder({\n    display_empty_filter: false,\n    //operators: $.fn.queryBuilder.constructor.DEFAULTS.operators.concat(rundataOperators),\n\n    plugins: queryBuilderPlugins,\n    filters: queryBuilderFilters,\n    sort_filters: false,\n    allow_empty: false,\n    optgroups: optGroups,\n\n    operators: qbOperators,\n    lang: qbLang,\n    sqlOperators: qbSqlOperators,\n\n    templates: {\n      rule: my_rule_template,\n    },\n  });\n\n  // Event handler when rule is created and rule operator is changed\n  $('#builder').on('afterCreateRuleInput.queryBuilder afterUpdateRuleOperator.queryBuilder', function(e, rule) {\n    if (rule.filter.id !== 'inscription_id') {\n      return;\n    }\n    adjustTomSelectAndAutoComplete(rule, signature_text_tomselect_cfg, signature_text_autocomplete_cfg);\n  });\n\n}","/*\nThis file contains code to do search in the inscriptions\n*/\n\n/**\n * Normalizes whitespace in a string by replacing all whitespace characters\n * (including non-breaking spaces, tabs, etc.) with regular spaces.\n * This ensures consistent matching regardless of the type of whitespace used.\n * \n * @param {*} value - The value to normalize\n * @returns {string} The normalized string\n */\nfunction normalizeWhitespace(value) {\n  return String(value).replace(/\\s/g, ' ');\n}\n\n// Standard comparison operators that can be used both in QueryBuilderParser and custom search functions\nexport const operators = {\n  equal: (a, b) => a == b,\n  not_equal: (a, b) => a != b,\n  in: (a, b) => b.includes(a),\n  not_in: (a, b) => !b.includes(a),\n  less: (a, b) => a < b,\n  less_or_equal: (a, b) => a <= b,\n  greater: (a, b) => a > b,\n  greater_or_equal: (a, b) => a >= b,\n  between: (a, b) => b[0] <= a && a <= b[1],\n  not_between: (a, b) => !(b[0] <= a && a <= b[1]),\n  begins_with: (a, b) => normalizeWhitespace(a).startsWith(normalizeWhitespace(b)),\n  not_begins_with: (a, b) => !normalizeWhitespace(a).startsWith(normalizeWhitespace(b)),\n  contains: (a, b) => normalizeWhitespace(a).includes(normalizeWhitespace(b)),\n  not_contains: (a, b) => !normalizeWhitespace(a).includes(normalizeWhitespace(b)),\n  ends_with: (a, b) => normalizeWhitespace(a).endsWith(normalizeWhitespace(b)),\n  not_ends_with: (a, b) => !normalizeWhitespace(a).endsWith(normalizeWhitespace(b)),\n  is_empty: (a) => a === '' || a === null || a === undefined || (Array.isArray(a) && a.length === 0),\n  is_not_empty: (a) => a !== '' && a !== null && a !== undefined && (!Array.isArray(a) || a.length > 0),\n  is_null: (a) => a === null || a === undefined,\n  is_not_null: (a) => a !== null && a !== undefined,\n};\n\n/**\n * JavaScript processor for jQuery QueryBuilder rules.\n * This module allows searching through data using rules\n * generated by jQuery QueryBuilder's getRules() function.\n */\n\nexport class QueryBuilderParser {\n  /**\n   * Initialize the parser with standard operators\n   */\n  constructor(customSearchFunctions = {}) {\n    // Use the external operators\n    this.operators = { ...operators };\n    this.customSearchFunctions = customSearchFunctions;\n  }\n\n  /**\n   * Apply rules from jQuery QueryBuilder to filter a list of data.\n   *\n   * @param {Object} rules - Rules object from jQuery QueryBuilder's getRules() method\n   * @param {Array} data - Array of objects (records) to filter\n   * @returns {Array} Filtered list of records with match details\n   */\n  parseRules(rules, data) {\n    if (!rules || !data) {\n      return [];\n    }\n\n    // If rules are invalid, return empty array\n    if (rules.valid === false) {\n      return [];\n    }\n\n    const result = [];\n    // If data is an array, process each item\n    if (Array.isArray(data)) {\n      data.forEach(item => {\n        const resultWithDetails = this._evaluateGroup(rules, item);\n        if (resultWithDetails.match) {\n          result.push({\n            record: item,\n            matchDetails: resultWithDetails.details || null\n          });\n        }\n      });\n    }\n    // If data is any iterable (e.g. a generator, Set, etc.)\n    else if (typeof data[Symbol.iterator] === 'function') {\n      for (const item of data) {\n        const resultWithDetails = this._evaluateGroup(rules, item);\n        if (resultWithDetails.match) {\n          result.push({\n            record: item,\n            matchDetails: resultWithDetails.details || null\n          });\n        }\n      }\n    }\n    // Fallback: if data implements the iterator protocol (has a next() method)\n    else if (typeof data.next === 'function') {\n      let nextItem = data.next();\n      while (!nextItem.done) {\n        const resultWithDetails = this._evaluateGroup(rules, nextItem.value);\n        if (resultWithDetails.match) {\n          result.push({\n            record: nextItem.value,\n            matchDetails: resultWithDetails.details || null\n          });\n        }\n        nextItem = data.next();\n      }\n    } else {\n      throw new Error('Data is not iterable. It must be an array or implement the iterator protocol.');\n    }\n\n    return result;\n  }\n\n  /**\n   * Recursively evaluate a group of rules.\n   *\n   * @param {Object} group - Group object with condition and rules\n   * @param {Object} record - Data record to evaluate against\n   * @returns {Object} Object with match (boolean) and details (object) properties\n   * @private\n   */\n  _evaluateGroup(group, record) {\n    // Helper function to apply negation if needed\n    const applyNegation = (result, shouldNegate) => {\n      if (!shouldNegate) return result;\n\n      return {\n        match: !result.match\n      };\n    };\n\n    if (!group.condition || !group.rules) {\n      return applyNegation({ match: false }, group.not);\n    }\n\n    const condition = group.condition.toUpperCase();\n    const rules = group.rules;\n\n    if (!rules || !rules.length) {\n      return applyNegation({ match: true }, group.not);\n    }\n\n    const results = rules.map(rule => {\n      // If it's a nested group\n      if (rule.rules) {\n        return this._evaluateGroup(rule, record);\n      }\n      // It's a rule\n      else if (rule.id && rule.operator) {\n        return this._evaluateRule(rule, record);\n      }\n      return { match: false };\n    });\n\n    // Combine the results based on the condition\n    let combinedResult = null;\n\n    if (condition === 'AND') {\n      const isMatch = results.every(result => result.match);\n      // For AND condition, we collect all details\n      const combinedDetails = isMatch ?\n        results.reduce((acc, result) => {\n          if (result.details) {\n            Object.entries(result.details).forEach(([field, details]) => {\n              if (!acc[field]) acc[field] = details;\n              else if (Array.isArray(acc[field]) && Array.isArray(details)) {\n                // Merge arrays and remove duplicates\n                acc[field] = [...new Set([...acc[field], ...details])];\n              }\n            });\n          }\n          return acc;\n        }, {}) : null;\n\n      combinedResult = {\n        match: isMatch,\n        details: combinedDetails\n      };\n    } else if (condition === 'OR') {\n      const matchingResults = results.filter(result => result.match);\n      const isMatch = matchingResults.length > 0;\n\n      // For OR condition, we take the first matching details\n      combinedResult = {\n        match: isMatch,\n        details: isMatch ? matchingResults[0].details : null\n      };\n    } else {\n      throw new Error(`Unknown condition: ${condition}`);\n    }\n\n    return applyNegation(combinedResult, group.not);\n  }\n\n  /**\n   * Evaluate a single rule against a record.\n   *\n   * @param {Object} rule - Rule object with id, operator, and value\n   * @param {Object} record - Data record to check against\n   * @returns {Object} Object with match (boolean) and details (object) properties\n   * @private\n   */\n  _evaluateRule(rule, record) {\n    const field = rule.field || rule.id;\n    const operatorName = rule.operator;\n    const isMultiFieldRule = rule.data && rule.data.multiField === true;\n\n    // Fast path: handle custom search functions first\n    if (rule.id &&\n        this.customSearchFunctions[rule.id] &&\n        typeof this.customSearchFunctions[rule.id][operatorName] === \"function\") {\n\n      // For custom functions, provide field value or entire record as needed\n      const valueToCheck = isMultiFieldRule ? record : record[field];\n      const result = this.customSearchFunctions[rule.id][operatorName](valueToCheck, rule.value);\n\n      // Normalize the result to always have match and details properties\n      return typeof result === 'object' && 'match' in result ?\n        result : { match: Boolean(result) };\n    }\n\n    // For standard single-field rules, verify the field exists\n    if (!isMultiFieldRule && !(field in record)) {\n      return { match: false };\n    }\n\n    // For multi-field rules without custom handlers, we can't process with standard operators\n    if (isMultiFieldRule) {\n      return { match: false };\n    }\n\n    const fieldValue = record[field];\n\n    // Handle special operators that don't need a value\n    if (['is_empty', 'is_not_empty', 'is_null', 'is_not_null'].includes(operatorName)) {\n      const result = this.operators[operatorName](fieldValue);\n      return {\n        match: result,\n        details: result ? { [field]: true } : null\n      };\n    }\n\n    // For regular operators, ensure we have a value to compare against\n    const ruleValue = rule.value;\n    if (ruleValue === null || ruleValue === undefined) {\n      return { match: false };\n    }\n\n    if (typeof ruleValue === 'number' && fieldValue === '') {\n      // Handle case where fieldValue is an empty string but ruleValue is a number\n      return { match: false };\n    }\n\n    // Apply the operator and normalize the result\n    const result = this.operators[operatorName](fieldValue, ruleValue);\n    const isMatch = Boolean(result);\n\n    return {\n      match: isMatch,\n      details: isMatch ? { [field]: true } : null\n    };\n  }\n\n  /**\n   * Add a custom operator function.\n   *\n   * @param {string} name - Name of the operator\n   * @param {Function} func - Function that takes two arguments (fieldValue, ruleValue) and returns an object with match and details properties\n   */\n  addOperator(name, func) {\n    this.operators[name] = func;\n  }\n\n  /**\n   * Add a custom type converter.\n   *\n   * @param {string} typeName - Name of the type\n   * @param {Function} func - Function that converts a value to the specified type\n   */\n  addTypeConverter(typeName, func) {\n    this.typeConverters[typeName] = func;\n  }\n}\n\n// Custom search functions using the new interface\nconst searchViaList = (fieldValue, ruleValue) => {\n  const items = ruleValue.split('|');\n  const match = items.some(item => item === fieldValue);\n  return { match };\n};\n\n/**\n * Wrapper function for searching in signature_text and aliases\n * @param {Object} record - The complete record object containing signature_text and aliases\n * @param {string|Array} ruleValue - The value to search for\n * @param {Function} operatorFn - The comparison function to apply (e.g., String.includes, String.startsWith)\n * @param {boolean} [negate=false] - Whether to negate the result\n * @returns {Object} Result object with match property\n */\nconst searchSignatureWrapper = (record, ruleValue, operatorFn, negate = false) => {\n  // Get the main signature text\n  const signatureText = record.signature_text;\n\n  // Get the aliases (if any) as an array\n  const aliases = record.aliases ?\n    record.aliases.split('|').map(a => a.trim()).filter(a => a) :\n    [];\n\n  // Combine into one array of values to check\n  const allSignatures = [signatureText, ...aliases];\n\n  // Process the rule value based on the input type\n  const items = Array.isArray(ruleValue) ? ruleValue :\n    (typeof ruleValue === 'string' && ruleValue.indexOf('|') > -1) ?\n    ruleValue.split('|') :\n    [ruleValue];\n\n  // Apply the operator function to check if any signature matches any item\n  let match = allSignatures.some(sig =>\n    items.some(item => operatorFn(sig, item))\n  );\n\n  // Negate the result if needed\n  if (negate) {\n    match = !match;\n  }\n\n  return { match };\n};\n\nconst doWordSearch = (entry, ruleValue, searchDirection, searchMode) => {\n  const isAHit = getWordSearchFunction(searchMode);\n  // key names defined in valueGetter, e.g. normalization_norse_to_transliteration\n  const normalisationQuery = ruleValue['normalization'];\n  const transliterationQuery = ruleValue['transliteration'];\n  const namesMode = ruleValue['names_mode'];\n\n  // Determine which normalization field to use\n  const normalizationField = searchDirection.includes('norse') ?\n    'normalisation_norse' : 'normalisation_scandinavian';\n\n  const normalWords = entry[`${normalizationField}_words`];\n  const transliterationWords = entry['transliteration_words'];\n\n  let matchFound = false;\n  let matchedWords = [];\n  let numFoundNames = 0;\n\n  // Helper function to check personal name constraints and record matches\n  const processMatch = (index, isPersonal) => {\n    // Skip if filtering by personal names and constraints are not met\n    if ((namesMode === 'excludeNames' && isPersonal) ||\n        (namesMode === 'namesOnly' && !isPersonal)) {\n      return false;\n    }\n\n    matchFound = true;\n    matchedWords.push(index);\n    if (isPersonal) numFoundNames++;\n    return true;\n  };\n\n  // Case 1: Both normalization and transliteration queries are present\n  if (normalisationQuery && transliterationQuery) {\n    for (let i = 0; i < Math.min(normalWords.length, transliterationWords.length); i++) {\n      if (isAHit(normalWords[i], normalisationQuery) && isAHit(transliterationWords[i], transliterationQuery)) {\n        processMatch(i, isPersonalName(normalWords[i]));\n      }\n    }\n  }\n  // Case 2: Only one query type is present\n  else {\n    // Check normalization words\n    if (normalisationQuery) {\n      normalWords.forEach((word, i) => {\n        if (isAHit(word, normalisationQuery)) {\n          processMatch(i, isPersonalName(word));\n        }\n      });\n    }\n\n    // Check transliteration words\n    if (transliterationQuery) {\n      transliterationWords.forEach((word, i) => {\n        if (isAHit(word, transliterationQuery)) {\n          // transliterated words don't contain personal name annotation\n          const isPersonal = (i < normalWords.length) && isPersonalName(normalWords[i]);\n          processMatch(i, isPersonal);\n        }\n      });\n    }\n  }\n\n  return {\n    match: matchFound,\n    details: matchFound ? {\n      wordIndices: matchedWords,\n      numPersonalNames: numFoundNames\n    } : null\n  };\n};\n\nconst searchCrossForm = (crosses, ruleValue) => {\n  if (!crosses || crosses.length === 0) {\n    return { match: false };\n  }\n\n  const ruleIsCertain = parseInt(ruleValue.is_certain, 10);\n  const searchForm = ruleValue.form;\n\n  // Flatten the array structure and search through all elements\n  for (const cross of crosses) {\n    if (!Array.isArray(cross)) continue;\n\n    for (const group of cross) {\n      if (!Array.isArray(group)) continue;\n\n      for (const element of group) {\n        // Check if the form name matches\n        if (element.name === searchForm) {\n          // If certainty doesn't matter (option 2) or certainty matches\n          if (ruleIsCertain === 2 || ruleIsCertain === element.isCertain) {\n            return { match: true };\n          }\n        }\n      }\n    }\n  }\n\n  return { match: false };\n};\n\nconst searchHasPersonalName = (numNames, ruleValue) => {\n  const isMatch = ruleValue === 0 ? numNames === 0 : numNames > 0;\n  return { match: isMatch };\n};\n\nconst searchCountryOrProvince = (entry, ruleValues) => {\n  for (let i = 0; i < ruleValues.length; i++) {\n    // let areaCode = ruleValues[i];\n    if (ruleValues[i] == 'all_sweden') {\n      const areaCodes = ['Öl ', 'Ög ', 'Sö ', 'Sm ', 'Vg ', 'U ', 'Vs ', 'Nä ', 'Vr ', 'Gs ', 'Hs ', 'M ', 'Ån ', 'D ', 'Hr ', 'J ', 'Lp ', 'Ds ', 'Bo ', 'G ', 'SE ', 'Bo'];\n      for (let j = 0; j < areaCodes.length; j++) {\n        if (operators.begins_with(entry['signature_text'], areaCodes[j])) {\n          return { match: true };\n        }\n      }\n      const districts = ['Skåne', 'Halland', 'Blekinge'];\n      for (let j = 0; j < districts.length; j++) {\n        if (operators.contains(entry['district'], districts[j])) {\n          return { match: true };\n        }\n      }\n      return { match: false };\n    }\n    if (operators.begins_with(entry['signature_text'], ruleValues[i])) {\n      return { match: true };\n    }\n  }\n  return { match: false };\n}\n\nconst customSearchFunctions = {\n  inscription_id: {\n    in: (record, ruleValue) => searchSignatureWrapper(record, ruleValue, operators.equal),\n    in_separated_list: (record, ruleValue) => searchSignatureWrapper(record, ruleValue, operators.equal),\n    begins_with: (record, ruleValue) => searchSignatureWrapper(record, ruleValue, operators.begins_with),\n    not_begins_with: (record, ruleValue) => searchSignatureWrapper(record, ruleValue, operators.begins_with, true),\n    ends_with: (record, ruleValue) => searchSignatureWrapper(record, ruleValue, operators.ends_with),\n    not_ends_with: (record, ruleValue) => searchSignatureWrapper(record, ruleValue, operators.ends_with, true),\n    contains: (record, ruleValue) => searchSignatureWrapper(record, ruleValue, operators.contains),\n    not_contains: (record, ruleValue) => searchSignatureWrapper(record, ruleValue, operators.contains, true),\n    equal: (record, ruleValue) => searchSignatureWrapper(record, ruleValue, operators.equal),\n    not_equal: (record, ruleValue) => searchSignatureWrapper(record, ruleValue, operators.not_equal),\n  },\n  inscription_country: {\n    in: searchCountryOrProvince,\n  },\n  normalization_norse_to_transliteration: {\n    contains: (fieldValue, ruleValue) => {\n      return doWordSearch(fieldValue, ruleValue, 'norseToTransliteration', 'includes');\n    },\n    equal: (fieldValue, ruleValue) => {\n      return doWordSearch(fieldValue, ruleValue, 'norseToTransliteration', 'exact');\n    },\n    begins_with: (fieldValue, ruleValue) => {\n      return doWordSearch(fieldValue, ruleValue, 'norseToTransliteration', 'beginsWith');\n    },\n    ends_with: (fieldValue, ruleValue) => {\n      return doWordSearch(fieldValue, ruleValue, 'norseToTransliteration', 'endsWith');\n    },\n  },\n  normalization_scandinavian_to_transliteration: {\n    contains: (fieldValue, ruleValue) => {\n      return doWordSearch(fieldValue, ruleValue, 'scandinavianToTransliteration', 'includes');\n    },\n    equal: (fieldValue, ruleValue) => {\n      return doWordSearch(fieldValue, ruleValue, 'scandinavianToTransliteration', 'exact');\n    },\n    begins_with: (fieldValue, ruleValue) => {\n      return doWordSearch(fieldValue, ruleValue, 'scandinavianToTransliteration', 'beginsWith');\n    },\n    ends_with: (fieldValue, ruleValue) => {\n      return doWordSearch(fieldValue, ruleValue, 'scandinavianToTransliteration', 'endsWith');\n    },\n  },\n  cross_form: {\n    cross_form: searchCrossForm,\n  },\n  has_personal_name: {\n    equal: searchHasPersonalName,\n    not_equal: (fieldValue, ruleValue) => {\n      const result = searchHasPersonalName(fieldValue, ruleValue);\n      return { match: !result.match };\n    },\n  },\n};\n\n/**\n * Returns a word search function based on the specified search mode\n * @param {string} searchMode - The search mode ('exact', 'beginsWith', 'endsWith', 'regex', 'includes')\n * @param {Object} options - Additional options\n * @param {boolean} [options.ignoreCase=false] - Whether to ignore case when searching\n * @returns {Function} A search function that takes (word, query) parameters\n * @throws {Error} When an invalid regex pattern is provided in regex mode\n */\nexport function getWordSearchFunction(searchMode, options = {}) {\n  const { ignoreCase = false } = options;\n\n  // Create a function to handle case sensitivity\n  const prepareString = ignoreCase\n    ? str => String(str).toLowerCase()\n    : str => String(str);\n\n  const prepareWord = (word) => {\n    // Check if this might be a list of personal names (divided by HTML escaped / symbol)\n    if (word.includes('&#x2F;') || word.includes('/')) {\n      // Split by the HTML escaped slash or regular slash\n      const names = word.split(/&#x2F;|\\//).map(name => {\n        // Trim whitespace and remove quotes (both regular and HTML escaped) from the beginning\n        return name.trim().replace(/^(&quot;|\")/, '');\n      });\n      // Return the array of individual names\n      return names;\n    }\n\n    // If it's not a list, just return the original word\n    return [word];\n  }\n\n  switch (searchMode) {\n    case 'exact':\n      return (word, query) => {\n        const words = prepareWord(word);\n        // Check if any of the words match the query\n        return words.some(w => prepareString(w) === prepareString(query));\n      }\n\n    case 'beginsWith':\n      return (word, query) => {\n        const words = prepareWord(word);\n        // Check if any of the words start with the query\n        return words.some(w => prepareString(w).startsWith(prepareString(query)));\n      }\n\n    case 'endsWith':\n      return (word, query) => {\n        const words = prepareWord(word);\n        // Check if any of the words end with the query\n        return words.some(w => prepareString(w).endsWith(prepareString(query)));\n      }\n\n    case 'regex': {\n      return (word, query) => {\n        try {\n          const flags = ignoreCase ? 'i' : '';\n          // Create RegExp only once per query\n          const regex = new RegExp(query, flags);\n          return regex.test(word);\n        } catch (error) {\n          throw new Error(`Invalid regex pattern: ${query}`);\n        }\n      };\n    }\n\n    case 'includes':\n    default:\n      return (word, query) => {\n        const words = prepareWord(word);\n        // Check if any of the words include the query\n        return words.some(w => prepareString(w).includes(prepareString(query)));\n      }\n  }\n}\n\n\n/**\n * Perform a search using QueryBuilder rules\n * @param {Object} rules - Rules object from jQuery QueryBuilder's getRules() method\n * @param {Array|Iterable} dbMap - Data to search through\n * @returns {Array} Array of objects that match search rules. Each item includes record data from\n *                  dbMap and matchDetails property with details of the match.\n */\nexport function doSearch(rules, dbMap) {\n  const parser = new QueryBuilderParser(customSearchFunctions);\n  const resultsRaw = parser.parseRules(rules, dbMap);\n  const results = resultsRaw.map(({ record, matchDetails }) => ({\n    ...record,\n    matchDetails\n  }));\n\n  return results;\n}\n\nexport function calcWordsAndPersonalNames(dbMap) {\n  let totalWordMatches = 0;\n  let totalPersonalNames = 0;\n  let totalSignatures = 0;\n\n  try {\n    const entries = dbMap.values();\n    for (const entry of entries) {\n      if (entry.matchDetails && entry.matchDetails.wordIndices) {\n        totalWordMatches += entry.matchDetails.wordIndices.length;\n        totalPersonalNames += entry.matchDetails.numPersonalNames;\n      } else {\n        totalWordMatches += entry.normalisation_norse_word_boundaries.length;\n        entry.normalisation_norse_word_boundaries.forEach(boundary => {\n          totalPersonalNames += boundary.isPersonal;\n        });\n      }\n      totalSignatures++;\n    }\n  } catch (error) {\n    console.error('Error calculating words and personal names:', error);\n  }\n\n  $(document).trigger('updateSignatureCount', { count: totalSignatures });\n  $(document).trigger('updateWordCount', { count: totalWordMatches });\n  $(document).trigger('updatePersonalNameCount', { count: totalPersonalNames });\n}\n\nexport function highlightWordsFromWordBoundaries(str, wordBoundaries) {\n  // Sort the indices to ensure they are processed in the correct order\n  wordBoundaries.sort((a, b) => a.start - b.start);\n\n  let highlightedStr = '';\n  let lastIndex = 0;\n\n  wordBoundaries.forEach(({start, end, text}) => {\n    // Append the part of the string before the current word\n    highlightedStr += str.slice(lastIndex, start);\n    // Wrap the word in a <span> tag and append it\n    highlightedStr += `<span class=\"highlight\">${str.slice(start, end)}</span>`;\n    // Update the lastIndex to the end of the current word\n    lastIndex = end;\n  });\n\n  // Append the remaining part of the string after the last word\n  highlightedStr += str.slice(lastIndex);\n\n  return highlightedStr;\n}\n","// view-model.js\nexport class RunicViewModel {\n  constructor(dbMap) {\n    this.dbMap = dbMap;            // Original data source\n    this.searchResults = null;     // Last search results (or null if no search active)\n    this.currentSelectionIds = []; // Currently selected IDs\n    this.allCrossForms = new Set();\n\n    for (const inscription of dbMap.values()) {\n      if (inscription.crosses && Array.isArray(inscription.crosses)) {\n        for (const cross of inscription.crosses) {\n          if (Array.isArray(cross)) {\n            for (const group of cross) {\n              if (Array.isArray(group)) {\n                for (const element of group) {\n                  this.allCrossForms.add(element.name);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    this.allCrossForms = Array.from(this.allCrossForms).sort();\n  }\n  \n  // Get data for a specific ID, prioritizing search results if available\n  getInscriptionData(id) {\n    if (this.searchResults && this.searchResults.has(id)) {\n      return this.searchResults.get(id);\n    }\n    return this.dbMap.get(id);\n  }\n\n  getAllCrossForms() {\n    return this.allCrossForms;\n  }\n\n  getInscriptions(ids) {\n    if (this.searchResults && this.searchResults.size > 0) {\n      return ids.map(id => this.searchResults.get(parseInt(id, 10)));\n    }\n    return ids.map(id => this.dbMap.get(parseInt(id, 10)));\n  }\n  \n  /**\n   * Retrieves all inscriptions from the database map.\n   * @returns {Iterator} An iterator over all values in the database map.\n   */\n  getAllInscriptions() {\n    return this.dbMap;\n  }\n\n  // Get all currently active inscriptions (filtered by search if a search is active)\n  getActiveInscriptions() {\n    if (this.searchResults) {\n      return Array.from(this.searchResults.values());\n    }\n    return Array.from(this.dbMap.values());\n  }\n  \n  // Get all currently active inscription IDs (filtered by search if a search is active)\n  getActiveInscriptionIds() {\n    if (this.searchResults) {\n      return Array.from(this.searchResults.keys());\n    }\n    return Array.from(this.dbMap.keys());\n  }\n\n  // Update search results\n  setSearchResults(results) {\n    if (!results) {\n      this.searchResults = null;\n      return;\n    }\n    \n    // Convert array to Map for O(1) lookups\n    this.searchResults = new Map();\n    results.forEach(result => {\n      this.searchResults.set(result.id, result);\n    });\n    \n    // Update current selection to match search results\n    // this.currentSelectionIds = Array.from(this.searchResults.keys());\n    \n    // Notify subscribers that data has changed\n    $(document).trigger('viewModelUpdated', { \n      source: 'search',\n      count: this.searchResults.size,\n      model: this\n    });\n  }\n\n  // Clear search results\n  clearSearchResults() {\n    this.searchResults = null;\n    //this.currentSelectionIds = Array.from(this.dbMap.keys());\n    \n    $(document).trigger('viewModelUpdated', { \n      source: 'reset',\n      count: this.dbMap.size,\n      model: this\n    });\n  }\n  \n  // Update current selections\n  // setSelection(ids) {\n  //   this.currentSelectionIds = ids;\n  //   $(document).trigger('selectionChanged', { ids });\n  // }\n}","function handleImportWrapper(evt) {\n  handleFiles(evt.target.files);\n  closeResultsIoModal();\n\n  // reset form, so that we can import the same file again if we need to\n  $('form#form-signature-import').get(0).reset();\n}\n\nfunction handleFiles(files) {\n  if (files.length == 0) {\n    return;\n  }\n  var fileReader = new FileReader();\n  var file = files[0]; // be sure to take just a single file\n  fileReader.onloadend = function(evt) {\n    if (evt.target.readyState == FileReader.DONE) {\n      $('#loading-sub-text').html('This dialog will disappear once data is ready');\n      showLoading();\n      setTimeout(importSignaturesHandler, 10, evt.target.result);\n    }\n  }\n  fileReader.readAsText(file);\n}\n\nfunction handleDrop(e) {\n  let dt = e.dataTransfer;\n  let files = dt.files;\n\n  handleFiles(files);\n  closeResultsIoModal();\n}\n\n// Event handler that stops event propagation. Used for drag and drop support\nfunction preventDefaults (e) {\n  e.preventDefault()\n  e.stopPropagation()\n}\nfunction highlight(e) {\n  dropArea.classList.add('highlight')\n}\n\nfunction unhighlight(e) {\n  dropArea.classList.remove('highlight')\n}\n\n// Import list of signatures provided from a file\n// Function argument fileContent is the actual file content.\nfunction importSignaturesHandler(fileContent) {\n  if (fileContent === null) {\n    return;\n  }\n  if (/[\\x00-\\x08\\x0E-\\x1F]/.test(fileContent)) {\n    alert(\"Seems like the file you've selected is not textual. Please select a different file.\");\n    hideLoading();\n    return;\n  }\n\n  const csvData = Papa.parse(fileContent);\n  let numLines = csvData.data.length;\n  let firstDataRow = 0;\n  let signatureColumn = 0;\n  let multiline = false;\n  let numEntries = 0;\n  let values = [];\n\n  if (numLines == 2) {\n    // check if csvData.data[1] is a string or array\n    if (typeof csvData.data[1] === 'string') {\n      if (csvData.data[1].trim().length == 0) {\n        numLines = 1;\n      }\n    } else {\n      if (csvData.data[1][0].trim().length == 0) {\n        numLines = 1;\n      }\n    }\n  }\n\n  if (numLines > 1) {\n    let signatureCandidate = csvData.data[0].findIndex(item => 'signature' === item.toLowerCase());\n    if (signatureCandidate != -1) {\n      firstDataRow = 1;\n      signatureColumn = signatureCandidate;\n    }\n\n    numEntries = csvData.data.length;\n    for (var i = firstDataRow; i < numEntries; i++) {\n      // iterate over rows\n      if (!csvData.data[i][signatureColumn] || csvData.data[i][signatureColumn].trim().length == 0) {\n        continue;\n      }\n      values.push(csvData.data[i][signatureColumn].trim());\n    }\n  } else {\n    // single line, treat every value as a signature\n    numEntries = csvData.data[0].length;\n    for (var i = 0; i < numEntries; i++) {\n      // iterate over columns\n      if (!csvData.data[0][i] || csvData.data[0][i].trim().length == 0) {\n        continue;\n      }\n      values.push(csvData.data[0][i].trim());\n    }\n  }\n\n  // Concatenate values into a string with '|' as separator\n  values = values.join('|');\n\n  var rule = [{\n    id: \"signature_text\",\n    field: \"signature_text\",\n    type: \"string\",\n    input: \"text\",\n    operator: \"in_separated_list\",\n    value: values,\n    ignoreCase: false,\n  }];\n\n  var allRules = {\n    condition: 'OR',\n    rules: rule,\n    not: false,\n  };\n\n  $(`#${inpQueryBuilder}`).queryBuilder('setRules', allRules, true);\n  // doSearch();\n  hideLoading();\n  // After importing signatures, automatically trigger the search\n  document.getElementById('btnSearch').click();\n}\n\nexport function initDragAndDrop() {\n  const dropArea = document.getElementById('drop-area');\n  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {\n    dropArea.addEventListener(eventName, preventDefaults, false)\n  });\n  ['dragenter', 'dragover'].forEach(eventName => {\n    dropArea.addEventListener(eventName, highlight, false)\n  });\n  ['dragleave', 'drop'].forEach(eventName => {\n    dropArea.addEventListener(eventName, unhighlight, false)\n  });\n  dropArea.addEventListener('drop', handleDrop, false);\n  document.getElementById('fileElem').addEventListener('change', handleImportWrapper, false);\n}\n","// src/index.js\nimport * as module1 from './index_scripts.js';\nimport * as module2 from './index_multiselect.js';\nimport * as map_module from './index_map.js';\nimport * as query_builder_module from './index_query_builder.js';\nimport * as search_module from './index_search.js';\nimport * as view_model_module from './index_view_model.js';\nimport * as import_utils_module from './index_import_utils.js';\n\nObject.assign(window, module1, module2, map_module, query_builder_module, search_module, view_model_module, import_utils_module);"],"names":["schemaFieldsInfo","schemaName","text","en","css","highlight","normalizationWordsToSkip","transliterationWordsToSkip","gRenderInProgress","isPersonalName","word","startsWith","includes","getWordBoundaries","str","sourceIsEscaped","wordBoundariesSource","punctuationSource","reg","RegExp","escapeHtml","purePunctuation","words","arr","wordBegin","processWord","wordEnd","wordText","slice","punctuationCheck","exec","length","oneWord","start","end","isPersonal","index","push","prepareSignumForDisplay","signature_text","lost","new_reading","additional","fetchAllImages","db","allRows","values","allImages","i","row","metaId","hasOwnProperty","links","indirect","direct","makeImagesMarkup","signatureImageLinks","directImages","indirectImages","galleryLinks","offsetIndirectImages","map","v","indirectImagesLinks","crossesForMeta","contents","lastCrossId","crosses","crossId","parseInt","Array","apply","formName","groupId","isCertain","name","setTooltip","el","message","that","$","attr","tooltip","setTimeout","renderSignatures","selectedSignatureIds","jstree","get_selected","html","inscriptions2markup","gViewModel","getInscriptions","document","getElementById","innerHTML","join","e","console","error","string","entityMap","String","replace","s","inscriptions","showHeaders","is","userSelectedFields","getUserSelectedFields","markupData","inscriptionData","signatureId","id","signatureName","paragraph","j","field","columnName","humanName","cssStyle","shouldHighlight","columnData","toString","matchDetails","entryWordBoundaries","matchedWords","wordIndices","matchedWordBoundaries","filter","_","highlightWordsFromWordBoundaries","indexOf","parts","split","sidesHeader","forEach","part","trim","allCrosses","k","gr","res","getCrossUrl","isCerain","onExportError","hideLoading","gExportInProgress","showAlert","alertObj","textContent","style","display","hide","closeResultsIoModal","modal","a","b","content","columns","numCrossesColumn","metaColumn","wordColumns","allDbImages","numDiffers","dbArray","objSignature","transliteration","wordsToSkip","normalisation_norse_word_boundaries","normalisation_scandinavian_word_boundaries","transliteration_word_boundaries","boundary","imagesMarkup","numCrosses","dbAsJson","Map","inscription","set","log","displaySignatureInfo","lang","find","querySelectorAll","button","addEventListener","symbol","innerText","navigator","clipboard","writeText","then","catch","err","container","dbMap","option","createElement","value","signature_display","appendChild","from","normalizedText","normalize","icon","signature","data","buffer","blob","Blob","type","link","href","URL","createObjectURL","download","body","click","removeChild","root","get_node","select_node","children","description","txtLoadingDescription","show","gUserSelectedDisplayKey","gShowHeadersKey","storageAvailable","storage","window","x","setItem","removeItem","DOMException","code","getUserSelectedDisplay","defaults","getItem","JSON","parse","saveUserSelectedDisplay","selectedValues","selectedValuesArray","stringify","concat","setMultiselectOptions","sortValue","empty","schemaField","prop","append","onDisplayFormatClicked","preventDefault","val","toArray","lastShowHeaders","localStorage","lastUserSelectedValues","arraysEqual","trigger","this","prev","defaultSelectedValues","savedSelected","savedShowHeaders","multiselect","keepRenderingSortRight","skipInitSortRight","sort","left","right","event","isMobileDevice","test","userAgent","inscription2marker","lat","lon","leaflet","L","marker","popupText","lng","isSafari","Error","getGeoIntentURL","bindPopup","autoClose","bindTooltip","permanent","openTooltip","divId","center","zoom","fullscreenControl","setView","tileLayer","maxZoom","attribution","addTo","control","locate","strings","title","markers","markerClusterGroup","showCoverageOnHover","chunkedLoading","maxClusterRadius","on","scrollToInscription","layer","options","mapMarkers","key","found_lat","parseFloat","latitude","found_lon","longitude","present_lat","present_latitude","present_lon","present_longitude","marker_found","has","found","present","get","marker_present","mapContainerId","menuItemId","mapContainerJquery","menuItemJquery","toggle","preserveMapArea","showOriginalLocation","inscriptionIds","allMarkers","mapObject","markersLayer","markersLatLon","clearLayers","inscriptionMarkers","markerToShow","addLayers","getLatLng","fitBounds","queryBuilderPlugins","sortable","optGroups","gr_signature","sv","gr_texts","gr_location","other","fn","queryBuilder","define","self","$el","$rule","closest","constructor","selectors","rule_container","rule","getModel","ignoreCase","model","node","Rule","updateRuleCaseIgnore","__","input","cssSelectorPluginCaseRule","disable_template","h","$h","parseHTML","rule_actions","prepend","icon_checked","translate","json","sqlFn","utils","defineModelProperties","sortGroupsByOrder","items","groupOrder","group","groups","item","groupKey","Object","keys","labelA","label","labelB","localeCompare","result","getMinMaxValues","dataSource","fieldName","min","max","hasValues","processItem","undefined","isNaN","isArray","getValuesFromAllData","term","suggest","isTomSelect","allValues","uniqueTracker","Set","nextArtificialId","visited","add","score","aliases","alias","normalizedTerm","toLowerCase","prepareAutoComplete","ruleId","humanNameGetter","opt","fieldId","operators","size","optgroup","plugin","plugin_config","minChars","delay","source","menuClass","attachToParent","prepareIntegerRule","config","dataLimitValues","step","validation","allow_empty_value","default_value","adjustTomSelectAndAutoComplete","tomSelectConfig","autoCompleteConfig","$input","operator","tomSelect","hasClass","autoComplete","createWordSearchRule","input1Label","input2Label","multiField","valueGetter","$container","normalization","names_mode","valueSetter","extend","containerId","viewModel","getHumanName","getAllInscriptions","qbOperators","DEFAULTS","nb_inputs","multiple","apply_to","signature_text_autocomplete_cfg","signature_text_tomselect_cfg","plugins","load","query","callback","settings","preload","valueField","hideSelected","delimiter","queryBuilderFilters","getAllCrossForms","form","is_certain","tmp","display_empty_filter","filters","sort_filters","allow_empty","optgroups","in_separated_list","cross_form","sqlOperators","op","mod","templates","rule_id","icons","builder","display_errors","remove_rule","normalizeWhitespace","equal","not_equal","in","not_in","less","less_or_equal","greater","greater_or_equal","between","not_between","begins_with","not_begins_with","contains","not_contains","ends_with","endsWith","not_ends_with","is_empty","is_not_empty","is_null","is_not_null","QueryBuilderParser","customSearchFunctions","parseRules","rules","valid","resultWithDetails","_evaluateGroup","match","record","details","Symbol","iterator","next","nextItem","done","applyNegation","shouldNegate","condition","not","toUpperCase","results","_evaluateRule","combinedResult","isMatch","every","reduce","acc","entries","matchingResults","operatorName","isMultiFieldRule","valueToCheck","Boolean","fieldValue","ruleValue","addOperator","func","addTypeConverter","typeName","typeConverters","searchSignatureWrapper","operatorFn","negate","allSignatures","some","sig","doWordSearch","entry","searchDirection","searchMode","isAHit","getWordSearchFunction","normalisationQuery","transliterationQuery","namesMode","normalWords","transliterationWords","matchFound","numFoundNames","processMatch","Math","numPersonalNames","searchHasPersonalName","numNames","inscription_id","inscription_country","ruleValues","areaCodes","districts","normalization_norse_to_transliteration","normalization_scandinavian_to_transliteration","ruleIsCertain","searchForm","cross","element","has_personal_name","prepareString","prepareWord","w","totalWordMatches","totalPersonalNames","totalSignatures","count","wordBoundaries","highlightedStr","lastIndex","searchResults","currentSelectionIds","allCrossForms","getInscriptionData","ids","getActiveInscriptions","getActiveInscriptionIds","setSearchResults","clearSearchResults","handleImportWrapper","evt","handleFiles","target","files","reset","fileReader","FileReader","file","onloadend","readyState","DONE","showLoading","importSignaturesHandler","readAsText","handleDrop","dataTransfer","preventDefaults","stopPropagation","dropArea","classList","unhighlight","remove","fileContent","alert","csvData","Papa","numLines","firstDataRow","signatureColumn","numEntries","signatureCandidate","findIndex","allRules","inpQueryBuilder","eventName","assign","module1","module2","map_module","query_builder_module","search_module","view_model_module","import_utils_module"],"mappings":"yBAAO,MAAMA,EAAmB,CAC9B,CACEC,WAAY,iBACZC,KAAM,CACJC,GAAM,gBAGV,CACEF,WAAY,eACZC,KAAM,CACJC,GAAM,iBAGV,CACEF,WAAY,iBACZC,KAAM,CACJC,GAAM,mBAGV,CACEF,WAAY,SACZC,KAAM,CACJC,GAAM,WAGV,CACEF,WAAY,WACZC,KAAM,CACJC,GAAM,aAGV,CACEF,WAAY,eACZC,KAAM,CACJC,GAAM,iBAGV,CACEF,WAAY,mBACZC,KAAM,CACJC,GAAM,qBAGV,CACEF,WAAY,gBACZC,KAAM,CACJC,GAAI,kBAGR,CACEF,WAAY,cACZC,KAAM,CACJC,GAAI,gBAGR,CACEF,WAAY,YACZC,KAAM,CACJC,GAAI,cAGR,CACEF,WAAY,SACZC,KAAM,CACJC,GAAI,WAGR,CACEF,WAAY,YACZC,KAAM,CACJC,GAAI,gBAGR,CACEF,WAAY,UACZC,KAAM,CACJC,GAAI,cAGR,CACEF,WAAY,QACZC,KAAM,CACJC,GAAI,UAGR,CACEF,WAAY,SACZC,KAAM,CACJC,GAAI,WAGR,CACEF,WAAY,WACZC,KAAM,CACJC,GAAI,aAGR,CACEF,WAAY,gBACZC,KAAM,CACJC,GAAI,kBAGR,CACEF,WAAY,aACZC,KAAM,CACJC,GAAI,uBAGR,CACEF,WAAY,YACZC,KAAM,CACJC,GAAI,eAGR,CACEF,WAAY,aACZC,KAAM,CACJC,GAAI,sBAGR,CACEF,WAAY,sBACZC,KAAM,CACJC,GAAI,mCAENC,IAAK,gBACLC,WAAW,GAEb,CACEJ,WAAY,6BACZC,KAAM,CACJC,GAAI,qCAENC,IAAK,gBACLC,WAAW,GAEb,CACEJ,WAAY,sBACZC,KAAM,CACJC,GAAI,2BAGR,CACEF,WAAY,sBACZC,KAAM,CACJC,GAAI,2BAGR,CACEF,WAAY,kBACZC,KAAM,CACJC,GAAI,6BAENC,IAAK,kBACLC,WAAW,GAEb,CACEJ,WAAY,cACZC,KAAM,CACJC,GAAI,sBAGR,CACEF,WAAY,aACZC,KAAM,CACJC,GAAI,eAGR,CACEF,WAAY,UACZC,KAAM,CACJC,GAAI,UAGR,CACEF,WAAY,SACZC,KAAM,CACJC,GAAI,YASJG,EAA2B,CAC/B,QAAS,CAAC,EAAG,GACb,OAAQ,CAAC,GAAI,IACb,QAAS,CAAC,GAAI,IACd,SAAU,CAAC,GAAI,IACf,OAAQ,CAAC,GAAI,IACb,QAAS,CAAC,EAAG,GACb,QAAS,CAAC,GACV,SAAU,CAAC,IACX,SAAU,CAAC,IACX,SAAU,CAAC,GACX,SAAU,CAAC,IACX,SAAU,CAAC,GACX,SAAU,CAAC,IACX,QAAS,CAAC,GACV,SAAU,CAAC,GACX,OAAQ,CAAC,GACT,SAAU,CAAC,GACX,QAAS,CAAC,GACV,QAAS,CAAC,GACV,QAAS,CAAC,GACV,QAAS,CAAC,IACV,QAAS,CAAC,GACV,QAAS,CAAC,GACV,OAAQ,CAAC,GACT,OAAQ,CAAC,IACT,eAAgB,CAAC,IACjB,gBAAiB,CAAC,IAClB,QAAS,CAAC,GACV,QAAS,CAAC,IACV,QAAS,CAAC,IACV,OAAQ,CAAC,GACT,QAAS,CAAC,IACV,QAAS,CAAC,GACV,OAAQ,CAAC,IACT,aAAc,CAAC,IACf,eAAgB,CAAC,IACjB,eAAgB,CAAC,GACjB,eAAgB,CAAC,IACjB,eAAgB,CAAC,IACjB,SAAU,CAAC,GACX,SAAU,CAAC,IACX,SAAU,CAAC,IACX,SAAU,CAAC,IACX,SAAU,CAAC,IACX,SAAU,CAAC,GACX,SAAU,CAAC,GACX,SAAU,CAAC,IACX,SAAU,CAAC,IACX,QAAS,CAAC,GACV,QAAS,CAAC,IACV,QAAS,CAAC,GACV,QAAS,CAAC,IACV,QAAS,CAAC,IACV,QAAS,CAAC,GACV,QAAS,CAAC,IACV,QAAS,CAAC,IACV,QAAS,CAAC,IACV,QAAS,CAAC,IACV,QAAS,CAAC,IACV,SAAU,CAAC,IACX,QAAS,CAAC,IACV,gBAAiB,CAAC,GAClB,SAAU,CAAC,GACX,SAAU,CAAC,GACX,SAAU,CAAC,IACX,SAAU,CAAC,GACX,SAAU,CAAC,IACX,SAAU,CAAC,IACX,SAAU,CAAC,GACX,QAAS,CAAC,GACV,QAAS,CAAC,IACV,QAAS,CAAC,GACV,SAAU,CAAC,IAGPC,EAA6B,CACjC,YAAa,CAAC,IACd,QAAS,CAAC,GACV,eAAgB,CAAC,GACjB,QAAS,CAAC,GACV,QAAS,CAAC,GACV,UAAW,CAAC,GACZ,eAAgB,CAAC,GACjB,cAAe,CAAC,EAAG,IACnB,QAAS,CAAC,IACV,QAAS,CAAC,GACV,QAAS,CAAC,IACV,OAAQ,CAAC,IACT,SAAU,CAAC,IACX,QAAS,CAAC,IAIZ,IAAIC,GAAoB,EAsBjB,SAASC,EAAeC,GAC7B,OAAOA,EAAKC,WAAW,MAAQD,EAAKC,WAAW,WAC1CD,EAAKE,SAAS,OAASF,EAAKE,SAAS,UAC5C,CAUA,SAASC,EAAkBC,EAAKC,GAAkB,GAEhD,MAAMC,EAAuB,4DAEvBC,EAAoB,2CAEpBC,EAAM,IAAIC,OAAOJ,EAAkBK,EAAWJ,GAAwBA,EAAsB,KAE5FK,EAAkB,IAAIF,OAAOJ,EAAkBK,EAAWH,GAAqBA,GAE/EK,EAAQ,GACd,IAuCIC,EAvCAC,EAAY,EAEhB,SAASC,EAAYD,EAAWE,GAC9B,MAAMC,EAAWb,EAAIc,MAAMJ,EAAWE,GAGtC,GAA4C,OAAxCZ,EAAIc,MAAMJ,EAAWA,EAAY,GACnC,OAAO,KAGT,GAA0C,OAAtCV,EAAIc,MAAMJ,EAAWA,EAAU,GACjC,OAAO,KAIT,MAAMK,EAAmBR,EAAgBS,KAAKH,GAC9C,GAAIE,GAAoBA,EAAiB,GAAGE,SAAWJ,EAASI,OAC9D,OAAO,KAIT,GAAgB,KAAZJ,EACF,OAAO,KAIT,MAAMK,EAAU,CACdC,MAAOT,EACPU,IAAKR,EACLxB,KAAMyB,EACNQ,WAAY,GAMd,OAFAH,EAAQG,WAAa1B,EAAekB,GAAY,EAAI,EAE7CK,CACX,CAGE,KAAiC,QAAzBT,EAAML,EAAIY,KAAKhB,KAAgB,CACrC,GAAIU,IAAcD,EAAIa,MAAO,CAC3BZ,GAAaD,EAAI,GAAGQ,OACpB,QACN,CACI,MAAMC,EAAUP,EAAYD,EAAWD,EAAIa,OACvCJ,GACFV,EAAMe,KAAKL,GAEbR,EAAYD,EAAIa,MAAQb,EAAI,GAAGQ,MACnC,CAGE,GAAIP,EAAYV,EAAIiB,OAAQ,CAC1B,MAAMC,EAAUP,EAAYD,EAAWV,EAAIiB,QACvCC,GACFV,EAAMe,KAAKL,EAEjB,CAEE,OAAOV,CACT,CA2HO,SAASgB,GAAwBC,eAACA,EAAcC,KAAEA,EAAIC,YAAEA,IAC7D,IAAIC,EAAa,GAWjB,OAVIF,IACFE,GAAc,KAEZD,IACFC,GAAc,KAEZA,EAAWX,OAAS,IACtBW,EAAa,IAAMA,GAGdH,EAAiBG,CAC1B,CAEO,SAASC,EAAeC,GAC7B,MACMC,EADUD,EAAGd,KAAK,6DACA,GAAGgB,OAE3B,IAAIC,EAAY,CAAE,EAElB,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAQd,OAAQiB,IAAK,CACvC,MAAMC,EAAMJ,EAAQG,GACdE,EAASD,EAAI,GACdF,EAAUI,eAAeD,KAC5BH,EAAUG,GAAU,CAACE,MAAO,KAE9BL,EAAUG,GAAQE,MAAMf,KAAK,CAACgB,SAAUJ,EAAI,GAAIK,OAAQL,EAAI,IAChE,CACE,OAAOF,CACT,CAEO,SAASQ,EAAiBC,GAC/B,IAAIC,EAAe,GACfC,EAAiB,aAGrB,MAAMC,EAAeH,EAAoBJ,MAAMxB,MAAM,EAAG,GAClDgC,EAAuBD,EAAa5B,OAE1C0B,EAAe,iDACfE,EAAaE,KAAI,SAAUC,EAAGd,GACxBA,EAAI,GAAK,GAAW,IAANA,IAChBS,GAAgB,2BAElBA,GAAgB,kCAAkCK,EAAET,+DAA+DS,EAAER,2CACzH,IACEG,GAAgB,eAEhB,MAAMM,EAAsBP,EAAoBJ,MAAMxB,MAAMgC,GAS5D,OARIG,EAAoBhC,OAAS,IAC/B2B,EAAiB,OACjBK,EAAoBF,KAAI,SAAUC,EAAGd,GACnCU,GAAkB,gBAAgBI,EAAET,qDAAqDS,EAAET,mBACjG,IACIK,GAAkB,SAGb,CAACD,eAAcC,iBACxB,CASO,SAASM,EAAepB,EAAIM,GAGjC,MAAMe,EAAWrB,EAAGd,KAAK,kQAAoQoB,EAAS,wBACtS,IAAKe,EACH,MAAO,GAET,IAAIC,GAAe,EACfC,EAAU,GAEd,IAAK,IAAInB,EAAI,EAAGA,EAAIiB,EAAS,GAAGnB,OAAOf,OAAQiB,IAAK,CAClD,IAAIoB,EAAUC,SAASJ,EAAS,GAAGnB,OAAOE,GAAG,GAAI,IAC7CoB,GAAWF,IACbA,EAAcE,EACdD,EAAQ9B,KAAKiC,MAAMC,MAAM,KAAMD,MAAM,IAAIT,KAAI,WAAY,MAAO,EAAG,MAGrE,IAAIW,EAAWP,EAAS,GAAGnB,OAAOE,GAAG,GACjCyB,EAAUR,EAAS,GAAGnB,OAAOE,GAAG,GAChC0B,EAAYT,EAAS,GAAGnB,OAAOE,GAAG,GAEtCmB,EAAQA,EAAQpC,OAAS,GAAGsC,SAASI,EAAS,KAAKpC,KAAK,CAACsC,KAAMH,EAAUE,UAAWA,GACxF,CACE,OAAOP,CACT,CAgDA,SAASS,EAAWC,EAAIC,GACtB,MAAMC,EAAOC,EAAEH,GACfE,EAAKE,KAAK,gBAAiBH,GAASI,QAAQ,QAE5CC,YAAW,WACTJ,EAAKG,QAAQ,OACd,GAAE,IACL,CA+CA,SAASE,IACP,GAAK5E,EAGL,IACE,MAAM6E,EAAuBL,EAAE,WAAWM,QAAO,GAAMC,eAGjDC,EAAOC,EAFcC,WAAWC,gBAAgBN,IAGtDO,SAASC,eAAe,eAAeC,UAAYN,EAAKO,KAAK,GAC9D,CAAC,MAAOC,GACPC,QAAQC,MAAM,+BAA+BF,IACjD,CAAY,QACRxF,GAAoB,CACxB,CACA,CAEA,SAASY,EAAW+E,GAClB,MAAMC,EAAY,CAChB,IAAK,QACL,IAAK,OACL,IAAK,OACL,IAAK,SACL,IAAK,QACL,IAAK,SACL,IAAK,SACL,IAAK,UAGP,OAAOC,OAAOF,GAAQG,QAAQ,gBAAgB,SAAUC,GACtD,OAAOH,EAAUG,EACrB,GACA,CAEO,SAASd,EAAoBe,GAGlC,MAIMC,EAAczB,EAAE,sBAAsB0B,GAAG,YACzCC,EAAsBC,wBAC5B,IAAIC,EAAa,GACjB,IAAK,IAAI7D,EAAI,EAAGA,EAAIwD,EAAazE,OAAQiB,IAAK,CAE5C,MAAM8D,EAAkBN,EAAaxD,GAC/B+D,EAAcD,EAAgBE,GAC9BC,EAAgBH,EAAgBvE,eAEtC,IAAI2E,EAAY,uBAAuBD,UAAsBA,qBAAiCF,kCAC9F,IAAK,IAAII,EAAI,EAAGA,EAAIR,EAAmB5E,OAAQoF,IAAK,CAClD,MAAMC,EAAQT,EAAmBQ,GAC3BE,EAAiC,kBAApBD,EAAMnH,WAAiC,mBAAqBmH,EAAMnH,WAC/EqH,EAAYF,EAAMlH,KAAS,GAC3BqH,EAAWH,EAAMhH,KAAO,GACxBoH,EAAkBJ,EAAM/G,YAAa,EAE3C,IAAIoH,EAAa,GAcjB,GAbIJ,KAAcP,IAChBW,EAAaX,EAAgBO,GAAYK,YAEvCjB,EACFS,GAAa,OAAOI,SACXJ,EAAUnF,OAAS,GAAoB,KAAf0F,IACjCP,GAAa,QAKfO,EAAaA,EAAWnB,QAAQ,OAAQ,KAErB,WAAfe,EAcJ,GAAmB,IAAdI,GAAkC,MAAdA,IAAuBhB,EAKhD,GAAmB,YAAfY,EAAJ,CAiDA,GAFAI,EAAarG,EAAWqG,GAEpBD,GAAmBV,EAAgB3D,eAAe,iBAAoD,OAAjC2D,EAAgBa,cAAyBb,EAAgBa,aAAaxE,eAAe,eAAgB,CAC5K,MAAMyE,EAAsBd,EAAgB,GAAGO,qBACzCQ,EAAef,EAAgBa,aAAaG,YAC5CC,EAAwBH,EAAoBI,QAAO,CAACC,EAAGjF,IAAM6E,EAAajH,SAASoC,KACzFyE,EAAaS,iCAAiCT,EAAYM,EAClE,CAEM,IAA6C,IAAzCN,EAAWU,QA7GK,KA6G4B,CAC9C,MAAMC,EAAQX,EAAWY,MA9GP,KA+GlBnB,GAAaoB,qCACbF,EAAMG,SAAQC,IACPA,EAAKC,SAIVvB,GAAa,oBAAoBK,QAAgCiB,gBAAkB,IAErFtB,GAAa,OACrB,MACQA,GAAa,gBAAgBK,MAAaE,UAvBlD,KA7CM,CACE,GAAsC,GAAlCX,EAA6B,YAAQ,CACvCI,GAAa,qBACb,QACV,CAEQA,GAAa,qCACbA,GAAa,cACbA,GAAa,aACbA,GAAa,aACbA,GAAa,aACbA,GAAa,aACbA,GAAa,aACbA,GAAa,aACbA,GAAa,aACbA,GAAa,gBACbA,GAAa,UAEb,MAAMwB,EAAa5B,EAAyB,QAC5C,IAAK,IAAI6B,EAAI,EAAGA,EAAID,EAAW3G,OAAQ4G,IACrC,GAAID,EAAWC,GAAG,GAAG5G,OAAS,EAE5BmF,GAAa,uBAAyBwB,EAAWC,GAAG,GAAG,GAAGhE,KAAO,iBAFnE,CAKAuC,GAAa,OAEb,IAAK,IAAI0B,EAAK,EAAGA,EAAK,EAAGA,IACS,GAA5BF,EAAWC,GAAGC,GAAI7G,QAItBmF,GAAa,OACbA,GAAawB,EAAWC,GAAGC,GAAI/E,KAAI,SAAUC,EAAGd,GAC9C,IAAI6F,EAAM,aAAeC,YAAYhF,EAAEa,MAAQ,UAAUb,EAAEa,KAAK,YAAYb,EAAEa,KAAK,4BAInF,OAHkB,GAAdb,EAAEiF,WACJF,GAAO,KAEFA,CACrB,IAAe9C,KAAK,MACRmB,GAAa,SAXXA,GAAa,4CAL3B,CAmBQA,GAAa,kBAErB,MAjDQA,GAAa,0CAff,CACE,GAA8C,GAA1CJ,EAA8B,aAAE/E,OAAa,CAC/CmF,GAAaJ,EAAgC,eAC7C,QACV,CACQI,GAAaJ,EAA8B,aACvCA,EAAgC,eAAE/E,OAAS,IAE7CmF,GAAa,OAASJ,EAAgC,eAIhE,CA6EA,CACII,GAAa,aACbL,EAAWxE,KAAK6E,EACpB,CACE,OAAOL,CACT,CA0CO,SAASmC,EAAc9C,GAC5BD,QAAQC,MAAM,gBAAiBA,GAC/B+C,IACAC,mBAAoB,EAGpBC,EAAU,kBAAoBjD,EAAMpB,SAAW,iBACjD,CAEO,SAASqE,EAAUrE,GACxB,MAAMsE,EAAWxD,SAASC,eAAe,YACzCuD,EAASC,YAAcvE,EACvBsE,EAASE,MAAMC,QAAU,QAGzBpE,YAAW,KACTiE,EAASE,MAAMC,QAAU,MAAM,GAC9B,IACL,CAmBO,SAASN,IACdjE,EAAE,YAAYwE,MAChB,CAEO,SAASC,IACdzE,EAAE,mBAAmB0E,MAAM,OAC7B,iDAtRO,SAAqBC,EAAGC,GAC7B,GAAID,IAAMC,EAAG,OAAO,EACpB,GAAS,MAALD,GAAkB,MAALC,EAAW,OAAO,EACnC,GAAID,EAAE5H,QAAU6H,EAAE7H,OAAQ,OAAO,EAEjC,IAAK,IAAIiB,EAAI,EAAGA,EAAI2G,EAAE5H,SAAUiB,EAC9B,GAAI2G,EAAE3G,KAAO4G,EAAE5G,GAAI,OAAO,EAE5B,OAAO,CACT,0CApSO,SAA2BJ,GAChC,IAAIiH,EAAUjH,EAAGd,KAAK,sKACtB,MAAMgI,EAAUD,EAAQ,GAAGC,QACrBjH,EAAUgH,EAAQ,GAAG/G,OACDgH,EAAQ3B,QAAQ,gBAC1C,MAAM4B,EAAmBD,EAAQ3B,QAAQ,eAClB2B,EAAQ3B,QAAQ,YACf2B,EAAQ3B,QAAQ,aACV2B,EAAQ3B,QAAQ,oBACf2B,EAAQ3B,QAAQ,qBAC/C,MAAM6B,EAAaF,EAAQ3B,QAAQ,MAC7B8B,EAAc,CAAC,kBAAmB,sBAAuB,8BAEzDC,EAAcvH,EAAeC,GACnC,IAAIuH,EAAa,EAEjB,MAAMC,EAAUvH,EAAQgB,KAAIZ,IAC1B,IAAIoH,EAAe,CAAE,EACrB,MAAMnH,EAASD,EAAI+G,GACnB,IAAK,IAAI7C,EAAI,EAAGA,EAAIlE,EAAIlB,OAAQoF,IAAK,CACnC,MAAME,EAAayC,EAAQ3C,GAE3BkD,EAAahD,GAAcpE,EAAIkE,GAEhB,OAAXlE,EAAIkE,KACNkD,EAAahD,GAAc,IAKzB4C,EAAYrJ,SAASyG,KACvBgD,EAAa,GAAGhD,UAAqBjG,EAAW6B,EAAIkE,IACpDkD,EAAa,GAAGhD,qBAAgCxG,EAAkBwJ,EAAa,GAAGhD,WAAoB,GAE9G,CAaI,GAPoC,WAAhCgD,EAAa9H,iBAEf8H,EAAmC,qBAAIjJ,EAAWiJ,EAAaC,gBAAgBhE,QAAQ,aAAc,eACrG+D,EAA8C,gCAAIxJ,EAAkBwJ,EAAmC,sBAAG,GAE1GA,EAA8C,gCAAE,IAAInK,KAAO,SAEzDI,EAAyB6C,eAAekH,EAAa9H,gBAAiB,CACxE,MAAMgI,EAAcjK,EAAyB+J,EAAa9H,gBAC1D8H,EAAaG,oCAAsCH,EAAaG,oCAAoCxC,QAAO,CAACC,EAAGjF,KAAOuH,EAAY3J,SAASoC,KAC3IqH,EAAaI,2CAA6CJ,EAAaI,2CAA2CzC,QAAO,CAACC,EAAGjF,KAAOuH,EAAY3J,SAASoC,IAC/J,CACI,GAAIzC,EAA2B4C,eAAekH,EAAa9H,gBAAiB,CAC1E,MAAMgI,EAAchK,EAA2B8J,EAAa9H,gBAC5D8H,EAAaK,gCAAkCL,EAAaK,gCAAgC1C,QAAO,CAACC,EAAGjF,KAAOuH,EAAY3J,SAASoC,IACzI,CA+BI,GA1B2D,GAAvDqH,EAAaK,gCAAgC3I,QAA0E,GAA3DsI,EAAaG,oCAAoCzI,QAC/C,OAA5DsI,EAAaG,oCAAoC,GAAGtK,OAEtDmK,EAAaG,oCAAsC,GACnDH,EAAaI,2CAA6C,IAI9DR,EAAY1B,SAAQ5D,IAGlB0F,EAAa,GAAG1F,WAAgB0F,EAAa,GAAG1F,qBAAwBd,KAAI8G,GACnEA,EAASzK,MAChB,IAEJiK,GAAcE,EAAaK,gCAAgC3I,SAAWsI,EAAaG,oCAAoCzI,OAAS,EAAI,EAEpIsI,EAAgC,kBAAI/H,EAAwB+H,GACxDA,EAAsB,QACxBA,EAA+B,iBAAIA,EAA6B,eAAI,KAAOA,EAAsB,QAAI,IAErGA,EAA+B,iBAAIA,EAA6B,eAK9DH,EAAY/G,eAAeD,GAAS,CACtC,MAAM0H,EAAerH,EAAiB2G,EAAYhH,IAClDmH,EAA2B,aAAIO,EAAanH,aAC5C4G,EAA6B,eAAIO,EAAalH,cACpD,MACM2G,EAA2B,aAAI,GAC/BA,EAA6B,eAAI,aAKnC,IAAIQ,EAAa5H,EAAI8G,GAOrB,OALEM,EAAsB,QADpBQ,EAAa,EACW7G,EAAepB,EAAIK,EAAI+G,IAEvB,GAGrBK,CAAY,IAEfS,EAAW,IAAIC,IAOrB,OANAX,EAAQ7B,SAAQyC,IACdF,EAASG,IAAID,EAAYhE,GAAIgE,EAAY,IAG3C/E,QAAQiF,IAAI,yEAAyEf,KAE9EW,CACT,wCAoLO,SAASK,IAEd,GAAsB,GADNnG,EAAE,WAAWM,QAAO,GAAMC,eAC9BxD,OAAZ,CAIA,GAAIvB,EAGF,OAFAA,GAAoB,OACpB2E,WAAWgG,EAAsB,KAGnCvF,SAASC,eAAe,eAAeC,UAAY,uGACnDtF,GAAoB,EACpB2E,WAAWC,EAAkB,IAT/B,CAUA,gCA7ZO,SAAsBnF,EAAYmL,EAAO,MAC9C,MAAMhE,EAAQpH,EAAiBqL,MAAKjE,GAASA,EAAMnH,aAAeA,IAClE,OAAKmH,GAGEA,EAAMlH,KAAKkL,IAFTnL,CAGX,qCA4WO,WAKoB2F,SAAS0F,iBAAiB,SAClC/C,SAAQgD,IACvBA,EAAOC,iBAAiB,SAAS,WAC/B,MAAMC,EAASF,EAAOG,UACtBC,UAAUC,UAAUC,UAAUJ,GAAQK,MAAK,WACzClH,EAAW2G,EAAQ,uBAC3B,IAASQ,OAAM,SAASC,GAChBpH,EAAW2G,EAAQ,kBAC3B,GACA,GAAM,GAEN,sBA5CO,SAA6BU,EAAWC,GAE7CD,EAAUnG,UAAY,GAEtBoG,EAAM3D,SAAQ,CAACyC,EAAahE,KAC1B,MAAMmF,EAASvG,SAASwG,cAAc,UACtCD,EAAOE,MAAQrF,EACfmF,EAAOjM,KAAO8K,EAAYsB,kBAE1BL,EAAUM,YAAYJ,EAAO,GAEjC,+CAjCO,SAAgC3F,GAGrC,OAFeA,aAAwBuE,IAAMzG,MAAMkI,KAAKhG,EAAa1D,UAAY0D,GAEnE3C,KAAImH,IACT,CACLhE,GAAIgE,EAAYhE,GAAGU,WACnBxH,KAAM8K,EAAYsB,kBAClBG,eAAgBzB,EAAYzI,eAAemK,UAAU,OAAOpG,QAAQ,mBAAoB,IACxFqG,MAAM,EACNC,UAAW5B,EAAYzI,kBAG7B,4EA8PO,SAA+ByD,GAGpC,GAFAkD,mBAAoB,EAEhBlD,EAAE6G,KAAK3G,MACT8C,EAAc,CAAClE,QAASkB,EAAE6G,KAAK/H,eAIjC,IAEE,GAAIkB,EAAE6G,KAAKC,OAAQ,CAEjB,MAAMC,EAAO,IAAIC,KAAK,CAAChH,EAAE6G,KAAKC,QAAS,CACrCG,KAAM,sEAIFC,EAAOtH,SAASwG,cAAc,KACpCc,EAAKC,KAAOC,IAAIC,gBAAgBN,GAChCG,EAAKI,SAAW,2BAChB1H,SAAS2H,KAAKhB,YAAYW,GAC1BA,EAAKM,QACL5H,SAAS2H,KAAKE,YAAYP,GAG1BzD,GACN,CACG,CAAC,MAAOvD,GACP8C,EAAc9C,EAClB,CAAY,QACR+C,GACJ,CACA,oEA5RO,WACL,IAAIyE,EAAO1I,EAAE,WAAWM,QAAO,GAAMqI,SAAS,KAC9C3I,EAAE,WAAWM,QAAO,GAAMsI,YAAYF,EAAKG,SAAS,GACtD,0BAsTO,SAAqBC,GAC1B,MACMC,EAAwBnI,SAASC,eAAe,yBAElDkI,IACFA,EAAsB1E,YAAcyE,GAJX,+BAM3B9I,EAAE,YAAYgJ,MAChB,IC/6BA,MAAMC,EAA0B,sBAC1BC,EAAkB,cAExB,SAASC,EAAiBlB,GACxB,IAAImB,EACJ,IACEA,EAAUC,OAAOpB,GACjB,MAAMqB,EAAI,mBAGV,OAFAF,EAAQG,QAAQD,EAAGA,GACnBF,EAAQI,WAAWF,IACZ,CACX,CACE,MAAMtI,GACJ,OAAOA,aAAayI,eAEP,KAAXzI,EAAE0I,MAES,OAAX1I,EAAE0I,MAGS,uBAAX1I,EAAErB,MAES,+BAAXqB,EAAErB,OAEDyJ,GAA8B,IAAnBA,EAAQrM,MAC1B,CACA,CAEO,SAAS4M,IACd,MAAMC,EAAW,CAAC,iBAAkB,kBAAmB,sBAAuB,iBAC5E,SAAU,eAAgB,WAAY,mBAAoB,UAE5D,IAAKT,EAAiB,gBACpB,OAAOS,EAGT,IACE,MAAMR,EAAUC,OAAqB,aACrC,GAAID,EAAQS,QAAQZ,GAClB,OAAOa,KAAKC,MAAMX,EAAQS,QAAQZ,GAErC,CAAC,MAAOjI,GACPC,QAAQC,MAAM,gEAAiEF,EACnF,CAEE,OAAO4I,CACT,CAEO,SAASI,EAAwBC,EAAiB,MACvD,IAAKd,EAAiB,gBACpB,OAEF,MAAMC,EAAUC,OAAqB,aAI/Ba,EAAsBJ,KAAKK,UAAUF,EAAiB,GAAGG,OAAOH,GAAkB,IAExFb,EAAQG,QAAQN,EAAyBiB,EAC3C,CAQA,SAASG,EAAsBJ,EAAgBxI,GAC7C,IAAI6I,EAAY,EAChBtK,EAAE,mBAAmBuK,QACrBvK,EAAE,gBAAgBuK,QAGlBN,EAAe1G,SAAQ8D,IACrB,MAAMmD,EAAcxP,iBAAiBqL,MAAKoE,GAAQA,EAAKxP,aAAeoM,IAClEmD,GACFxK,EAAE,mBAAmB0K,OAAO1K,EAAE,WAAY,CACxCqH,MAAOmD,EAAYvP,WACnBC,KAAOsP,EAAYtP,KAAS,GAC5BoP,UAAWA,MAEnB,IAIEtP,iBAAiBuI,SAAQiH,KACiC,IAApDP,EAAe9G,QAAQqH,EAAYvP,aACrC+E,EAAE,gBAAgB0K,OAAO1K,EAAE,WAAY,CACrCqH,MAAOmD,EAAYvP,WACnBC,KAAOsP,EAAYtP,KAAS,GAC5BoP,UAAWA,MAEnB,IAG6B,kBAAhB7I,IACTA,EAA8B,SAAhBA,GAEhBzB,EAAE,sBAAsByK,KAAK,UAAWhJ,EAC1C,CA4DA,SAASkJ,EAAuB3J,GAC9BA,EAAE4J,iBAEF,MAAMxG,EAAWpE,EAAE,yBACbiK,EAAiBjK,EAAE,0BAA0BnB,KAAI,CAACzB,EAAOyC,IAAOG,EAAEH,GAAIgL,QAAOC,UAEnF,GAAuB,OAAnBb,GAAoD,GAAzBA,EAAelN,OAG5C,OAFAqH,EAAS5D,KAAK,8EACd4D,EAAS4E,OAGX5E,EAASI,OAGT,MAAMuG,EAAkBC,aAAanB,QAAQX,GACvC+B,EAAyBnB,KAAKC,MAAMiB,aAAanB,QAAQZ,IAEzDxH,EAAczB,EAAE,sBAAsB0B,GAAG,YAC1CwJ,YAAYD,EAAwBhB,IAAmBc,GAAmBtJ,IAC7EuI,EAAwBC,GACxBe,aAAazB,QAAQL,EAAiBzH,GAGtCzB,EAAE,gBAAgBmL,QAAQ,iBAAkB,CAACrL,QAAS,WAGxDE,EAAEoL,MAAMC,OAAO7C,OACjB,oFA7HO,WAEL,OADuBmB,IACD9K,KAAIwI,GAASrM,iBAAiBqL,MAAKoE,GAAQA,EAAKxP,aAAeoM,KACvF,kBAqCO,WACL,MAAMiE,EAAwB,CAC5B,iBAAkB,kBAAmB,6BAA8B,sBACnE,sBAAuB,sBAAuB,iBAAkB,SAAU,eAAgB,WAAY,mBACtG,gBAAiB,SAAU,YAAa,SAAU,cAAe,UAAW,SAAU,QACtF,gBAAiB,WAAY,aAAc,YAAa,cAGpDC,EAAgBP,aAAanB,QAAQZ,GACrCgB,EAAiBsB,EAAgBzB,KAAKC,MAAMwB,GAAiBD,EAC7DE,EAAmBR,aAAanB,QAAQX,GAG9CmB,EAAsBJ,GAFFuB,GAAwC,SAArBA,GAIvCxL,EAAE,gBAAgByL,YAAY,CAC5BC,wBAAwB,EACxBC,mBAAmB,EACnBC,KAAM,CACJC,KAAM,SAAUlH,EAAGC,GAIjB,OAHevF,SAASW,EAAE2E,GAAG1E,KAAK,cACnBZ,SAASW,EAAE4E,GAAG3E,KAAK,cAET,GAAK,CAC/B,EACD6L,MAAO,SAAUnH,EAAGC,GAIlB,OAHevF,SAASW,EAAE2E,GAAG1E,KAAK,cACnBZ,SAASW,EAAE4E,GAAG3E,KAAK,cAET,GAAK,CACtC,KAIED,EAAE,yBAAyBwE,OAE3B5D,SAASC,eAAe,yBAAyB2F,iBAAiB,QAASmE,GAC3E/J,SAASC,eAAe,2BAA2B2F,iBAAiB,SAAS,KAE3E,MAAMgF,EAAmBR,aAAanB,QAAQX,GACxCzH,GAAc+J,GAAwC,SAArBA,EACjCD,EAAgBP,aAAanB,QAAQZ,GAE3CoB,EADuBkB,EAAgBzB,KAAKC,MAAMwB,GAAiBD,EAC7B7J,EAAY,IAG7Bb,SAASC,eAAe,mBAChC2F,iBAAiB,kBAAkBuF,IAChD/L,EAAE,yBAAyBwE,OAG3B,MAAMuG,EAAkB/K,EAAE,sBAAsB0B,GAAG,YAEnDsI,EAD4BhK,EAAE,0BAA0BnB,KAAI,CAACzB,EAAOyC,IAAOG,EAAEH,GAAIgL,QAAOC,WAExFE,aAAazB,QAAQL,EAAiB6B,EAAgB,GAE1D,8BC7GA,SAASiB,IACP,IACE,MAAO,iEAAiEC,KAAKtF,UAAUuF,UACxF,CAAC,MAAOlL,GACP,OAAO,CACX,CACA,CAgBA,SAASmL,EAAmBrK,EAAiBsK,EAAKC,EAAKC,EAAQC,GAM7D,GAAY,IAARH,GAAuB,IAARC,EACjB,OAAO,KAET,IAAIG,EAASF,EAAQE,OAAO,CAACJ,EAAKC,GAAM,CACtCzE,UAAW9F,EAAgBvE,eAC3ByE,GAAIF,EAAgBE,KAElByK,EAAY,GAAG3K,EAAgBvE,qBAUnC,OATIyO,MACFS,GAAa,YA7BjB,SAAyBL,EAAKM,GAC5B,GAAwB,mBAAbC,SAET,MADA1L,QAAQC,MAAM,oCACR,IAAI0L,MAAM,oCAGlB,OAAID,WACK,gCAAgCP,KAAOM,IAGvC,OAAON,KAAOM,OAASN,KAAOM,GAEzC,CAiB6BG,CAAgBT,EAAKC,sCAG5CL,KACFQ,EAAOM,UAAUL,EAAW,CAACM,WAAW,IAE1CP,EAAOQ,YAAYlL,EAAgBvE,eAAgB,CAAC0P,WAAW,IAAOC,cAE/DV,CACT,6CAzFO,SAAiBW,EAAOC,EAAS,CAAC,UAAW,WAAYC,EAAO,GACrE,MAAMxO,EAAM0N,EAAE1N,IAAIsO,EAAO,CACvBG,mBAAmB,IAClBC,QAAQH,EAAQC,GACnBd,EAAEiB,UAAU,qDAAsD,CAChEC,QAAS,GACTC,YAAa,yEACZC,MAAM9O,GAIT0N,EAAEqB,QAAQC,OAAO,CACfC,QAAS,CACPC,MAAO,iBAGVJ,MAAM9O,GAEP,MAAMmP,EAAUzB,EAAE0B,mBAAmB,CACnCC,qBAAqB,EACrBC,gBAAgB,EAChBC,iBAAkB,KAOpB,OALAJ,EAAQK,GAAG,SAAS,SAAUrN,GAC5BsN,oBAAoBtN,EAAEuN,MAAMC,QAAQ5G,UAAW5G,EAAEuN,MAAMC,QAAQxM,GACnE,IACEgM,EAAQL,MAAM9O,GAEP,CAACA,MAAKmP,UACf,uBAsEO,SAA8B9G,EAAOoF,EAAQC,GAClD,MAAMkC,EAAa,IAAI1I,IAsBvB,OAnBAmB,EAAM3D,SAAQ,CAACzB,EAAiB4M,KACR5M,EAAgBvE,eAEtC,MAAMoR,EAAYC,WAAW9M,EAAgB+M,WAAa,EACpDC,EAAYF,WAAW9M,EAAgBiN,YAAc,EACrDC,EAAcJ,WAAW9M,EAAgBmN,mBAAqB,EAC9DC,EAAcN,WAAW9M,EAAgBqN,oBAAsB,EAC/DC,EAAejD,EAAmBrK,EAAiB6M,EAAWG,EAAWxC,GAC/E,IAAK8C,EACH,OAEGX,EAAWY,IAAIX,IAClBD,EAAWxI,IAAIyI,EAAK,CAACY,MAAO,KAAMC,QAAS,OAE7Cd,EAAWe,IAAId,GAAKY,MAAQF,EAE5B,MAAMK,EAAiBtD,EAAmBrK,EAAiBkN,EAAaE,EAAa5C,GACrFmC,EAAWe,IAAId,GAAKa,QAAUE,GAAkCL,CAAY,IAEvEX,CACT,mBA5FO,SAA0BiB,EAAgBC,GAC/C,MAAMC,EAAqB,IAAIF,IACzBG,EAAiB,IAAIF,IAE3B3P,EAAE4P,GAAoBE,SAClB9P,EAAE4P,GAAoBlO,GAAG,YAC3B1B,EAAE6P,GAAgBrP,KAAK,YAEvBR,EAAE6P,GAAgBrP,KAAK,WAE3B,cAgGO,UAAqBuP,gBAC1BA,GAAkB,EAAKC,qBACvBA,GAAuB,EAAKC,eAC5BA,EAAiB,GAAEC,WACnBA,EAAa,IAAInK,IAAKoK,UACtBA,EAAY,KAAIC,aAChBA,EAAe,MACb,IAEF,IAAIC,EAAgB,GAEpB,GAAKD,GAAiBD,EAAtB,CAMAC,EAAaE,cAEb,IAAK,IAAItS,EAAI,EAAGA,EAAIiS,EAAelT,OAAQiB,IAAK,CAC9C,MAAM0Q,EAAMuB,EAAejS,GAC3B,IAAKkS,EAAWb,IAAIX,GAClB,SAEF,MAAM6B,EAAqBL,EAAWV,IAAId,GACpC8B,EAAeR,EAAuBO,EAAmBjB,MAAQiB,EAAmBhB,QAC1Fa,EAAaK,UAAUD,GACvBH,EAAchT,KAAKmT,EAAaE,YACpC,CAEML,EAActT,OAAS,IAAMgT,GAC/BI,EAAUQ,UAAUN,EAjBxB,MAFIpP,QAAQiF,IAAI,0CAqBhB,IC3KA,MAAM0K,EAAsB,CAC1B,oBAAqB,KACrBC,SAAY,KACZ,YAAa,MAITC,EAAY,CAChBC,aAAgB,CACd5V,GAAM,cACN6V,GAAM,aAERC,SAAY,QACZC,YAAe,WACfC,MAAS,OAIXnR,EAAEoR,GAAGC,aAAaC,OAAO,aAAa,SAAS9C,GAC7C,IAAI+C,EAAOnG,KAGXA,KAAKiD,GAAG,aAAa,WACnBkD,EAAKC,IAAInD,GAAG,qBAAsB,oBAAoB,WACpD,IAAIoD,EAAQzR,EAAEoL,MAAMsG,QAAQ1R,EAAEoR,GAAGC,aAAaM,YAAYC,UAAUC,gBAChEC,EAAOP,EAAKQ,SAASN,GACzBK,EAAKE,YAAcF,EAAKE,UAI9B,IAEIT,EAAKU,MAAM5D,GAAG,UAAU,SAASrN,EAAGkR,EAAM9P,GACpC8P,aAAgBlS,EAAEoR,GAAGC,aAAaM,YAAYQ,MAAkB,eAAV/P,GAExDmP,EAAKa,qBAAqBF,EAElC,GACA,IAGE9G,KAAKiD,GAAG,gBAAgB,SAASrN,EAAG8Q,GAClCA,EAAKO,GAAGL,YAAa,CACzB,IAEE5G,KAAKiD,GAAG,+BAA+B,SAASrN,EAAG8Q,GAE5CA,EAAK9O,QAAuC,iBAAtB8O,EAAK9O,OAAOsP,OAKI,IAAvCR,EAAK9O,OAAOsP,MAAMnP,QAAQ,QAC5B2O,EAAKN,IAAInL,KAAKkM,GAA2B/N,OAEzCsN,EAAKN,IAAInL,KAAKkM,GAA2BvJ,OAPzC8I,EAAKN,IAAInL,KAAKkM,GAA2B/N,MAS/C,IAGOgK,EAAQgE,kBACXpH,KAAKiD,GAAG,0BAA0B,SAASoE,GACzC,IAAIC,EAAK1S,EAAEA,EAAE2S,UAAUF,EAAEpL,QACzBqL,EAAGrM,KAAKrG,EAAEoR,GAAGC,aAAaM,YAAYC,UAAUgB,cAAcC,QAC1D,4FACerE,EAAQsE,aADvB,uCAEkCvB,EAAKwB,UAAU,cAFjD,oBAKJN,EAAEpL,MAAQqL,EAAGjI,KAAK,YACxB,IAIEW,KAAKiD,GAAG,qBAAqB,SAASrN,EAAG8Q,GACvC9Q,EAAEqG,MAAM2K,WAAaF,EAAKE,UAC9B,IAGE5G,KAAKiD,GAAG,qBAAqB,SAASrN,EAAGgS,GACvChS,EAAEqG,MAAM2K,aAAegB,EAAKhB,UAChC,IAGE5G,KAAKiD,GAAG,oBAAoB,SAASrN,EAAG8Q,EAAMzK,EAAO4L,GACnDhS,QAAQiF,IAAI,qBAAqB4L,EAAK9P,mBAAmB8P,EAAKE,cAC1DF,EAAKE,aACPhR,EAAEqG,MAAQ,YAAcrG,EAAEqG,MAAQ,KAExC,GACA,GAAG,CACDyL,aAAc,sBACdN,kBAAkB,IAGpBxS,EAAEoR,GAAGC,aAAaM,YAAYuB,MAAMC,sBAAsBnT,EAAEoR,GAAGC,aAAaM,YAAYQ,KAAM,CAAC,eAE/F,MAAMI,EAA4BvS,EAAEoR,GAAGC,aAAaM,YAAYC,UAAUgB,aAAe,oBA2BlF,SAASQ,EAAkBC,EAAOC,GAKvCA,EAAW/P,SAAQ,CAACgQ,EAAOnW,KAAR,IAKnB,MAAMoW,EAAS,CAAE,EACjBH,EAAM9P,SAAQkQ,IACZ,MAAMC,EAAWD,EAAQ,UAAK,GACzBD,EAAOE,KAAWF,EAAOE,GAAY,IAC1CF,EAAOE,GAAUrW,KAAKoW,EAAK,IAI7BE,OAAOC,KAAKJ,GAAQjQ,SAAQmQ,IAC1BF,EAAOE,GAAU9H,MAAK,CAACjH,EAAGC,KACxB,MAAMiP,EAASlP,EAAEmP,OAAS,GACpBC,EAASnP,EAAEkP,OAAS,GAC1B,OAAOD,EAAOG,cAAcD,EAAO,GACnC,IAIJ,IAAIE,EAAS,GAab,OAZAX,EAAW/P,SAAQmQ,IACbF,EAAOE,KACTO,EAASA,EAAO7J,OAAOoJ,EAAOE,WACvBF,EAAOE,GACpB,IAIEC,OAAO7V,OAAO0V,GAAQjQ,SAAQgQ,IAC5BU,EAASA,EAAO7J,OAAOmJ,EAAM,IAGxBU,CACT,CASO,SAASC,EAAgBC,EAAYC,GAC1C,IAAKD,EACH,MAAM,IAAIvH,MAAM,oCAGlB,IAAKwH,GAAkC,iBAAdA,EACvB,MAAM,IAAIxH,MAAM,wDAGlB,IAAIyH,EAAM,KACNC,EAAM,KACNC,GAAY,EAGhB,MAAMC,EAAef,IAEnB,IAAKA,QAA4BgB,IAApBhB,EAAKW,IAAgD,OAApBX,EAAKW,GACjD,OAIF,MAAM/M,EAAmC,iBAApBoM,EAAKW,GACxBxF,WAAW6E,EAAKW,IAAcX,EAAKW,GAGrC,IAAIM,MAAMrN,GAAV,CAKA,IAAKkN,EAIH,OAHAF,EAAMhN,EACNiN,EAAMjN,OACNkN,GAAY,GAKVlN,EAAQgN,IAAKA,EAAMhN,GACnBA,EAAQiN,IAAKA,EAAMjN,EAZ3B,CAYgC,EAI9B,GAAI8M,aAAsBpO,IAExB,IAAK,MAAM0N,KAAQU,EAAWrW,SAC5B0W,EAAYf,OAET,KAAInU,MAAMqV,QAAQR,GAMvB,MAAM,IAAIvH,MAAM,+CAJhB,IAAK,MAAM6G,KAAQU,EACjBK,EAAYf,EAIlB,CAEE,OAAOc,EAAY,CAAEF,MAAKC,OAAQ,IACpC,CAEO,SAASM,EAAqBC,EAAMC,EAASV,EAAWlN,EAAO6N,GAAc,GAElF,IAAIC,EAAY,GAChB,MAAMC,EAAgB,IAAIC,IAC1B,IAAIC,EAAmB,IAgCvB,GA9BA7V,MAAMkI,KAAKN,EAAMpJ,UAAUyF,SAAQkQ,IACjC,MAAM2B,EAAUH,EAAc5F,IAAIoE,EAAKW,IACvC,GAAIX,EAAKW,IAAkC,KAApBX,EAAKW,KAAsBgB,IAChDH,EAAcI,IAAI5B,EAAKW,IACvBY,EAAU3X,KAAK,CACbnC,KAAMuY,EAAKW,GACXpS,GAAIyR,EAAKW,GACTkB,MAAO7B,EAAKzR,IAAM,IAEF,mBAAdoS,GAAkCX,EAAK8B,SAAS,CAClC9B,EAAK8B,QAAQlS,MAAM,KAAKxE,KAAI8F,GAAKA,EAAElB,SAAQT,QAAO2B,GAAKA,IAG/DpB,SAAQiS,IACTP,EAAc5F,IAAImG,KACrBP,EAAcI,IAAIG,GAClBR,EAAU3X,KAAK,CACbnC,KAAMsa,EACNxT,GAAIwT,EACJF,MAAOH,MAErB,GAEA,CACA,IAGEH,EAAUpJ,MAAK,CAACjH,EAAGC,IAAMD,EAAE2Q,MAAQ1Q,EAAE0Q,QAGxB,KAATT,EAAa,CAEf,MAAMY,EAAiBZ,EAAKnN,UAAU,OAAOpG,QAAQ,mBAAoB,IAAIoU,cAC7EV,EAAYA,EAAUhS,QAAOyQ,GACJA,EAAKvY,KAAKwM,UAAU,OAAOpG,QAAQ,mBAAoB,IAAIoU,cAC5D9Z,SAAS6Z,IAErC,CAEE,GAAIV,EAEF,OADAD,EAAQE,GACDA,EAGT,MAAMlX,EAASkX,EAAUnW,KAAI4U,GAAQA,EAAKvY,OAE1C,OADA4Z,EAAQhX,GACDA,CACT,CAkBA,SAAS6X,EAAoBC,EAAQ1O,EAAO2O,EAAiBC,EAAM,CAAA,GAEjE,QAAerB,IAAXmB,EACF,MAAM,IAAIhJ,MAAM,uDAElB,KAAK1F,GAAWA,aAAiBnB,KAC/B,MAAM,IAAI6G,MAAM,wEAElB,IAAKiJ,GAA8C,mBAApBA,EAC7B,MAAM,IAAIjJ,MAAM,uFAGlB,MAAMmJ,EAAUD,EAAIC,SAAWH,EACzBI,EAAYF,EAAIE,WAAa,CAAC,WAAY,eAC1C,QAAS,YAAa,cAAe,kBACrC,YAAa,gBAAiB,WAAY,gBAC1C/N,EAAO6N,EAAI7N,MAAQ,SACnBgO,EAAOH,EAAIG,MAAQ,IACnBC,EAAWJ,EAAII,UAAY,QAEjC,MAAO,CACLlU,GAAI4T,EACJxT,MAAO2T,EACPG,SAAUA,EACVpC,MAAO+B,EAAgBD,GACvB3N,KAAMA,EACNkO,OAAQ,eACRC,cAAe,CACbC,SAAU,EACVC,MAAO,IACPC,OAAQ,SAAU1B,EAAMC,GACtBF,EAAqBC,EAAMC,EAASiB,EAAS7O,EAC9C,EACDsP,UAAW,uBACXC,gBAAgB,GAElBR,KAAMA,EACND,UAAWA,EAEf,CAmBA,SAASU,EAAmBd,EAAQ1O,EAAO2O,EAAiBC,GAE1D,QAAerB,IAAXmB,EACF,MAAM,IAAIhJ,MAAM,sDAElB,KAAK1F,GAAWA,aAAiBnB,KAC/B,MAAM,IAAI6G,MAAM,uEAElB,IAAKiJ,GAA8C,mBAApBA,EAC7B,MAAM,IAAIjJ,MAAM,sFAEbkJ,IAAKA,EAAM,CAAE,GAClB,MAAMC,EAAUD,EAAIC,SAAWH,EACzBI,EAAYF,EAAIE,WAAa,CAAC,QAAS,YAAa,OAAQ,gBAAiB,UAAW,mBAAoB,UAAW,eACvHC,EAAOH,EAAIG,MAAQ,GAGzB,IAAIU,EAAS,CACX3U,GAAI4T,EACJxT,MAAO2T,EACPG,SALeJ,EAAII,UAAY,QAM/BpC,MAAO+B,EAAgBE,GACvB9N,KAAM,UACNgO,KAAMA,EACND,UAAWA,EACX1D,MAAO,UAET,MAAMsE,EAAkB1C,EAAgBhN,EAAO6O,GAoB/C,OAnBAD,EAAIzB,IAAMyB,EAAIzB,KAAQuC,GAAmBA,EAAgBvC,IACzDyB,EAAIxB,IAAMwB,EAAIxB,KAAQsC,GAAmBA,EAAgBtC,SAGzCG,IAAZqB,EAAIzB,UAAiCI,IAAZqB,EAAIxB,UAAkCG,IAAbqB,EAAIe,OACxDF,EAAOG,WAAa,CAClBC,mBAAmB,QAGLtC,IAAZqB,EAAIzB,MAAmBsC,EAAOG,WAAWzC,IAAMyB,EAAIzB,UACvCI,IAAZqB,EAAIxB,MAAmBqC,EAAOG,WAAWxC,IAAMwB,EAAIxB,UACtCG,IAAbqB,EAAIe,OAAoBF,EAAOG,WAAWD,KAAOf,EAAIe,YAIjCpC,IAAtBqB,EAAIkB,gBACNL,EAAOK,cAAgBlB,EAAIkB,eAGtBL,CACT,CAgBA,SAASM,EAA+BnF,EAAMoF,EAAkB,CAAA,EAAIC,EAAqB,CAAA,GACvF,IAAIC,EAAStF,EAAKN,IAAInL,KAAK,+BAC3B,MAAMgR,EAAWvF,EAAKuF,SAASpP,UAGEwM,IAA7B2C,EAAOvP,KAAK,cACduP,EAAOE,UAAU,WAEfF,EAAOG,SAAS,iBAClBH,EAAOI,aAAa,WAIL,OAAbH,GAAkC,WAAbA,EACvBD,EAAOE,UAAUJ,GAEjBE,EAAOI,aAAaL,EAExB,CAaA,SAASM,EAAqBd,GAC5B,MAAMe,EAAc,gBACdC,EAAc,kBACpB,MAAO,CACL3V,GAAI2U,EAAO3U,GACXI,MAAOuU,EAAOvU,MACd0R,MAAO6C,EAAO7C,MACd7L,KAAM,SACNiO,SAAUS,EAAOT,UAAY,WAC7BrO,KAAM,CACJ+P,YAAY,GAEdtF,MAAO,SAASR,EAAMnS,GACpB,MAAO,qIAGoCA,+BAAkC+X,gDAC9C/X,yEAA4E+X,wBAAkC/X,uIAGlGA,iCAAoCgY,gDAChDhY,2EAA8EgY,wBAAkChY,4MAIlFA,+CAAkDA,mFAChEA,mMAGcA,iDAAoDA,6EAClEA,qMAGcA,8CAAiDA,0EAC/DA,6GAKhD,EACDqW,UAAWW,EAAOX,WAAa,CAAC,WAAY,QAAS,cAAe,aACpE6B,YAAa,SAAS/F,GACpB,IAAIgG,EAAahG,EAAKN,IAAInL,KAAK,yBAC/B,MAAO,CACL0R,cAAeD,EAAWzR,KAAK,6BAA6BwE,MAC5DvF,gBAAiBwS,EAAWzR,KAAK,+BAA+BwE,MAChEmN,WAAYF,EAAWzR,KAAK,sCAAsCwE,MAErE,EACDoN,YAAa,SAASnG,EAAMzK,GAC1B,MAAM2Q,EAAa3Q,EAAM2Q,YAAc,aACvC,IAAIF,EAAahG,EAAKN,IAAInL,KAAK,yBAC/ByR,EAAWzR,KAAK,6BAA6BwE,IAAIxD,EAAM0Q,eAAiB,IACxED,EAAWzR,KAAK,+BAA+BwE,IAAIxD,EAAM/B,iBAAmB,IAC5EwS,EAAWzR,KAAK,qCAAuC2R,EAAa,MAAMvN,KAAK,WAAW,EAChG,EAEA,CAhaAzK,EAAEoR,GAAGC,aAAa6G,OAAO,CAOvB9F,qBAAsB,SAASN,GAE3BA,EAAKN,IAAInL,KAAKkM,EAA4B,qBACrCrX,KAAKkQ,KAAK2H,UAAUjB,EAAKE,WAAa,cAAgB,eAQ3D5G,KAAKD,QAAQ,8BAA+B2G,GAE5C1G,KAAKD,QAAQ,eACnB,kGAoZO,SAA0BgN,EAAaC,EAAWC,GACvD,MAAMnR,EAAQkR,EAAUE,qBAClBjH,EAAerR,EAAE,IAAImY,KAErBI,EAAcvY,EAAEoR,GAAGC,aAAaM,YAAY6G,SAASxC,UAAU5L,OAAO,CAE1E,CAAEnC,KAAM,oBAAqBwQ,UAAW,EAAGC,UAAU,EAAOC,SAAU,CAAC,WACvE,CAAE1Q,KAAM,aAAcwQ,UAAW,EAAGC,UAAU,EAAOC,SAAU,CAAC,aAa5DC,EAAkC,CACtCvC,SAAU,EACVC,MAAO,IACPC,OAAQ,SAAS1B,EAAMC,GACrBF,EAAqBC,EAAMC,EAAS,iBAAkB5N,EACvD,EACDsP,UAAW,qBACXC,gBAAgB,GAGZoC,EAA+B,CACnCC,QAAS,CAAC,iBAEVC,KAAM,SAASC,EAAOC,GAEpBrE,EAAqBoE,EAAOC,EAAU,iBAAkB/R,GAAO,GADpDkE,KAGN8N,SAASH,KAAO,IACtB,EAEDI,SAAS,EACTC,WAAY,KACZC,cAAc,EACdC,UAAW,KAGb,IAAIC,EAAsB,CACxB,CACEvX,GAAI,iBACJkU,SAAU,eACV9T,MAAO,iBACP0R,MAAOuE,EAAa,kBACpBpQ,KAAM,SACNyQ,UAAU,EACV7Q,KAAM,CACJ+P,YAAY,GAEd5B,UAAW,CACT,KAAM,oBAAqB,cAAe,kBAC1C,YAAa,gBAAiB,WAAY,gBAE5CiC,YAAa,SAAUnG,EAAMzK,GACZyK,EAAKN,IAAInL,KAAK,+BACtBwE,IAAIxD,GACX4P,EAA+BnF,EAAM+G,EAA8BD,EACpE,EACDzC,OAAQ,YACRC,cAAeyC,GAEjBlD,EAAoB,SAAUzO,EAAOmR,GACrC,CACErW,GAAI,sBACJkU,SAAU,eACV9T,MAAO,iBACP0R,MAAO,8BACP7L,KAAM,SACNqK,MAAO,SACPoG,UAAU,EACV7Q,KAAM,CACJ+P,YAAY,GAEd5B,UAAW,CAAC,MACZG,OAAQ,YACRC,cAAe,CACb0C,QAAS,CAAC,iBACVtK,QAAS,CACP,CAACtT,KAAM,gBAAiBmM,MAAO,cAC/B,CAACnM,KAAM,aAAcmM,MAAO,OAAQ,CAACnM,KAAM,oBAAqBmM,MAAO,OAAQ,CAACnM,KAAM,oBAAqBmM,MAAO,OAClH,CAACnM,KAAM,eAAgBmM,MAAO,OAAQ,CAACnM,KAAM,qBAAsBmM,MAAO,OAAQ,CAACnM,KAAM,cAAemM,MAAO,MAC/G,CAACnM,KAAM,mBAAoBmM,MAAO,OAAQ,CAACnM,KAAM,aAAcmM,MAAO,OAAQ,CAACnM,KAAM,gBAAiBmM,MAAO,OAC7G,CAACnM,KAAM,mBAAoBmM,MAAO,OAAQ,CAACnM,KAAM,mBAAoBmM,MAAO,OAAQ,CAACnM,KAAM,eAAgBmM,MAAO,MAClH,CAACnM,KAAM,oBAAqBmM,MAAO,OAAQ,CAACnM,KAAM,cAAemM,MAAO,MAAO,CAACnM,KAAM,kBAAmBmM,MAAO,OAChH,CAACnM,KAAM,eAAgBmM,MAAO,MAAO,CAACnM,KAAM,gBAAiBmM,MAAO,OAAQ,CAACnM,KAAM,gBAAiBmM,MAAO,OAC3G,CAACnM,KAAM,gBAAiBmM,MAAO,OAAQ,CAACnM,KAAM,cAAemM,MAAO,MAAO,CAACnM,KAAM,qBAAsBmM,MAAO,OAC/G,CAACnM,KAAM,eAAgBmM,MAAO,OAAQ,CAACnM,KAAM,aAAcmM,MAAO,MAAO,CAACnM,KAAM,qBAAsBmM,MAAO,OAC7G,CAACnM,KAAM,iBAAkBmM,MAAO,OAAQ,CAACnM,KAAM,eAAgBmM,MAAO,OAAQ,CAACnM,KAAM,eAAgBmM,MAAO,OAC5G,CAACnM,KAAM,gBAAiBmM,MAAO,OAAQ,CAACnM,KAAM,cAAemM,MAAO,OAAQ,CAACnM,KAAM,gBAAiBmM,MAAO,OAC3G,CAACnM,KAAM,cAAemM,MAAO,MAAO,CAACnM,KAAM,mBAAoBmM,MAAO,OAAQ,CAACnM,KAAM,eAAgBmM,MAAO,OAC5G,CAACnM,KAAM,aAAcmM,MAAO,MAAO,CAACnM,KAAM,mBAAoBmM,MAAO,OAAQ,CAACnM,KAAM,eAAgBmM,MAAO,OAC3G,CAACnM,KAAM,cAAemM,MAAO,OAAQ,CAACnM,KAAM,cAAemM,MAAO,OAAQ,CAACnM,KAAM,cAAemM,MAAO,OACvG,CAACnM,KAAM,eAAgBmM,MAAO,OAAQ,CAACnM,KAAM,iBAAkBmM,MAAO,OAAQ,CAACnM,KAAM,aAAcmM,MAAO,OAC1G,CAACnM,KAAM,kBAAmBmM,MAAO,OAEnCgS,cAAc,GAEhBpB,YAAa,SAAUnG,EAAMzK,GACZyK,EAAKN,IAAInL,KAAK,gCACtBiR,UAAU,WAAYjQ,EACrC,GAEIoQ,EAAqB,CACnBzV,GAAI,yCACJI,MAAO,sBACP0R,MAAO,yCACPoC,SAAU,aAEZuB,EAAqB,CACnBzV,GAAI,gDACJI,MAAO,6BACP0R,MAAO,gDACPoC,SAAU,aAEZP,EAAoB,sBAAuBzO,EAAOmR,EAAc,CAAEnC,SAAU,aAC5EP,EAAoB,sBAAuBzO,EAAOmR,EAAc,CAAEnC,SAAU,aAE5EP,EAAoB,eAAgBzO,EAAOmR,EAAc,CAAEnC,SAAU,cAAeF,UAAW,CAAC,cAChGL,EAAoB,iBAAkBzO,EAAOmR,EAAc,CAAEnC,SAAU,gBACvEP,EAAoB,SAAUzO,EAAOmR,EAAc,CAAEnC,SAAU,gBAC/DP,EAAoB,WAAYzO,EAAOmR,EAAc,CAAEnC,SAAU,gBACjEP,EAAoB,eAAgBzO,EAAOmR,EAAc,CAAEnC,SAAU,gBACrEP,EAAoB,mBAAoBzO,EAAOmR,EAAc,CAAEnC,SAAU,gBACzEP,EAAoB,gBAAiBzO,EAAOmR,GAC5C1C,EAAoB,cAAezO,EAAOmR,EAAc,CAAEnC,SAAU,gBACpEP,EAAoB,YAAazO,EAAOmR,GACxC1C,EAAoB,SAAUzO,EAAOmR,GACrC3B,EAAmB,YAAaxP,EAAOmR,EAAc,CAAErC,UAAW,CAAC,QAAS,OAAQ,UAAW,aAC/FU,EAAmB,UAAWxP,EAAOmR,EAAc,CAAErC,UAAW,CAAC,QAAS,OAAQ,UAAW,aAC7FL,EAAoB,QAASzO,EAAOmR,GACpC1C,EAAoB,WAAYzO,EAAOmR,GACvC1C,EAAoB,gBAAiBzO,EAAOmR,GAC5C1C,EAAoB,aAAczO,EAAOmR,GACzC1C,EAAoB,YAAazO,EAAOmR,GACxC1C,EAAoB,aAAczO,EAAOmR,GACzC3B,EAAmB,cAAexP,EAAOmR,EAAc,CAAErC,UAAW,CAAC,QAAS,OAAQ,UAAW,aACjG,CACEhU,GAAI,aACJI,MAAO,UACP0R,MAAOuE,EAAa,cACpBrC,UAAW,CAAC,cACZE,SAAU,QACV5D,MAAO,SAAUR,EAAMnS,GAKrB,MAAO,6BACWA,oDAJIyY,EAAUoB,mBAAmB3a,KAAI4U,GAC9C,kBAAkBA,MAASA,eACjC1S,KAAK,0IAK0BpB,+CAAkDA,sCAChEA,qKAIcA,+CAAkDA,sCAChEA,sKAIcA,+CAAkDA,8CAChEA,8FAGrB,EACDkY,YAAa,SAAU/F,GAGrB,MAAO,CAAC2H,KAFK3H,EAAKN,IAAInL,KAAK,oCAAoCwE,MAE3C6O,WADP5H,EAAKN,IAAInL,KAAK,4CAA4CwE,MAExE,EACDoN,YAAa,SAAUnG,EAAMzK,GAC3BrH,EAAE8R,EAAKN,IAAInL,KAAK,oCAAoC,IAAIwE,IAAIxD,EAAMoS,MAClE3H,EAAKN,IAAInL,KAAK,0CAA0CgB,EAAMqS,eAAejP,KAAK,WAAW,EAC9F,GAEH,CACEzI,GAAI,oBACJ8R,MAAO,wBACP1R,MAAO,YACP8T,SAAU,QACVjO,KAAM,UACNqK,MAAO,QACPxU,OAAQ,CACN,CAAC,EAAG,MACJ,CAAC,EAAG,QAENkZ,cAAe,EACfhB,UAAW,CAAC,WA0BhBuD,EAAsBnG,EAAkBmG,EAAqB5F,OAAOC,KAAK9C,IAGzE,MAAM6I,EAAMJ,EAAoB,GAChCA,EAAoB,GAAKA,EAAoB,GAC7CA,EAAoB,GAAKI,EAEzBtI,EAAaA,aAAa,CACxBuI,sBAAsB,EAGtBd,QAASlI,EACTiJ,QAASN,EACTO,cAAc,EACdC,aAAa,EACbC,UAAWlJ,EAEXkF,UAAWuC,EACXnS,KAvOa,CACb4P,UAAW,CACTiE,kBAAqB,yBACrBC,WAAc,MAqOhBC,aAlOqB,CACrBF,kBAAqB,CAAEG,GAAM,KAAMC,IAAK,OACxCH,WAAc,CAAEE,GAAM,OAkOtBE,UAAW,CACTxI,KA5CqB,EAAGyI,UAASC,QAAOtB,WAAUnG,YAAW0H,aACxD,gBACEF,8GAGPrB,EAASwB,eAAiB,gEAC6BF,EAAMtZ,0BAC3D,kaAOcsZ,EAAMG,qBAAqB5H,EAAU,2EAmCzD/S,EAAE,YAAYqO,GAAG,0EAA0E,SAASrN,EAAG8Q,GAC9E,mBAAnBA,EAAK9O,OAAOhB,IAGhBiV,EAA+BnF,EAAM+G,EAA8BD,EACvE,GAEA,wBCtwBA,SAASgC,EAAoBvT,GAC3B,OAAOhG,OAAOgG,GAAO/F,QAAQ,MAAO,IACtC,CAGO,MAAM0U,EAAY,CACvB6E,MAAO,CAAClW,EAAGC,IAAMD,GAAKC,EACtBkW,UAAW,CAACnW,EAAGC,IAAMD,GAAKC,EAC1BmW,GAAI,CAACpW,EAAGC,IAAMA,EAAEhJ,SAAS+I,GACzBqW,OAAQ,CAACrW,EAAGC,KAAOA,EAAEhJ,SAAS+I,GAC9BsW,KAAM,CAACtW,EAAGC,IAAMD,EAAIC,EACpBsW,cAAe,CAACvW,EAAGC,IAAMD,GAAKC,EAC9BuW,QAAS,CAACxW,EAAGC,IAAMD,EAAIC,EACvBwW,iBAAkB,CAACzW,EAAGC,IAAMD,GAAKC,EACjCyW,QAAS,CAAC1W,EAAGC,IAAMA,EAAE,IAAMD,GAAKA,GAAKC,EAAE,GACvC0W,YAAa,CAAC3W,EAAGC,MAAQA,EAAE,IAAMD,GAAKA,GAAKC,EAAE,IAC7C2W,YAAa,CAAC5W,EAAGC,IAAMgW,EAAoBjW,GAAGhJ,WAAWif,EAAoBhW,IAC7E4W,gBAAiB,CAAC7W,EAAGC,KAAOgW,EAAoBjW,GAAGhJ,WAAWif,EAAoBhW,IAClF6W,SAAU,CAAC9W,EAAGC,IAAMgW,EAAoBjW,GAAG/I,SAASgf,EAAoBhW,IACxE8W,aAAc,CAAC/W,EAAGC,KAAOgW,EAAoBjW,GAAG/I,SAASgf,EAAoBhW,IAC7E+W,UAAW,CAAChX,EAAGC,IAAMgW,EAAoBjW,GAAGiX,SAAShB,EAAoBhW,IACzEiX,cAAe,CAAClX,EAAGC,KAAOgW,EAAoBjW,GAAGiX,SAAShB,EAAoBhW,IAC9EkX,SAAWnX,GAAY,KAANA,SAAYA,GAAkCrF,MAAMqV,QAAQhQ,IAAmB,IAAbA,EAAE5H,OACrFgf,aAAepX,GAAY,KAANA,SAAYA,KAAmCrF,MAAMqV,QAAQhQ,IAAMA,EAAE5H,OAAS,GACnGif,QAAUrX,GAAMA,QAChBsX,YAActX,GAAMA,SASf,MAAMuX,EAIX,WAAAvK,CAAYwK,EAAwB,IAElC/Q,KAAK4K,UAAY,IAAKA,GACtB5K,KAAK+Q,sBAAwBA,CACjC,CASE,UAAAC,CAAWC,EAAOxU,GAChB,IAAKwU,IAAUxU,EACb,MAAO,GAIT,IAAoB,IAAhBwU,EAAMC,MACR,MAAO,GAGT,MAAMrI,EAAS,GAEf,GAAI3U,MAAMqV,QAAQ9M,GAChBA,EAAKtE,SAAQkQ,IACX,MAAM8I,EAAoBnR,KAAKoR,eAAeH,EAAO5I,GACjD8I,EAAkBE,OACpBxI,EAAO5W,KAAK,CACVqf,OAAQjJ,EACR9Q,aAAc4Z,EAAkBI,SAAW,MAEvD,SAIS,GAAqC,mBAA1B9U,EAAK+U,OAAOC,UAC1B,IAAK,MAAMpJ,KAAQ5L,EAAM,CACvB,MAAM0U,EAAoBnR,KAAKoR,eAAeH,EAAO5I,GACjD8I,EAAkBE,OACpBxI,EAAO5W,KAAK,CACVqf,OAAQjJ,EACR9Q,aAAc4Z,EAAkBI,SAAW,MAGvD,KAGS,IAAyB,mBAAd9U,EAAKiV,KAanB,MAAM,IAAIlQ,MAAM,iFAbwB,CACxC,IAAImQ,EAAWlV,EAAKiV,OACpB,MAAQC,EAASC,MAAM,CACrB,MAAMT,EAAoBnR,KAAKoR,eAAeH,EAAOU,EAAS1V,OAC1DkV,EAAkBE,OACpBxI,EAAO5W,KAAK,CACVqf,OAAQK,EAAS1V,MACjB1E,aAAc4Z,EAAkBI,SAAW,OAG/CI,EAAWlV,EAAKiV,MACxB,CACA,CAEA,CAEI,OAAO7I,CACX,CAUE,cAAAuI,CAAejJ,EAAOmJ,GAEpB,MAAMO,EAAgB,CAAChJ,EAAQiJ,IACxBA,EAEE,CACLT,OAAQxI,EAAOwI,OAHSxI,EAO5B,IAAKV,EAAM4J,YAAc5J,EAAM8I,MAC7B,OAAOY,EAAc,CAAER,OAAO,GAASlJ,EAAM6J,KAG/C,MAAMD,EAAY5J,EAAM4J,UAAUE,cAC5BhB,EAAQ9I,EAAM8I,MAEpB,IAAKA,IAAUA,EAAMtf,OACnB,OAAOkgB,EAAc,CAAER,OAAO,GAAQlJ,EAAM6J,KAG9C,MAAME,EAAUjB,EAAMxd,KAAIiT,GAEpBA,EAAKuK,MACAjR,KAAKoR,eAAe1K,EAAM4K,GAG1B5K,EAAK9P,IAAM8P,EAAKuF,SAChBjM,KAAKmS,cAAczL,EAAM4K,GAE3B,CAAED,OAAO,KAIlB,IAAIe,EAAiB,KAErB,GAAkB,QAAdL,EAAqB,CACvB,MAAMM,EAAUH,EAAQI,OAAMzJ,GAAUA,EAAOwI,QAgB/Ce,EAAiB,CACff,MAAOgB,EACPd,QAhBsBc,EACtBH,EAAQK,QAAO,CAACC,EAAK3J,KACfA,EAAO0I,SACThJ,OAAOkK,QAAQ5J,EAAO0I,SAASpZ,SAAQ,EAAEnB,EAAOua,MACzCiB,EAAIxb,GACA9C,MAAMqV,QAAQiJ,EAAIxb,KAAW9C,MAAMqV,QAAQgI,KAElDiB,EAAIxb,GAAS,IAAI,IAAI8S,IAAI,IAAI0I,EAAIxb,MAAWua,MAH7BiB,EAAIxb,GAASua,CAI5C,IAGiBiB,IACN,CAAA,GAAM,KAMjB,KAAW,IAAkB,OAAdT,EAUT,MAAM,IAAIvQ,MAAM,sBAAsBuQ,KAVT,CAC7B,MAAMW,EAAkBR,EAAQta,QAAOiR,GAAUA,EAAOwI,QAClDgB,EAAUK,EAAgB/gB,OAAS,EAGzCygB,EAAiB,CACff,MAAOgB,EACPd,QAASc,EAAUK,EAAgB,GAAGnB,QAAU,KAExD,CAEA,CAEI,OAAOM,EAAcO,EAAgBjK,EAAM6J,IAC/C,CAUE,aAAAG,CAAczL,EAAM4K,GAClB,MAAMta,EAAQ0P,EAAK1P,OAAS0P,EAAK9P,GAC3B+b,EAAejM,EAAKuF,SACpB2G,EAAmBlM,EAAKjK,OAAiC,IAAzBiK,EAAKjK,KAAK+P,WAGhD,GAAI9F,EAAK9P,IACLoJ,KAAK+Q,sBAAsBrK,EAAK9P,KAC6B,mBAAtDoJ,KAAK+Q,sBAAsBrK,EAAK9P,IAAI+b,GAA8B,CAG3E,MAAME,EAAeD,EAAmBtB,EAASA,EAAOta,GAClD6R,EAAS7I,KAAK+Q,sBAAsBrK,EAAK9P,IAAI+b,GAAcE,EAAcnM,EAAKzK,OAGpF,MAAyB,iBAAX4M,GAAuB,UAAWA,EAC9CA,EAAS,CAAEwI,MAAOyB,QAAQjK,GAClC,CAGI,IAAK+J,KAAsB5b,KAASsa,GAClC,MAAO,CAAED,OAAO,GAIlB,GAAIuB,EACF,MAAO,CAAEvB,OAAO,GAGlB,MAAM0B,EAAazB,EAAOta,GAG1B,GAAI,CAAC,WAAY,eAAgB,UAAW,eAAexG,SAASmiB,GAAe,CACjF,MAAM9J,EAAS7I,KAAK4K,UAAU+H,GAAcI,GAC5C,MAAO,CACL1B,MAAOxI,EACP0I,QAAS1I,EAAS,CAAE7R,CAACA,IAAQ,GAAS,KAE9C,CAGI,MAAMgc,EAAYtM,EAAKzK,MACvB,GAAI+W,QACF,MAAO,CAAE3B,OAAO,GAGlB,GAAyB,iBAAd2B,GAAyC,KAAfD,EAEnC,MAAO,CAAE1B,OAAO,GAIlB,MAAMxI,EAAS7I,KAAK4K,UAAU+H,GAAcI,EAAYC,GAClDX,EAAUS,QAAQjK,GAExB,MAAO,CACLwI,MAAOgB,EACPd,QAASc,EAAU,CAAErb,CAACA,IAAQ,GAAS,KAE7C,CAQE,WAAAic,CAAY1e,EAAM2e,GAChBlT,KAAK4K,UAAUrW,GAAQ2e,CAC3B,CAQE,gBAAAC,CAAiBC,EAAUF,GACzBlT,KAAKqT,eAAeD,GAAYF,CACpC,EAkBA,MAAMI,EAAyB,CAAChC,EAAQ0B,EAAWO,EAAYC,GAAS,KAEtE,MAQMC,EAAgB,CARAnC,EAAOnf,kBAGbmf,EAAOnH,QACrBmH,EAAOnH,QAAQlS,MAAM,KAAKxE,KAAI8F,GAAKA,EAAElB,SAAQT,QAAO2B,GAAKA,IACzD,IAMI0O,EAAQ/T,MAAMqV,QAAQyJ,GAAaA,EACjB,iBAAdA,GAA0BA,EAAUjb,QAAQ,MAAQ,EAC5Dib,EAAU/a,MAAM,KAChB,CAAC+a,GAGH,IAAI3B,EAAQoC,EAAcC,MAAKC,GAC7B1L,EAAMyL,MAAKrL,GAAQkL,EAAWI,EAAKtL,OAQrC,OAJImL,IACFnC,GAASA,GAGJ,CAAEA,QAAO,EAGZuC,EAAe,CAACC,EAAOb,EAAWc,EAAiBC,KACvD,MAAMC,EAASC,EAAsBF,GAE/BG,EAAqBlB,EAAyB,cAC9CmB,EAAuBnB,EAA2B,gBAClDoB,EAAYpB,EAAsB,WAMlCqB,EAAcR,EAAM,GAHCC,EAAgBtjB,SAAS,SAClD,sBAAwB,sCAGpB8jB,EAAuBT,EAA6B,sBAE1D,IAAIU,GAAa,EACb9c,EAAe,GACf+c,EAAgB,EAGpB,MAAMC,EAAe,CAACziB,EAAOD,MAER,iBAAdqiB,GAAgCriB,GAClB,cAAdqiB,IAA8BriB,KAInCwiB,GAAa,EACb9c,EAAaxF,KAAKD,GACdD,GAAYyiB,KACT,GAIT,GAAIN,GAAsBC,EACxB,IAAK,IAAIvhB,EAAI,EAAGA,EAAI8hB,KAAKzL,IAAIoL,EAAY1iB,OAAQ2iB,EAAqB3iB,QAASiB,IACzEohB,EAAOK,EAAYzhB,GAAIshB,IAAuBF,EAAOM,EAAqB1hB,GAAIuhB,IAChFM,EAAa7hB,EAAGvC,eAAegkB,EAAYzhB,UAO3CshB,GACFG,EAAYlc,SAAQ,CAAC7H,EAAMsC,KACrBohB,EAAO1jB,EAAM4jB,IACfO,EAAa7hB,EAAGvC,eAAeC,GACzC,IAKQ6jB,GACFG,EAAqBnc,SAAQ,CAAC7H,EAAMsC,KAClC,GAAIohB,EAAO1jB,EAAM6jB,GAAuB,CAEtC,MAAMpiB,EAAca,EAAIyhB,EAAY1iB,QAAWtB,eAAegkB,EAAYzhB,IAC1E6hB,EAAa7hB,EAAGb,EAC1B,KAKE,MAAO,CACLsf,MAAOkD,EACPhD,QAASgD,EAAa,CACpB7c,YAAaD,EACbkd,iBAAkBH,GAChB,KACL,EAiCGI,EAAwB,CAACC,EAAU7B,KAEhC,CAAE3B,MADqB,IAAd2B,EAA+B,IAAb6B,EAAiBA,EAAW,IA6B1D9D,EAAwB,CAC5B+D,eAAgB,CACdnF,GAAI,CAAC2B,EAAQ0B,IAAcM,EAAuBhC,EAAQ0B,EAAWpI,EAAU6E,OAC/EZ,kBAAmB,CAACyC,EAAQ0B,IAAcM,EAAuBhC,EAAQ0B,EAAWpI,EAAU6E,OAC9FU,YAAa,CAACmB,EAAQ0B,IAAcM,EAAuBhC,EAAQ0B,EAAWpI,EAAUuF,aACxFC,gBAAiB,CAACkB,EAAQ0B,IAAcM,EAAuBhC,EAAQ0B,EAAWpI,EAAUuF,aAAa,GACzGI,UAAW,CAACe,EAAQ0B,IAAcM,EAAuBhC,EAAQ0B,EAAWpI,EAAU2F,WACtFE,cAAe,CAACa,EAAQ0B,IAAcM,EAAuBhC,EAAQ0B,EAAWpI,EAAU2F,WAAW,GACrGF,SAAU,CAACiB,EAAQ0B,IAAcM,EAAuBhC,EAAQ0B,EAAWpI,EAAUyF,UACrFC,aAAc,CAACgB,EAAQ0B,IAAcM,EAAuBhC,EAAQ0B,EAAWpI,EAAUyF,UAAU,GACnGZ,MAAO,CAAC6B,EAAQ0B,IAAcM,EAAuBhC,EAAQ0B,EAAWpI,EAAU6E,OAClFC,UAAW,CAAC4B,EAAQ0B,IAAcM,EAAuBhC,EAAQ0B,EAAWpI,EAAU8E,YAExFqF,oBAAqB,CACnBpF,GAvC4B,CAACkE,EAAOmB,KACtC,IAAK,IAAIpiB,EAAI,EAAGA,EAAIoiB,EAAWrjB,OAAQiB,IAAK,CAE1C,GAAqB,cAAjBoiB,EAAWpiB,GAAoB,CACjC,MAAMqiB,EAAY,CAAC,MAAO,MAAO,MAAO,MAAO,MAAO,KAAM,MAAO,MAAO,MAAO,MAAO,MAAO,KAAM,MAAO,KAAM,MAAO,KAAM,MAAO,MAAO,MAAO,KAAM,MAAO,MACjK,IAAK,IAAIle,EAAI,EAAGA,EAAIke,EAAUtjB,OAAQoF,IACpC,GAAI6T,EAAUuF,YAAY0D,EAAsB,eAAGoB,EAAUle,IAC3D,MAAO,CAAEsa,OAAO,GAGpB,MAAM6D,EAAY,CAAC,QAAS,UAAW,YACvC,IAAK,IAAIne,EAAI,EAAGA,EAAIme,EAAUvjB,OAAQoF,IACpC,GAAI6T,EAAUyF,SAASwD,EAAgB,SAAGqB,EAAUne,IAClD,MAAO,CAAEsa,OAAO,GAGpB,MAAO,CAAEA,OAAO,EACtB,CACI,GAAIzG,EAAUuF,YAAY0D,EAAsB,eAAGmB,EAAWpiB,IAC5D,MAAO,CAAEye,OAAO,EAEtB,CACE,MAAO,CAAEA,OAAO,EAAO,GAmBvB8D,uCAAwC,CACtC9E,SAAU,CAAC0C,EAAYC,IACdY,EAAab,EAAYC,EAAW,yBAA0B,YAEvEvD,MAAO,CAACsD,EAAYC,IACXY,EAAab,EAAYC,EAAW,yBAA0B,SAEvE7C,YAAa,CAAC4C,EAAYC,IACjBY,EAAab,EAAYC,EAAW,yBAA0B,cAEvEzC,UAAW,CAACwC,EAAYC,IACfY,EAAab,EAAYC,EAAW,yBAA0B,aAGzEoC,8CAA+C,CAC7C/E,SAAU,CAAC0C,EAAYC,IACdY,EAAab,EAAYC,EAAW,gCAAiC,YAE9EvD,MAAO,CAACsD,EAAYC,IACXY,EAAab,EAAYC,EAAW,gCAAiC,SAE9E7C,YAAa,CAAC4C,EAAYC,IACjBY,EAAab,EAAYC,EAAW,gCAAiC,cAE9EzC,UAAW,CAACwC,EAAYC,IACfY,EAAab,EAAYC,EAAW,gCAAiC,aAGhFlE,WAAY,CACVA,WAzGoB,CAAC/a,EAASif,KAChC,IAAKjf,GAA8B,IAAnBA,EAAQpC,OACtB,MAAO,CAAE0f,OAAO,GAGlB,MAAMgE,EAAgBphB,SAAS+e,EAAU1E,WAAY,IAC/CgH,EAAatC,EAAU3E,KAG7B,IAAK,MAAMkH,KAASxhB,EAClB,GAAKG,MAAMqV,QAAQgM,GAEnB,IAAK,MAAMpN,KAASoN,EAClB,GAAKrhB,MAAMqV,QAAQpB,GAEnB,IAAK,MAAMqN,KAAWrN,EAEpB,GAAIqN,EAAQjhB,OAAS+gB,IAEG,IAAlBD,GAAuBA,IAAkBG,EAAQlhB,WACnD,MAAO,CAAE+c,OAAO,GAO1B,MAAO,CAAEA,OAAO,EAAO,GAgFvBoE,kBAAmB,CACjBhG,MAAOmF,EACPlF,UAAW,CAACqD,EAAYC,KAEf,CAAE3B,OADMuD,EAAsB7B,EAAYC,GACzB3B,UAavB,SAAS4C,EAAsBF,EAAY3Q,EAAU,IAC1D,MAAMwD,WAAEA,GAAa,GAAUxD,EAGzBsS,EAAgB9O,EAClBlW,GAAOuF,OAAOvF,GAAK4Z,cACnB5Z,GAAOuF,OAAOvF,GAEZilB,EAAerlB,IAEnB,GAAIA,EAAKE,SAAS,WAAaF,EAAKE,SAAS,KAAM,CAOjD,OALcF,EAAK2H,MAAM,aAAaxE,KAAIc,GAEjCA,EAAK8D,OAAOnC,QAAQ,cAAe,KAIlD,CAGI,MAAO,CAAC5F,EAAK,EAGf,OAAQyjB,GACN,IAAK,QACH,MAAO,CAACzjB,EAAMsd,IACE+H,EAAYrlB,GAEbojB,MAAKkC,GAAKF,EAAcE,KAAOF,EAAc9H,KAG9D,IAAK,aACH,MAAO,CAACtd,EAAMsd,IACE+H,EAAYrlB,GAEbojB,MAAKkC,GAAKF,EAAcE,GAAGrlB,WAAWmlB,EAAc9H,MAGrE,IAAK,WACH,MAAO,CAACtd,EAAMsd,IACE+H,EAAYrlB,GAEbojB,MAAKkC,GAAKF,EAAcE,GAAGpF,SAASkF,EAAc9H,MAGnE,IAAK,QACH,MAAO,CAACtd,EAAMsd,KACZ,IAIE,OADc,IAAI7c,OAAO6c,EAFXhH,EAAa,IAAM,IAGpB/F,KAAKvQ,EACnB,CAAC,MAAOwF,GACP,MAAM,IAAI0L,MAAM,0BAA0BoM,IACpD,GAKI,QACE,MAAO,CAACtd,EAAMsd,IACE+H,EAAYrlB,GAEbojB,MAAKkC,GAAKF,EAAcE,GAAGplB,SAASklB,EAAc9H,MAGvE,oFAqBO,SAAmC9R,GACxC,IAAI+Z,EAAmB,EACnBC,EAAqB,EACrBC,EAAkB,EAEtB,IACE,MAAMtD,EAAU3W,EAAMpJ,SACtB,IAAK,MAAMmhB,KAASpB,EACdoB,EAAMtc,cAAgBsc,EAAMtc,aAAaG,aAC3Cme,GAAoBhC,EAAMtc,aAAaG,YAAY/F,OACnDmkB,GAAsBjC,EAAMtc,aAAaod,mBAEzCkB,GAAoBhC,EAAMzZ,oCAAoCzI,OAC9DkiB,EAAMzZ,oCAAoCjC,SAAQoC,IAChDub,GAAsBvb,EAASxI,UAAU,KAG7CgkB,GAEH,CAAC,MAAOjgB,GACPD,QAAQC,MAAM,8CAA+CA,EACjE,CAEElB,EAAEY,UAAUuK,QAAQ,uBAAwB,CAAEiW,MAAOD,IACrDnhB,EAAEY,UAAUuK,QAAQ,kBAAmB,CAAEiW,MAAOH,IAChDjhB,EAAEY,UAAUuK,QAAQ,0BAA2B,CAAEiW,MAAOF,GAC1D,WArCO,SAAkB7E,EAAOnV,GAQ9B,OAPe,IAAIgV,EAAmBC,GACZC,WAAWC,EAAOnV,GACjBrI,KAAI,EAAG6d,SAAQ/Z,mBAAoB,IACzD+Z,EACH/Z,kBAIJ,2DA8BO,SAA0C7G,EAAKulB,GAEpDA,EAAezV,MAAK,CAACjH,EAAGC,IAAMD,EAAE1H,MAAQ2H,EAAE3H,QAE1C,IAAIqkB,EAAiB,GACjBC,EAAY,EAchB,OAZAF,EAAe9d,SAAQ,EAAEtG,QAAOC,MAAKhC,WAEnComB,GAAkBxlB,EAAIc,MAAM2kB,EAAWtkB,GAEvCqkB,GAAkB,2BAA2BxlB,EAAIc,MAAMK,EAAOC,YAE9DqkB,EAAYrkB,CAAG,IAIjBokB,GAAkBxlB,EAAIc,MAAM2kB,GAErBD,CACT,mEC1pBO,MACL,WAAA3P,CAAYzK,GACVkE,KAAKlE,MAAQA,EACbkE,KAAKoW,cAAgB,KACrBpW,KAAKqW,oBAAsB,GAC3BrW,KAAKsW,cAAgB,IAAIxM,IAEzB,IAAK,MAAMlP,KAAekB,EAAMpJ,SAC9B,GAAIkI,EAAY7G,SAAWG,MAAMqV,QAAQ3O,EAAY7G,SACnD,IAAK,MAAMwhB,KAAS3a,EAAY7G,QAC9B,GAAIG,MAAMqV,QAAQgM,GAChB,IAAK,MAAMpN,KAASoN,EAClB,GAAIrhB,MAAMqV,QAAQpB,GAChB,IAAK,MAAMqN,KAAWrN,EACpBnI,KAAKsW,cAAcrM,IAAIuL,EAAQjhB,MAQ7CyL,KAAKsW,cAAgBpiB,MAAMkI,KAAK4D,KAAKsW,eAAe9V,MACxD,CAGE,kBAAA+V,CAAmB3f,GACjB,OAAIoJ,KAAKoW,eAAiBpW,KAAKoW,cAAcnS,IAAIrN,GACxCoJ,KAAKoW,cAAchS,IAAIxN,GAEzBoJ,KAAKlE,MAAMsI,IAAIxN,EAC1B,CAEE,gBAAAwX,GACE,OAAOpO,KAAKsW,aAChB,CAEE,eAAA/gB,CAAgBihB,GACd,OAAIxW,KAAKoW,eAAiBpW,KAAKoW,cAAcvL,KAAO,EAC3C2L,EAAI/iB,KAAImD,GAAMoJ,KAAKoW,cAAchS,IAAInQ,SAAS2C,EAAI,OAEpD4f,EAAI/iB,KAAImD,GAAMoJ,KAAKlE,MAAMsI,IAAInQ,SAAS2C,EAAI,MACrD,CAME,kBAAAsW,GACE,OAAOlN,KAAKlE,KAChB,CAGE,qBAAA2a,GACE,OAAIzW,KAAKoW,cACAliB,MAAMkI,KAAK4D,KAAKoW,cAAc1jB,UAEhCwB,MAAMkI,KAAK4D,KAAKlE,MAAMpJ,SACjC,CAGE,uBAAAgkB,GACE,OAAI1W,KAAKoW,cACAliB,MAAMkI,KAAK4D,KAAKoW,cAAc5N,QAEhCtU,MAAMkI,KAAK4D,KAAKlE,MAAM0M,OACjC,CAGE,gBAAAmO,CAAiBzE,GACVA,GAMLlS,KAAKoW,cAAgB,IAAIzb,IACzBuX,EAAQ/Z,SAAQ0Q,IACd7I,KAAKoW,cAAcvb,IAAIgO,EAAOjS,GAAIiS,EAAO,IAO3CjU,EAAEY,UAAUuK,QAAQ,mBAAoB,CACtCoL,OAAQ,SACR6K,MAAOhW,KAAKoW,cAAcvL,KAC1BhE,MAAO7G,QAjBPA,KAAKoW,cAAgB,IAmB3B,CAGE,kBAAAQ,GACE5W,KAAKoW,cAAgB,KAGrBxhB,EAAEY,UAAUuK,QAAQ,mBAAoB,CACtCoL,OAAQ,QACR6K,MAAOhW,KAAKlE,MAAM+O,KAClBhE,MAAO7G,MAEb,KCvGA,SAAS6W,EAAoBC,GAC3BC,GAAYD,EAAIE,OAAOC,OACvB5d,sBAGAzE,EAAE,8BAA8BwP,IAAI,GAAG8S,OACzC,CAEA,SAASH,GAAYE,GACnB,GAAoB,GAAhBA,EAAMtlB,OAAV,CAGA,IAAIwlB,EAAa,IAAIC,WACjBC,EAAOJ,EAAM,GACjBE,EAAWG,UAAY,SAASR,GAC1BA,EAAIE,OAAOO,YAAcH,WAAWI,OACtC5iB,EAAE,qBAAqBQ,KAAK,iDAC5BqiB,cACA1iB,WAAW2iB,GAAyB,GAAIZ,EAAIE,OAAOnO,QAEzD,EACEsO,EAAWQ,WAAWN,EAVxB,CAWA,CAEA,SAASO,GAAWhiB,GAIlBmhB,GAHSnhB,EAAEiiB,aACIZ,OAGf5d,qBACF,CAGA,SAASye,GAAiBliB,GACxBA,EAAE4J,iBACF5J,EAAEmiB,iBACJ,CACA,SAAS9nB,GAAU2F,GACjBoiB,SAASC,UAAUhO,IAAI,YACzB,CAEA,SAASiO,GAAYtiB,GACnBoiB,SAASC,UAAUE,OAAO,YAC5B,CAIA,SAAST,GAAwBU,GAC/B,GAAoB,OAAhBA,EACF,OAEF,GAAI,uBAAuBvX,KAAKuX,GAG9B,OAFAC,MAAM,4FACNxf,cAIF,MAAMyf,EAAUC,KAAK5Z,MAAMyZ,GAC3B,IAAII,EAAWF,EAAQ7b,KAAK9K,OACxB8mB,EAAe,EACfC,EAAkB,EAElBC,EAAa,EACbjmB,EAAS,GAeb,GAbgB,GAAZ8lB,IAE6B,iBAApBF,EAAQ7b,KAAK,GACe,GAAjC6b,EAAQ7b,KAAK,GAAGpE,OAAO1G,SACzB6mB,EAAW,GAG2B,GAApCF,EAAQ7b,KAAK,GAAG,GAAGpE,OAAO1G,SAC5B6mB,EAAW,IAKbA,EAAW,EAAG,CAChB,IAAII,EAAqBN,EAAQ7b,KAAK,GAAGoc,WAAUxQ,GAAQ,cAAgBA,EAAKiC,iBACrD,GAAvBsO,IACFH,EAAe,EACfC,EAAkBE,GAGpBD,EAAaL,EAAQ7b,KAAK9K,OAC1B,IAAK,IAAIiB,EAAI6lB,EAAc7lB,EAAI+lB,EAAY/lB,IAEpC0lB,EAAQ7b,KAAK7J,GAAG8lB,IAAsE,GAAlDJ,EAAQ7b,KAAK7J,GAAG8lB,GAAiBrgB,OAAO1G,QAGjFe,EAAOT,KAAKqmB,EAAQ7b,KAAK7J,GAAG8lB,GAAiBrgB,OAEnD,KAAS,CAELsgB,EAAaL,EAAQ7b,KAAK,GAAG9K,OAC7B,IAASiB,EAAI,EAAGA,EAAI+lB,EAAY/lB,IAEzB0lB,EAAQ7b,KAAK,GAAG7J,IAA0C,GAApC0lB,EAAQ7b,KAAK,GAAG7J,GAAGyF,OAAO1G,QAGrDe,EAAOT,KAAKqmB,EAAQ7b,KAAK,GAAG7J,GAAGyF,OAErC,CAGE3F,EAASA,EAAOiD,KAAK,KAErB,IAUImjB,EAAW,CACb/G,UAAW,KACXd,MAZS,CAAC,CACVra,GAAI,iBACJI,MAAO,iBACP6F,KAAM,SACNqK,MAAO,OACP+E,SAAU,oBACVhQ,MAAOvJ,EACPkU,YAAY,IAMZoL,KAAK,GAGPpd,EAAE,IAAImkB,mBAAmB9S,aAAa,WAAY6S,GAAU,GAE5DjgB,cAEArD,SAASC,eAAe,aAAa2H,OACvC,sDAEO,WACL,MAAM4a,EAAWxiB,SAASC,eAAe,aACzC,CAAC,YAAa,WAAY,YAAa,QAAQ0C,SAAQ6gB,IACrDhB,EAAS5c,iBAAiB4d,EAAWlB,IAAiB,EAAK,IAE7D,CAAC,YAAa,YAAY3f,SAAQ6gB,IAChChB,EAAS5c,iBAAiB4d,EAAW/oB,IAAW,EAAK,IAEvD,CAAC,YAAa,QAAQkI,SAAQ6gB,IAC5BhB,EAAS5c,iBAAiB4d,EAAWd,IAAa,EAAK,IAEzDF,EAAS5c,iBAAiB,OAAQwc,IAAY,GAC9CpiB,SAASC,eAAe,YAAY2F,iBAAiB,SAAUyb,GAAqB,EACtF,ICvIAtO,OAAO0Q,OAAOhb,OAAQib,EAASC,EAASC,EAAYC,EAAsBC,EAAeC,EAAmBC"}