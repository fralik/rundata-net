{% load static %}
{% load settings %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Rundata.info is a web version of ​​​Scandinavian Runic-text Data Base.">
    <title>Rundata-net</title>
    {% get_from_settings 'USE_GA' as use_ga %}
    {% if use_ga %}
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-116856737-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-116856737-2');
    </script>
    {% endif %}

    <link href="https://netdna.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="{% static 'runes/jstree/themes/default/style.min.css' %}" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css"
     integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ=="
     crossorigin=""/>
    <link rel="stylesheet" href="{% static 'runes/css/MarkerCluster.css' %}" />
    <link rel="stylesheet" href="{% static 'runes/css/MarkerCluster.Default.css' %}" />
    <link rel="stylesheet" href="{% static 'runes/pixabay/jquery.auto-complete.css' %}" />

    <link rel="apple-touch-icon" sizes="180x180" href="{% static 'apple-touch-icon.png' %}">
    <link rel="icon" type="image/png" sizes="32x32" href="{% static 'favicon-32x32.png' %}">
    <link rel="icon" type="image/png" sizes="16x16" href="{% static 'favicon-16x16.png' %}">
    <link rel="mask-icon" href="{% static 'safari-pinned-tab.svg' %}" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#2b5797">
    <meta name="theme-color" content="#ffffff">

    <style type="text/css">
      .my-fixed-height {
        max-height: 500px;
        min-height: 500px;
        height: 500px;
        margin-bottom: 15px;
      }
      .jstree-scrollable {
        overflow-y: scroll;
        max-height: 95%;
        height: 95%;
      }
      .border-1 {
        border: 1px solid #ccc;
      }
      .group-full-heigth {
        max-height: 100%;
        min-height: 100%;
        height: 100%;
      }
      .border-left-bottom {
        border-left: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
      }
      .border-bottom-right {
        border-right: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
      }
      .border-bottom {
        border-bottom: 1px solid #ccc;
      }
      body {
        font-family: 'Lucida Grande', 'Lucida Sans Unicode', 'Lucida Sans', 'DejaVu Sans', Verdana, Helvetica, sans-serif;
      }
      .transliteration {
        font-weight: bold;
      }
      .normalization {
        font-style: italic;
        font-weight: normal;
      }
      th {
        text-align: center;
      }
      span.null {
        font-weight: bold;
        color: #CCCCCC;
      }
      .white-text {
        color:#fff!important;
      }
      .navbar-static-top {
        margin-bottom: 0px;
      }

      .vertical-align {
        display: flex;
        align-items: center;
      }
      .inscription-section {
        border-bottom: 2px solid #999;
      }
      .search-status {
        padding-left: 10px;
        padding-top: 5px;
      }
      .zero-padding-left {
        padding-left: 0px;
      }
      .highlighted {
        color: red;
      }
    </style>
  </head>
<body style="">
  <nav class="navbar navbar-default navbar-static-top">
    <div class="container">
      <div class="navbar-header">
        <a class="navbar-brand" href="#">Rundata-net</a>
      </div>
      <ul class="nav navbar-nav navbar-right">
        <li class=""><a href="{% url 'runes:about' %}" target="_blank">About</a></li>
        <li class=""><a href="http://rundata-net.rtfd.io/" target="_blank">Help</a></li>
        <li class=""><a href="{% url 'runes:references' %}" target="_blank">Bibliography</a></li>
      </ul>
    </div>
  </nav>

  <div class="container-fluid">
    <div class="row">
      <div class="col alert alert-danger hidden" role="alert" id="alertObj"></div>
    </div>

    <div class="row">
      <div id="leftPanel" class="col-md-3 col-sm-3 my-fixed-height table-bordered" style="padding: 0;">
        <div class="list-group group-full-heigth" style="padding-right: 0px; position: relative;">
          <div id="jstree" class="jstree-scrollable border-bottom"></div>
          <div id="lblNumAvailable" class="search-status"></div>
        </div>
      </div>
      <div id="mainDisplay" contentEditable="true" class="col-md-5 col-sm-7 table-bordered my-fixed-height pre-scrollable"></div>
      <div id="mapDisplay" class="col-md-4 col-sm-2 my-fixed-height"></div>
    </div>

    <form class="row" role="group">
      <div class="checkbox col-md-2">
        <input type="checkbox" id="chkApplyFilters">
        <label for="chkApplyFilters">Apply filter(s)</label>
      </div>
      <div class="col-md-10 btn-group" role="group" aria-label="">
        <button type="button" class="btn btn-default" id="btnDisplayFormat">Show display format dialog</button>
        <button type="button" class="btn btn-default" id="btnShowMap">Hide map</button>
      </div>
    </form>

    <section role="group" class="row vertical-align">
      <div class="col-md-2 zero-padding-left">Copy symbols to clipboard:</div>
      <div class="col-md-10 btn-group" role="group">
        <button type="button" class="btn clip" id="btnOUmlautSmall">ö</button>
        <button type="button" class="btn clip" id="btnOUmlaut">Ö</button>
        <button type="button" class="btn clip" id="btnAaSmall">å</button>
        <button type="button" class="btn clip" id="btnAa">Å</button>
        <button type="button" class="btn clip" id="btnAaUmlautSmall">ä</button>
        <button type="button" class="btn clip" id="btnAaUmlaut">Ä</button>
        <button type="button" class="btn clip" id="btnDot">•</button>
        <button type="button" class="btn clip" id="btnX">×</button>
        <button type="button" class="btn clip" id="btnTh">þ</button>
        <button type="button" class="btn clip" id="btnEn">ñ</button>
        <button type="button" class="btn clip" id="btnDh">ð</button>
        <button type="button" class="btn clip" id="btnAe">æ</button>
        <button type="button" class="btn clip" id="btnOe">ø</button>
        <button type="button" class="btn clip" id="btnCross">†</button>
        <button type="button" class="btn clip" id="btnOe2">œ</button>
        <button type="button" class="btn clip" id="btnOhakeSmall">ô</button>
        <button type="button" class="btn clip" id="btnOhakeCapital">Ô</button>
        <button type="button" class="btn clip" id="btnRuneR">ᛦ</button>
      </div>
    </section>
    <section role="group" class="row"><div class="col">&nbsp;</div></section>

    <div id="divFormatDiaglog" class="row border-1">
      <div class="col-sm-5">
        <select name="from[]" id="multiselect" class="form-control" size="8" multiple="multiple"></select>
        <div class="row">
          <form role="form" class="col-sm-6">
            <div class="checkbox">
              <input type="checkbox" id="chkDisplayHeaders" checked>
              <label for="chkDisplayHeaders">Display headers</label>
            </div>
          </form>
        </div>
      </div>

      <div class="col-sm-2">
        <button type="button" id="multiselect_rightAll" class="btn btn-block"><i class="glyphicon glyphicon-forward"></i></button>
        <button type="button" id="multiselect_rightSelected" class="btn btn-block"><i class="glyphicon glyphicon-chevron-right"></i></button>
        <button type="button" id="multiselect_leftSelected" class="btn btn-block"><i class="glyphicon glyphicon-chevron-left"></i></button>
        <button type="button" id="multiselect_leftAll" class="btn btn-block"><i class="glyphicon glyphicon-backward"></i></button>
      </div>

      <div class="col-sm-5">
        <select name="to[]" id="multiselect_to" class="form-control" size="8" multiple="multiple"></select>
        <div class="row">
          <div class="col-sm-6">
            <button type="button" id="multiselect_move_up" class="btn btn-block"><i class="glyphicon glyphicon-arrow-up"></i></button>
          </div>
          <div class="col-sm-6">
            <button type="button" id="multiselect_move_down" class="btn btn-block"><i class="glyphicon glyphicon-arrow-down"></i></button>
          </div>
        </div>
      </div>
    </div>

    <div class="row">
      <div id="builder" class="col"></div>
    </div>

  </div>

  <aside id="loading" class="loading-screen" style="position:fixed; top:0; right:0; bottom:0; left:0; z-index:9999; background-color: #000; opacity: 0.6;">
    <div class="col-sm-8 col-sm-offset-2 col-md-6 col-md-offset-3 col-lg-4 col-lg-offset-4" style="position:absolute; top:50%; margin-top:-7em">
      <div class="page-header">
        <i class="text-primary fa fa-spin fa-fw pull-left fa-spinner fa-2x" style="text-shadow: 0px 0px 0ex;"></i>
        <hgroup class="" style="text-shadow: 0px 0px 0ex;">
          <h4 ng-switch-default="" class="white-text">
            Loading<br>
            <small class="white-text">It can take up to 45 seconds.</small>
          </h4>
        </hgroup>
      </div>
    </div>
  </aside>

<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<!-- query builder styles -->
<!-- <link href="{% static 'query-builder/bootstrap-datepicker3.min.css' %}" rel="stylesheet"> -->
<!-- <link href="{% static 'query-builder/bootstrap-slider.min.css' %}" rel="stylesheet"> -->
<link href="{% static 'query-builder/selectize.bootstrap3.css' %}" rel="stylesheet">
<link href="{% static 'query-builder/bootstrap-select.min.css' %}" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/awesome-bootstrap-checkbox/0.3.7/awesome-bootstrap-checkbox.css" rel="stylesheet">
<link href="{% static 'query-builder/query-builder.default.min.css' %}" rel="stylesheet">
<!--<link href="{% static 'runes/chosen/chosen.min.css' %}" rel="stylesheet">-->
<link href="{% static 'runes/jquery-ui/jquery-ui.min.css' %}" rel="stylesheet">
<!-- end of query builder styles -->

<script>
/**
 * detect IE
 * returns version of IE or false, if browser is not Internet Explorer
 */
function detectIE() {
  var ua = window.navigator.userAgent;

  // Test values; Uncomment to check result …

  // IE 10
  // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';

  // IE 11
  // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';

  // Edge 12 (Spartan)
  // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';

  // Edge 13
  // ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586';

  var msie = ua.indexOf('MSIE ');
  if (msie > 0) {
    // IE 10 or older => return version number
    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
  }

  var trident = ua.indexOf('Trident/');
  if (trident > 0) {
    // IE 11 => return version number
    var rv = ua.indexOf('rv:');
    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
  }

  var edge = ua.indexOf('Edge/');
  if (edge > 0) {
    // Edge (IE 12+) => return version number
    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
  }

  // other browser
  return false;
}

var ieVersion = detectIE();
if (ieVersion !== false && ieVersion <= 12) {
  alert('This version of Internet Explorer is not supported. Please update or use a different browser. Will redirect to About page.');
  window.location.href = "{% url 'runes:about' %}#browser-support";
}
</script>

<script src="https://unpkg.com/clipboard@2.0.0/dist/clipboard.min.js"></script>
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="{% static 'runes/jstree/jstree.js' %}"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bootbox.js/4.3.0/bootbox.min.js"></script>
<script src="{% static 'runes/interact.min.js' %}"></script>
<script src="{% static 'runes/sql.js' %}"></script>

<!-- begin of query builder js -->
<script src="{% static 'query-builder/moment.min.js' %}"></script>
<!-- <script src="{% static 'query-builder/bootstrap-datepicker.min.js' %}"></script> -->
<!--<script src="{% static 'query-builder/bootstrap-slider.min.js' %}"></script>-->
<script src="{% static 'query-builder/selectize.min.js' %}"></script>
<script src="{% static 'query-builder/bootstrap-select.min.js' %}"></script>
<script src="{% static 'query-builder/query-builder.standalone.min.js' %}"></script>
<script src="{% static 'query-builder/interact.min.js' %}"></script>
<!--<script type="text/javascript" src="{% static 'runes/chosen/chosen.jquery.min.js' %}"></script>-->
<script type="text/javascript" src="{% static 'runes/jquery-ui/jquery-ui.min.js' %}"></script>
<!-- end of query builder js -->

<script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"
 integrity="sha512-/Nsx9X4HebavoBvEBuyp3I7od5tA0UzAxs+j83KgC8PU0kgB4XiK4Lfe4y4cgBtaRJQEIFCW+oC506aPT2L1zw=="
 crossorigin=""></script>
<script src="{% static 'runes/leaflet.markercluster.js' %}"></script>

<script src="{% static 'runes/multiselect.min.js' %}"></script>
<script src="{% static 'runes/pixabay/jquery.auto-complete.min.js' %}"></script>
<!-- <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script> -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/clusterize.js/0.18.0/clusterize.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/clusterize.js/0.18.0/clusterize.js"></script>

<script type="text/javascript">
var entityMap = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '/': '&#x2F;',
  '`': '&#x60;',
  '=': '&#x3D;'
};

function escapeHtml (string) {
  return String(string).replace(/[&<>"'`=\/]/g, function (s) {
    return entityMap[s];
  });
}

// Globals:
// connection to the DB
var db = null;
// original data when no filter is applied.
// Used as cache, so we can skip quering the db again
var originalData = [];
var rootIds = []; // Map of parent/root inscription IDs
var rootsJson = []; // JSON representation for rootIds
var sumRootChildren = 0; // number of all children signatures in current search
var origianlSumRootChildren = 0; // reference of sumRootChildren, similar to originalData.
var signatureNames = []; // names of all signatures in the DB
var signaturesSelectize = [];
var formatDialog = [];
var userSelectedDisplay = []; // list of user selected fields for display per inscription
var myMap = null; // Global handle to map object
var mapMarkers = {}; // Collection of created map markers. This is used in order to create
  // markers only once.
var markers = []; // Leaflet markers group
var numSelectedSignatures = [];
var renderIsDone = false;
var lastShowHeaders = true; // last value of show headers checkbox in display format dialog
var gRegExpMap = {}; // Object of all regex expressions
var gRegExpMapG = {}; // Object of all regex expressions with global flag
var gWordIndices = {}; // Object that contains matched word indices across inscription text.
    // Words in this case are based on values prepared for search.
    // Each entry is an object itself where keys are column names and values
    // are arrays of matched words. Example entry of gWordIndices:
    // {search_transliteration: [1, 3, 5]; normalisation_search_norse: [3];}
var gMatchedWordIndices = {}; // A processed version of gWordIndices. It is a map that provides
    // information which words are matched for particular signature id. Key is signature id,
    // values set of matched word indices.
var gFoundPersonalNames = 0;
var gWordVariants = 0;
// regex that is used to separate words in displayed inscription texts.
//var gWordSearchRegex = new RegExp("((·|:|×|¤|'|\\+|÷|\\s)+|¶+)+", 'g');
var gWordSearchRegex = new RegExp("((\\s+|^(·|:|×|¤|'|\\+|÷|¶))(·|:|×|¤|'|\\+|÷|¶){0,1}\\s*)", 'g');
var gWordSearchRegexEsc = new RegExp(escapeHtml("((\\s+|^(·|:|×|¤|'|\\+|÷|¶))(·|:|×|¤|'|\\+|÷|¶){0,1}\\s*)"), 'g');
var gWordPunctuationRegex = new RegExp("(·|:|×|¤|'|\\+|÷|¶|\\(|\\)|\\[|\\])+");
var gWordPunctuationRegexEsc = new RegExp(escapeHtml("(·|:|×|¤|'|\\+|÷|¶|\\(|\\)|\\[|\\])+"));

// defaults. TODO: should be replaced with reading from local storage memory
userSelectedDisplay = ['signature_text', 'transliteration', 'normalisation_norse'];

// An extension of Leaflet marker that provides information about inscription
MarkerWithData = L.Marker.extend({
   options: {
      inscription: '',
   }
});

function applyPagination() {
  $('#jstree').jstree(true).refresh();

  var total = rootsJson.length + sumRootChildren;
  if (total == 0) {
    $('#lblNumAvailable').html('Sorry, no inscriptions has been found.');
  } else {
    let numWords = 0;
    for (signId in gMatchedWordIndices) {
      numWords += gMatchedWordIndices[signId].size;
    }
    let infoStr = `${rootsJson.length} inscriptions`;
    numWords -= gWordVariants;
    if (numWords > 0) {
      infoStr += `, ${numWords} words, ${gFoundPersonalNames} personal names`;
    }
    infoStr += '.';
    $('#lblNumAvailable').html(infoStr);
  }

  $('#mainDisplay').empty();
  for (let key in mapMarkers) {
    if (mapMarkers.hasOwnProperty(key)) {
      mapMarkers[key].remove();
    }
  }
  markers.clearLayers();
}

function dbToJson(columnNames, values, rootsWithChildren = null) {
  let lostIdx = columnNames.indexOf('lost');
  let newReadingIdx = columnNames.indexOf('new_reading');

  let dbJson = values.map(function(v, i) {
      var hasChildren = false;
      //if (rootsWithChildren !== null && rootsWithChildren.has(v[0])) {
          //hasChildren = true;
      //}

      let additional = '';
      if (lostIdx != -1 && newReadingIdx != -1) {
        let isLost = !!+v[lostIdx];
        let isNewReading = !!+v[newReadingIdx];

        if (isLost) {
          additional += "†";
        }
        if (isNewReading) {
          additional += '$';
        }
        if (additional.length > 0)
          additional = ' ' + additional;
      }

      return {
          id: v[0].toString(),
          text: v[1] + additional,
          normalizedText: v[1].normalize('NFD').replace(/[\u0300-\u036f]/g, ""),
          icon: false,
          children: hasChildren,
          id_numeric: v[0],
      }
  });

  return dbJson;
}

function arraysEqual(a, b) {
  if (a === b) return true;
  if (a == null || b == null) return false;
  if (a.length != b.length) return false;

  for (var i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}

function onDisplayFormatClicked() {
  formatDialog.toggle();
  if (formatDialog.is(':visible')) {
    $('#btnDisplayFormat').html('Hide display format dialog');
  } else {
    $('#btnDisplayFormat').html('Show display format dialog');
  }

  var selectedValues = [];
  if (!formatDialog.is(':visible')) {
    $('#multiselect_to option').each(function() { selectedValues.push($(this).val()); });
    if (selectedValues === null || selectedValues.length == 0) {
      $('#alertObj').html('Nothing is selected on format dialog! Please select at least one field.');
      $('#alertObj').removeClass('hidden');
      $('#alertObj').addClass('show');
      return;
    }
  }

  if ($('#alertObj').hasClass('show')) {
    $('#alertObj').removeClass('show');
    $('#alertObj').addClass('hidden');
  }

  if (selectedValues.length > 0 && !(formatDialog.is(':visible'))) {
    const newShowHeaders = $('#chkDisplayHeaders').is(":checked");
    if (!arraysEqual(userSelectedDisplay, selectedValues) || newShowHeaders != lastShowHeaders) {
      userSelectedDisplay = selectedValues;
      displaySignatureInfo(false);
      lastShowHeaders = newShowHeaders;
    }
  }
}

function onShowMapClicked() {
  $('#mapDisplay').toggle();
  if ($('#mapDisplay').is(':visible')) {
    $('#btnShowMap').html('Hide map');
    $('#mainDisplay').removeClass('col-md-9');
    $('#mainDisplay').addClass('col-md-5');
  } else {
    $('#btnShowMap').html('Show map');
    $('#mainDisplay').removeClass('col-md-5');
    $('#mainDisplay').addClass('col-md-9');
  }
}

function selectizeFilter(fieldId) {
  var str = `SELECT DISTINCT ${fieldId} FROM all_data WHERE ${fieldId} NOT NULL AND ${fieldId} <> '' ORDER BY ${fieldId} COLLATE NOCASE;`;
  var contents = db.exec(str);
  var myOptions = contents[0].values.map(function (v) { return {text: v[0]} });

  return {
    id: fieldId,
    field: fieldId,
    label: humanNameForColumnName(fieldId),
    type: 'string',
    plugin: 'selectize',
    plugin_config: {
      valueField: 'text',
      labelField: 'text',
      searchField: 'text',
      sortField: 'text',
      maxItems: 1,
      plugins: ['restore_on_backspace'],
      valueSetter: function (rule, value) {
        rule.$el.find('.rule-value-container input')[0].selectize.setValue(value);
      },
      options: myOptions,
      create: true,
      createOnBlur: true,
      persist: true,
      dropdownDirection: 'up',
    }
  }
}

/* Dictionary with fields:
  .r => rule id, mandatory
  .l => label, mandatory
  .f => field id, optional. If not provided, .r is used.
  .v => default value, optional. If not provided, set to 0.
*/
function prepareBooleanRule(opt) {
  let fieldId = opt.f || opt.r;
  let defaultValue = opt.v || 0;

  return {
    id: opt.r,
    label: opt.l,
    type: 'boolean',
    field: fieldId,
    input: 'radio',
    values: [
      {0: 'No'},
      {1: 'Yes'}
    ],
    default_value: defaultValue,
    operators: ['equal'],
  };
}

function prepareAutoComplete(ruleId, opt) {
  if (!opt) opt = {};
  let fieldId = opt.fieldId || ruleId;
  let operators = opt.operators || ['equal', 'not_equal', 'begins_with',
        "not_begins_with", "contains", "not_contains", "ends_with",
        "not_ends_with", "is_empty", 'is_not_empty', "my_regex"];

  let contents = [];
  if (ruleId.indexOf('normalisation') != -1) {
    let str = `SELECT DISTINCT search_value FROM ${ruleId}`;
    contents = db.exec(str);
  } else if (ruleId.indexOf('runes_personalname') != -1) {
    let str = `SELECT DISTINCT value FROM ${ruleId}`;
    contents = db.exec(str);
  } else if (ruleId.indexOf('transliteration') != -1) {
    let str = 'SELECT DISTINCT search_value FROM transliterated_text';
    contents = db.exec(str);
  } else {
    let str = `SELECT DISTINCT ${fieldId} FROM all_data WHERE ${fieldId} NOT NULL AND ${fieldId} <> '' ORDER BY ${fieldId} COLLATE NOCASE;`;
    contents = db.exec(str);
  }

  return {
    id: ruleId,
    field: fieldId,
    label: humanNameForColumnName(fieldId),
    type: 'string',
    plugin: 'autoComplete',
    plugin_config: {
      minChars: 0,
      delay: 100,
      source: function (term, suggest) {
        var matches = [];
        for (i = 0; i < contents[0].values.length; i++) {
          if (contents[0].values[i][0].startsWith(term))
            matches.push(contents[0].values[i][0]);
        }
        suggest(matches);
      },
      menuClass: ' clusterize-content ',
      attachToParent: true,
    },
    size: 70,
    operators: operators,
  }
}

function resetSearchStats() {
  gWordIndices = {};
  gMatchedWordIndices = {};
  gFoundPersonalNames = 0;
  gWordVariants = 0;
}

// Applies user-defined filters in order to obtain valid IDs
// Returns true on success, false on any failure.
//
function applyFilters() {
  var result = $('#builder').queryBuilder('getSQL', false);
  if (!result || !result.sql.length) {
    return false;
  }

  resetSearchStats();

  console.log('Got SQL: ' + result.sql);
  var contents = db.exec("SELECT signature_id, signature_text, lost, new_reading, normalisation_scandinavian FROM all_data WHERE " + result.sql);
  if (contents.length == 0) {
    // no results
    rootsJson = [];
    sumRootChildren = 0;
    return true;
  }

  let signatureIdIdx = contents[0].columns.indexOf('signature_id');
  let normalisationScandinavianIdx = contents[0].columns.indexOf('normalisation_scandinavian');

  if (Object.keys(gWordIndices).length != 0) {
    contents[0].values = contents[0].values.filter(function checkIds(row) {
      id = row[signatureIdIdx];
      normalizedText = row[normalisationScandinavianIdx];

      if (!gWordIndices.hasOwnProperty(id))
        return true;

      let allKeys = Object.keys(gWordIndices[id]);
      let intersection = new Set(gWordIndices[id][allKeys[0]]);
      for (i = 1; i < allKeys.length; i++) {
        if (allKeys[i].indexOf('_par') != -1) {
          continue;
        }
        let b = new Set(gWordIndices[id][allKeys[i]]);
        intersection = new Set([...intersection].filter(x => b.has(x)));
        if (intersection.size == 0) {
          return false;
        }
      }

      let words = getWordBoundaries(normalizedText, gWordSearchRegex, gWordPunctuationRegex);
      let wordVariants = [];
      var counts = {};
      var countsPersonal = {};
      intersection.forEach(function (val) {
        // We do not need to count words that have isVariant > 0.
        // Do not count corresponding personal names
        gFoundPersonalNames += words[val].isPersonal;
        if (words[val].isVariant > 0) {
          let key = words[val].isVariant;
          counts[key] = (counts[key] || 0) + 1;
          if (words[val].isPersonal) {
            countsPersonal[key] = (countsPersonal[key] || 0) + 1;
          } else {
            countsPersonal[key] = (countsPersonal[key] || 0);
          }
        }
      });

      let countValues = [...Object.values(counts)];
      var personalBias = 0;
      if (countValues.length > 0) {
        let minCounts = Math.min(...countValues);
        let minIndex = countValues.indexOf(minCounts) + 1;

        if (!isNaN(minCounts))
          gWordVariants += minCounts * (countValues.length-1);
        if (!isNaN(countsPersonal[minIndex]))
          personalBias += countsPersonal[minIndex] * (countValues.length-1);
      }
      gFoundPersonalNames -= personalBias;

      gMatchedWordIndices[id] = intersection;
      return true;
    });
  }

  // hash map of inscription IDs that have children.
  var rootsWithChildren = db.exec("SELECT * FROM signatures_with_children");
  // make a hash map for quick read access
  rootsWithChildren = new Map(rootsWithChildren[0].values.map((v, i) => [v[0], 1]));

  rootsJson = dbToJson(contents[0].columns, contents[0].values, rootsWithChildren);

  //contents = db.exec("SELECT COUNT(id) FROM signatures WHERE parent_id IN (SELECT signatureId FROM all_data WHERE " + result.sql + ")");
  //sumRootChildren = contents[0].values[0][0];
  sumRootChildren = 0;
  return true;
}


function range(size, startAt = 0) {
    return [...Array(size).keys()].map(i => i + startAt);
}

// extract starting indices of words from str
// Can be applied for string where words are separated by a single whitespace
function getWordStarts(str, regexStr) {
  if (regexStr === undefined) {
    regexStr = '\\s';
  }
  let r = new RegExp(regexStr, 'g');
  var matches = [-1];
  while ((arr = r.exec(str)) !== null) {
    matches.push(arr.index);
  }
  matches.push(str.length);

  return matches;
}

// Extracts word boundaries from inscription texts. These texts
// have multiple separators (whitespaces, punctuation) that often
// go together, i.e. space,punctuation,space
// returns array of objects. Each object:
// {start: num, end: num, text: string, isPersonal: 0 or 1, isVariant: [0...N] }
// isVariant - if word is located within a paragrapgh (i.e. §P) isVariant
// contains a numerical difference between paragraph character and 'P'. For §P
// isVariant is 1, for §Q isVariant is 1.
// str - search string
// reg - regex used to detect word boundaries
// purePunctuation - regex used to check if detected word is pure punctuational
function getWordBoundaries(str, reg, purePunctuation) {
  var words = [];
  var wordBegin = 0;
  //var purePunctuation = new RegExp("(·|:|×|¤|'|\\+|÷|¶|\\(|\\))+");
  var strReversed = str.split("").reverse().join("");
  let pCode = 'P'.charCodeAt();

  while ((arr = reg.exec(str)) !== null) {
    if (wordBegin == arr.index) {
      wordBegin += arr[0].length;
      continue;
    }
    let oneWord = {start: wordBegin, end: arr.index, isPersonal: 0, isVariant: 0};
    let wordText = str.slice(oneWord.start, oneWord.end);
    oneWord.text = wordText;
    // skip double sides character
    if (arr[0] == '¶¶')
      continue;

    punctuationCheck = purePunctuation.exec(oneWord.text);
    if (punctuationCheck !== null && punctuationCheck[0].length == oneWord.text.length)
    {
      wordBegin = arr.index + arr[0].length;
      continue;
    }

    if (wordText.startsWith('"') || wordText.startsWith("&quot;"))
      oneWord.isPersonal = 1;
    let reverseStart = str.length-1 - wordBegin;
    if ((parPos = strReversed.indexOf('§', reverseStart)) != -1) {
      if (strReversed[parPos-1].charCodeAt() - pCode >= 0) {
        oneWord.isVariant = strReversed[parPos-1].charCodeAt() - pCode + 1;
      }
    }

    words.push(oneWord);
    wordBegin = arr.index + arr[0].length;
  }
  if (wordBegin == 0) {
    if (str.length > 0) {
      let oneWord = {start: 0, end: str.length, text: str, isPersonal: 0, isVariant: 0};
      if (oneWord.text.startsWith('"') || oneWord.text.startsWith("&quot;"))
        oneWord.isPersonal = 1;

      let reverseStart = str.length-1;
      if ((parPos = strReversed.indexOf('§', reverseStart)) != -1) {
        if (strReversed[parPos-1].charCodeAt() - pCode >= 0) {
          oneWord.isVariant = strReversed[parPos-1].charCodeAt() - pCode + 1;
        }
      }

      punctuationCheck = purePunctuation.exec(oneWord.text);
      if (punctuationCheck === null || punctuationCheck[0].length != oneWord.text.length)
        words.push(oneWord);
    }
  } else {
    // let's add the final word
    if (wordBegin != str.length) {
      let oneWord = {start: wordBegin, end: str.length, isPersonal: 0, isVariant: 0};
      oneWord.text = str.slice(oneWord.start, oneWord.end);
      if (oneWord.text.startsWith('"') || oneWord.text.startsWith("&quot;"))
        oneWord.isPersonal = 1;

      let reverseStart = str.length-1 - wordBegin;
      if ((parPos = strReversed.indexOf('§', reverseStart)) != -1) {
        if (strReversed[parPos-1].charCodeAt() - pCode >= 0) {
          oneWord.isVariant = strReversed[parPos-1].charCodeAt() - pCode + 1;
        }
      }

      punctuationCheck = purePunctuation.exec(oneWord.text);
      if (punctuationCheck === null || punctuationCheck[0].length != oneWord.text.length)
        words.push(oneWord);
    }
  }
  return words;
}

// return words by index. Words are separated by a single space
function wordsByIndex(str, indices) {
  let allWords = str.split(' ');
  let words = [];
  indices.forEach(item => words.push(allWords[item]));
  return words;
}

function wordByCharPos(wordStarts, charPos) {
  for (i = 0; i < wordStarts.length - 1; i++) {
    if (charPos > wordStarts[i] && charPos < wordStarts[i+1]) {
      return i;
    }
  }
  return -1;
}

function onDbLoaded(e) {
  if (!this.response) {
    return;
  }

  var uInt8Array = new Uint8Array(this.response);
  db = new SQL.Database(uInt8Array);

  db.create_function('regexp', function (regexValue, fieldData) {
    if (!gRegExpMap.hasOwnProperty(regexValue)) {
      gRegExpMap[regexValue] = new RegExp(regexValue);
      gRegExpMapG[regexValue] = new RegExp(regexValue, 'g');
    }
    let res = -1;
    if (gRegExpMap[regexValue].test(fieldData))
      res = 1;

    return res;
  });

  db.create_function('wordRegexp', function (regexValue, fieldData, id, fieldName) {
    if (!gRegExpMap.hasOwnProperty(regexValue)) {
      gRegExpMap[regexValue] = new RegExp(regexValue);
      gRegExpMapG[regexValue] = new RegExp(regexValue, 'g');
    }

    // Test method doesn't really work with global regexps. At least
    // when regex is stored in a global variable, i.e. preserves state
    // between function calls
    if (gRegExpMap[regexValue].test(fieldData) == true) {
      // Use gRegExpMapG from now on. This is important!

      wordStarts = getWordStarts(fieldData);

      var matchIndices = [];
      while ((array1 = gRegExpMapG[regexValue].exec(fieldData)) !== null) {
        minWordIdx = wordByCharPos(wordStarts, array1.index);
        maxWordIdx = wordByCharPos(wordStarts, array1.index+array1[0].length-1);

        let wordIndices = range(maxWordIdx-minWordIdx+1, minWordIdx); // range of word indices
        if (!gWordIndices.hasOwnProperty(id)) {
          gWordIndices[id] = {};
        }
        if (!gWordIndices[id].hasOwnProperty(fieldName)) {
          gWordIndices[id][fieldName] = [];
        }
        gWordIndices[id][fieldName].push(...wordIndices);
      }
      return 1;
    }

    //console.log(`${regexValue}; ${fieldData}; ${id};`);
    return -1;
  });

  // get all root signatures (that are not aliases)
  var contents = db.exec("SELECT signature_id, signature_text, lost, new_reading FROM all_data");
  var rootsWithChildren = db.exec("SELECT * FROM signatures_with_children");
  // make a hash map for quick read access
  rootsWithChildren = new Map(rootsWithChildren[0].values.map((v, i) => [v[0], 1]));

  rootIds = new Map(contents[0].values.map((v, i) => [v[0], 1]));
  rootsJson = dbToJson(contents[0].columns, contents[0].values, rootsWithChildren);
  //sumRootChildren = db.exec("SELECT COUNT(id) FROM signatures WHERE parent_id IS NOT NULL");
  //sumRootChildren = sumRootChildren[0].values[0][0];
  sumRootChildren = 0;

  originalData = rootsJson;
  origianlSumRootChildren = sumRootChildren

  contents = db.exec("SELECT signature_text FROM signatures");
  signatureNames = contents[0].values.map((v, i) => v[0]);

  contents = db.exec("SELECT id, signature_text FROM signatures");
  signaturesSelectize = dbToJson(contents[0].columns, contents[0].values);

  $('#jstree').jstree(true).refresh();

  contents = db.exec('SELECT meta_id, count(1) AS num FROM crosses GROUP BY meta_id ORDER BY num DESC LIMIT 1');
  var maxCrosses = contents[0].values[0][1];

  contents = db.exec('SELECT DISTINCT id, name from cross_forms ORDER BY name COLLATE NOCASE');
  var allCrossForms = contents[0].values.map((v, i) => ['<option value="'+v[0]+'">'+v[1]+'</option>']);

  contents = db.exec('SELECT DISTINCT id, name from material_types ORDER BY name COLLATE NOCASE');
  var allMaterialTypes = (contents[0].values);
  let materialTypeFilter = {
    id: 'material_type',
    field: 'materialType_id',
    label: 'Material type',
    type: 'string',
    plugin: 'autoComplete',
    plugin_config: {
      minChars: 0,
      delay: 100,
      source: function (term, suggest) {
        var matches = [];
        for (i = 0; i < allMaterialTypes.length; i++) {
          if (allMaterialTypes[i][1].startsWith(term))
            matches.push(allMaterialTypes[i][1]);
        }
        suggest(matches);
      }
    },
    operators: ['equal', 'not_equal', 'begins_with', 'not_begins_with', 'contains', 'not_contains',
      'ends_with', 'not_ends_with', 'is_empty', 'is_not_empty'],
  };

  /////////////////////////////////////
  // Initialzie QueryBuilder
  //////////////////////////////////////
  var glob_operators = ['equal', 'not_equal', 'begins_with_glob', "not_begins_with_glob", "contains_glob",
   "not_contains_glob", "ends_with", "not_ends_with", "is_empty", 'is_not_empty', "my_regex", "word_regexp"];
  var queryBuilderFilters = [
    {
      id: 'signature_text',
      field: 'signature_text',
      label: humanNameForColumnName('signature_text'),
      type: 'string',
      plugin: 'autoComplete',
      plugin_config: {
        minChars: 0,
        delay: 50,
        source: function(term, suggest) {
          var matches = [];
          for (i = 0; i < signaturesSelectize.length; i++) {
            if (signaturesSelectize[i].text.startsWith(term)) {
              matches.push(signaturesSelectize[i].text);
              continue;
            }
            // do not do the search if we got a match already
            if (signaturesSelectize[i].normalizedText.startsWith(term)) {
              matches.push(signaturesSelectize[i].text);
              continue;
            }
          }
          suggest(matches);
        },
        menuClass: 'clusterize-content ',
      },
      size: 40,
      operators: ['equal', 'not_equal', 'begins_with', "not_begins_with", "contains", "not_contains",
        "ends_with", "not_ends_with", "my_regex"],
    },
    {
      id: 'signature_country',
      field: 'signature_text',
      label: 'Country',
      type: 'string',
      input: 'select',
      multiple: true,
      operators: ['in'],
      plugin: 'selectize',
      plugin_config: {
        plugins: ['remove_button'],
        valueSetter: function (rule, value) {
          rule.$el.find('.rule-value-container input')[0].selectize.setValue(value);
        },
        options: [{text: 'Öland (Öl)', v: 'Öl '}, {text: 'Östergötland (Ög)', v: 'Ög '}, {text: 'Södermanland (Sö)', v: 'Sö '},
          {text: 'Småland (Sm)', v: 'Sm '}, {text: 'Västergötland (Vg)', v: 'Vg '}, {text: 'Uppand (U)', v: 'U '},
          {text: 'Västmanland (Vs)', v: 'Vs '}, {text: 'Närke (Nä)', v: 'Nä '}, {text: 'Värmland (Vr)', v: 'Vr '},
          {text: 'Gästrikland (Gs)', v: 'Gs '}, {text: 'Hälsingland (Hs)', v: 'Hs '}, {text: 'Medelpad (M)', v: 'M '},
          {text: 'Ångermanland (Ån)', v: 'Ån '}, {text: 'Dalarna (D)', v: 'D '}, {text: 'Härjedalen (Hr)', v: 'Hr '},
          {text: 'Jämtland (J)', v: 'J '}, {text: 'Lappland (Lp)', v: 'Lp '}, {text: 'Dalsland (Ds)', v: 'Ds '},
          {text: 'Bohuslän (Bo)', v: 'Bo '}, {text: 'Gotland (G)', v: 'G '}, {text: 'Sweden other (SE)', v: 'SE '},
          {text: 'Denmark (DR)', v: 'DR '}, {text: 'Norway (N)', v: 'N '}, {text: 'Faroe Islands (FR)', v: 'FR '},
          {text: 'Greenland (GR)', v: 'GR '}, {text: 'Iceland (IS)', v: 'IS '}, {text: 'Finland (FI)', v: 'FI '},
          {text: 'Shetland (Sh)', v: 'Sh '}, {text: 'Orkney (Or)', v: 'Or '}, {text: 'Scotland (Sc)', v: 'Sc '},
          {text: 'England (E)', v: 'E '}, {text: 'Isle of Man (IM)', v: 'IM '}, {text: 'Ireland (IR)', v: 'IR '},
          {text: 'France (F)', v: 'F '}, {text: 'Netherlands (NL)', v: 'NL '}, {text: 'Germany (DE)', v: 'DE '},
          {text: 'Poland (PL)', v: 'PL '}, {text: 'Latvia (LV)', v: 'LV '}, {text: 'Russia (RU)', v: 'RU '},
          {text: 'Ukraine (UA)', v: 'UA '}, {text: 'Byzantium (By)', v: 'By '}, {text: 'Italy (IT)', v: 'IT '},
          {text: 'Other areas (X)', v: 'X '}],
        valueField: 'v',
        labelField: 'text',
        searchField: 'text',
        sortField: 'text',
        create: false,
        dropdownDirection: 'up',
        maxItems: null,
      },
    },
    prepareAutoComplete('found_location'),
    prepareAutoComplete('parish'),
    prepareAutoComplete('district'),
    prepareAutoComplete('municipality'),
    prepareAutoComplete('current_location'),
    prepareAutoComplete('original_site'),
    prepareAutoComplete('rune_type'),
    prepareAutoComplete('dating'),
    prepareAutoComplete('carver'),
    prepareAutoComplete('material'),
    prepareAutoComplete('normalisation_norse', {fieldId: 'normalisation_search_norse', operators: glob_operators}),
    prepareAutoComplete('normalisation_scandinavian', {fieldId: 'normalisation_search_scandinavian', operators: glob_operators}),
    prepareAutoComplete('english_translation'),
    prepareAutoComplete('transliteration', {fieldId: 'search_transliteration', operators: glob_operators}),
    prepareAutoComplete('style'),
    prepareAutoComplete('reference'),
    prepareAutoComplete('additional'),
    prepareAutoComplete('objectInfo'),
    prepareAutoComplete('runes_personalname'),
    prepareBooleanRule({'r':'has_personal_name', 'l':'Has personal name?', 'f':'num_names', 'v':1}),
    {
      id: 'alternatives',
      label: 'Has alternative(s)?',
      type: 'integer',
      input: 'radio',
      field: 'signature_id',
      values: [
          {1: 'Yes'},
          {0: 'No'}
      ],
      default_value: 1,
      operators: ['alternatives_in'],
    },
    prepareBooleanRule({'r':'lost', 'l':'Is lost?'}),
    prepareBooleanRule({'r':'new_reading', 'l':'New reading?'}),
    {
      id: 'num_crosses',
      label: 'Number of crosses',
      type: 'integer',
      input: 'number',
      validation: {
        min: 0,
        max: maxCrosses,
        step: 1,
        allow_empty_value: false,
      },
      default_value: 0,
      operators: ['equal', 'not_equal', 'less', 'less_or_equal', 'greater', 'greater_or_equal',
        'between', 'not_between'],
      size: 10,
    },
    {
      id: 'cross_form',
      label: 'Cross form',
      type: 'string',
      operators: ['cross_form'],
      input: function (rule, name) {
        //let $container = rule.$el.find('.rule-value-container');
        return '\
          <select name="'+name+'_1">\
          ' + allCrossForms +
          '</select>\
          <div>Certain?\
            <label><input type="radio" name="'+name+'_2" value="0">No</label>\
            <label><input type="radio" name="'+name+'_2" value="1" checked>Yes</label>\
          </div>';
      },
      valueGetter: function (rule) {
        let val1 = rule.$el.find('.rule-value-container [name$=_1]').val();
        let val2 = rule.$el.find('.rule-value-container [name$=_2]:checked').val();
        return {form: val1, is_certain: val2};
      }
    },
    materialTypeFilter,
    prepareBooleanRule({'r':'ornamental', 'l':'Is pure ornamental?', 'v': 1}),
  ];

  // Fix for Selectize
  $('#builder').on('afterCreateRuleInput.queryBuilder', function(e, rule) {
    if (rule.filter.plugin == 'selectize') {
      rule.$el.find('.rule-value-container').css('min-width', '200px')
        .find('.selectize-control').removeClass('form-control');
    }
  });

  $('#builder').queryBuilder({
    operators: $.fn.queryBuilder.constructor.DEFAULTS.operators.concat([
      { type: 'alternatives_in',  nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'cross_form', nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'begins_with_glob',      nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'not_begins_with_glob',  nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'contains_glob',  nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'not_contains_glob',  nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'my_regex', nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'word_regexp', nb_inputs: 1, multiple: false, apply_to: ['string'] },
    ]),

    lang: {
      operators: {
        alternatives_in: ' ',
        cross_form: ' ',
        begins_with_glob: "begins with",
        not_begins_with_glob: "doesn't begin with",
        contains_glob: "contains",
        not_contains_glob: "doesn't contain",
        my_regex: 'matches expression',
        word_regexp: 'matches across words',
      }
    },

    // SQL export (first half)
    sqlOperators: {
      alternatives_in: { op: 'IN' },
      cross_form: { op: 'IN' },
      //like_glob: {op: 'GLOB'},
      begins_with_glob: {op: 'GLOB ?', mod: '{0}*'},
      not_begins_with_glob: {op: 'NOT GLOB ?', mod: '{0}*'},
      contains_glob: { op: 'GLOB ?', mod: '*{0}*'},
      not_contains_glob: { op: 'NOT GLOB ?', mod: '*{0}*'},
      my_regex: { op: 'REGEXP ?', mod: '{0}'},
      word_regexp: { op: 'wordRegexp(?)', mod: '{0}'},
    },
    plugins: {
      'bt-tooltip-errors': null,
      'sortable': null,
      'not-group': null,
      'bt-selectpicker': {liveSearch: true, liveSearchStyle: 'startsWith'},
    },

    filters: queryBuilderFilters,
    sort_filters: true,
  })
  .on('rulesChanged.queryBuilder', function () {
      if ($('#chkApplyFilters').is(":checked")) {
          if (applyFilters())
            applyPagination();
      }
  })
  // SQL export (second half)
  .on('ruleToSQL.queryBuilder.filter', function (e, rule, sqlValue, sqlOperator) {
    if (rule.operator === 'alternatives_in') {
      if (rule.value == 1) {
        e.value = rule.field + ' ' + sqlOperator() + ' signatures_with_children';
      } else {
        e.value = rule.field + ' IN root_signatures and ' + rule.field +
          ' NOT ' + sqlOperator() + ' signatures_with_children';
      }
    }
    if (rule.operator === 'cross_form') {
      e.value = 'id IN (SELECT meta_id FROM crosses WHERE crosses.id in (SELECT cross_id FROM cross_definitions WHERE form_id="' + rule.value[0].form + '" AND is_certain="' + rule.value[0].is_certain + '"))';
    }
    if (rule.id === 'material_type') {
      e.value = rule.field + ' IN (SELECT id FROM material_types WHERE name ' + sqlOperator(sqlValue) + ')';
    }
    if (rule.id === 'signature_country') {
      e.value = "(" + rule.value.map(function (v, i) { return rule.field + " LIKE ('"+v+"%')"; }).join(' OR ') + ")";
    }
    if (rule.id === 'has_personal_name') {
      if (rule.value == 1) {
        e.value = rule.field + '> 0';
      } else {
        e.value = rule.field + '= 0';
      }
    }
    if (rule.id === 'signature_text') {
      e.value = 'signature_id IN (SELECT id FROM signatures WHERE ' + rule.field + ' ' + sqlOperator(sqlValue) + ' OR id IN (SELECT parent_id FROM signatures WHERE '
      + rule.field + ' ' + sqlOperator(sqlValue) + '))';
    }
    if (sqlOperator().indexOf('REGEXP') != -1) {
      // Let's convert it to a function call. A better approach might exist,
      // see ruleExpression in query-builder.standalone.js
      e.value = `regexp(${sqlValue}, ${rule.field}) == 1`;
    }
    if (sqlOperator().indexOf('wordRegexp') != -1) {
      e.value = `wordRegexp(${sqlValue}, ${rule.field}, id, '${rule.field}') == 1`;
    }
  })
  ;

  // if (!window.Selectize.prototype.positionDropdownOriginal) {
  //   window.Selectize.prototype.positionDropdownOriginal = window.Selectize.prototype.positionDropdown;
  //   window.Selectize.prototype.positionDropdown = function () {
  //     this.settings.dropdownDirection = 'up';
  //     if (this.settings.dropdownDirection === 'up') {
  //       let $control = this.$control;
  //       let offset = this.settings.dropdownParent === 'body' ? $control.offset() : $control.position();

  //       this.$dropdown.css({
  //         width: $control.outerWidth(),
  //         top: offset.top - this.$dropdown.outerHeight(),
  //         left: offset.left
  //       });
  //       this.$dropdown.addClass('direction-' + this.settings.dropdownDirection);
  //       this.$control.addClass('direction-' + this.settings.dropdownDirection);
  //       this.$wrapper.addClass('direction-' + this.settings.dropdownDirection);
  //     } else {
  //       window.Selectize.prototype.positionDropdownOriginal.apply(this, arguments);
  //     }
  //   };
  // }

  // button handlers
  $('#btnDisplayFormat').on('click', onDisplayFormatClicked);
  $('#btnShowMap').on('click', onShowMapClicked);

  $('#chkApplyFilters').on('change', function() {
    if (this.checked) {
      if (applyFilters())
        applyPagination();
    } else {
      rootsJson = originalData;
      sumRootChildren = origianlSumRootChildren;
      resetSearchStats();
      applyPagination();
    }
  });
}

// Data provided for jsTree.
function fetchTreeData(obj, cb) {
  if (obj.id === '#') {
    if (db === null) {
        // we need to load the database first
        return;
    }

    cb.call(this, rootsJson);
  }/* else {
    var contents = db.exec("SELECT * FROM signatures where parent_id = '" + obj.id + "'");
    var children = dbToJson(contents[0].columns, contents[0].values);
    cb.call(this, children);
  }*/
}

function displaySignatureInfo(makeMarkers) {
  if (makeMarkers === undefined) {
    makeMarkers = true;
  }

  $('#mainDisplay').empty();
  if (makeMarkers) {
    for (let key in mapMarkers) {
      if (mapMarkers.hasOwnProperty(key)) {
        mapMarkers[key].remove();
      }
    }
    markers.clearLayers();
  }

  let indices = $('#jstree').jstree(true).get_selected();
  if (indices.length == 0)
    return;

  let finalText = '';
  let customColumns = ['transliteration', 'english_translation', 'normalisation_scandinavian', 'normalisation_norse'];

  const paragraphSymbol = '§';
  const sidesMarker = '§A';
  const readingMarker = '§P';
  let staticBase = "{% static 'runes/images/cross_forms/' %}";
  const showHeaders = $('#chkDisplayHeaders').is(":checked");

  let markersLatLon = [];

  let indicesStr = indices.join(',');
  let contents = db.exec("SELECT * FROM all_data where signature_id IN (" + indicesStr + ")");
  if (!contents || contents.length == 0)
    return;

  // Map of aliases. Key is parent ID, value - list of alias names
  let aliasByParent = {};
  let aliasContents = db.exec('SELECT id, signature_text, parent_id FROM signatures WHERE parent_id IN (' + indicesStr + ')');
  if (aliasContents && aliasContents.length > 0) {
    aliasContents[0].values.map(function (v, i) {
      if (!(v[2] in aliasByParent)) {
        aliasByParent[v[2]] = [];
      }
      curValue = aliasByParent[v[2]];
      curValue.push(v[1]);
      aliasByParent[v[2]] = curValue;
    });
  }

  let latIdx = contents[0].columns.indexOf('latitude');
  let lonIdx = contents[0].columns.indexOf('longitude');
  let signNameIdx = 0;
  let metaIdIdx = contents[0].columns.indexOf('id');
  let mainDisplayDom = document.getElementById('mainDisplay');

  let renderParams = {
    latIdx: latIdx,
    lonIdx: lonIdx,
    metaIdIdx: metaIdIdx,
    userSelectedDisplay: userSelectedDisplay,
    showHeaders: showHeaders,
    mainDisplay: mainDisplayDom,
    allRows: contents[0].values,
    curRowIdx: 0,
    columns: contents[0].columns,
    aliasByParent: aliasByParent,
    signNameIdx: signNameIdx,
  };

  numSelectedSignatures = indices.length;

  if ($('#mapDisplay').is(':visible') && makeMarkers) {
    for (let i = 0; i < indices.length; i++) {
      let row = indices[i];
      let signatureName = contents[0].values[i][signNameIdx];

      // handle map marker only if map is visible
      let marker = '';
      if (row in mapMarkers) {
        marker = mapMarkers[row];
      } else {
        let lat = parseFloat(contents[0].values[i][latIdx]);
        let lon = parseFloat(contents[0].values[i][lonIdx]);
        if ((!isNaN(lat) && !isNaN(lon)) && (lat != 0 && lon != 0)) {
          marker = new MarkerWithData([lat, lon], {inscription: signatureName});
          let popupText = "<b>" + signatureName + "</b>";
          marker.bindPopup(popupText);
          mapMarkers[row] = marker;
        }
      }
      if (marker instanceof Object) {
        markers.addLayer(marker);
        markersLatLon.push(marker.getLatLng());
      }
    }

    if (markersLatLon.length > 0) {
      let markersBounds = L.latLngBounds(markersLatLon);
      myMap.fitBounds(markersBounds);
    }
  }

  renderIsDone = true;
  renderParams.mainDisplay.innerHTML += "<img src='{% static 'runes/jstree/themes/default/throbber.gif' %}'><br>";
  setTimeout(signatureRenderHelper, 10, renderParams);
}

function signatureRenderHelper(renderParams) {
  if (numSelectedSignatures == 0) {
    return;
  }

  if (renderParams.curRowIdx < numSelectedSignatures) {
    if (!renderIsDone) {
      setTimeout(signatureRenderHelper, 50, renderParams);
      return;
    }

    setTimeout(renderSignature, 20, renderParams);
  } else {
    let idx = renderParams.mainDisplay.innerHTML.indexOf('<article');
    if (idx != -1) {
      renderParams.mainDisplay.innerHTML = renderParams.mainDisplay.innerHTML.slice(idx);
    }
  }
}

// Depends on global variables: db
function renderSignature(renderParams) {
  renderIsDone = false;

  let curRow = renderParams.allRows[renderParams.curRowIdx];
  let userSelectedDisplay = renderParams.userSelectedDisplay;
  let showHeaders = renderParams.showHeaders;
  let metaIdIdx = renderParams.metaIdIdx;
  let columns = renderParams.columns;
  let aliasByParent = renderParams.aliasByParent;
  let signatureName = curRow[renderParams.signNameIdx];

  let highlightColumns = ['transliteration', 'normalisation_scandinavian', 'normalisation_norse'];
  let customColumns = new Array(...highlightColumns);
  customColumns.push('english_translation');
  const paragraphSymbol = '§';
  const sidesMarker = '§A';
  const readingMarker = '§P';
  let staticBase = "{% static 'runes/images/cross_forms/' %}";
  let signIdIdx = columns.indexOf('signature_id');
  let signatureId = curRow[signIdIdx];

  let paragraph = `<article signature="${signatureName}" id="${signatureName}" class="inscription-section">`;

  for (let j = 0; j < userSelectedDisplay.length; j++) {
    let columnName = userSelectedDisplay[j];
    let humanName = humanNameForColumnName(columnName);
    let columnIdx = columns.indexOf(columnName);
    let columnData = curRow[columnIdx];

    if (showHeaders) {
      paragraph += '<h4>' + humanName + '</h4>';
    } else if (paragraph.length > 0 && columnData !== '') {
      paragraph += '<br>';
    }

    columnData = escapeHtml(columnData);

    if (userSelectedDisplay[j] == 'images') {
      let directImages = db.exec("SELECT id, link_url, direct_url FROM runes_imagelink WHERE meta_id = '" + curRow[metaIdIdx] + "' AND direct_url <> '' LIMIT 9");
      let dbImages = [];
      if (directImages.length > 0) {
        let ids = directImages[0].values.map(function (v, i) { return v[0]; });
        ids = ids.join(',');
        dbImages = db.exec("SELECT link_url, direct_url FROM runes_imagelink WHERE meta_id = '" + curRow[metaIdIdx] + "' AND id NOT IN (" + ids + ")");
      } else {
        dbImages = db.exec("SELECT link_url, direct_url FROM runes_imagelink WHERE meta_id = '" + curRow[metaIdIdx] + "'");
      }
      let indirectImages = 'No images.';
      if (dbImages.length > 0) {
        indirectImages = '<ul>';
        dbImages[0].values.map(function (v, i) {
          indirectImages += `<li><a href="${v[0]}" contentEditable="false" target="_blank">${v[0]}</a></li>`;
        });
        indirectImages += '</ul>';
      }

      if (directImages.length == 0) {
        paragraph += indirectImages;
        continue;
      }

      paragraph += '<div class="container-fluid"><div class="row">';
      directImages[0].values.map(function (v, i) {
        if (i % 3 == 0) {
          paragraph += "</div>";
          if (i < 9)
            paragraph += '<div class="row">';
        }
        paragraph += `<div class="col-md-4"><a href="${v[1]}" contentEditable="false" target="_blank"><img src="${v[2]}" class="img-responsive"></a></div>`;
      });
      paragraph += '</div></div>';

      if (indirectImages !== 'No images.') {
        paragraph += '<br>' + indirectImages;
      }

      continue;
    }

    if (jQuery.inArray(userSelectedDisplay[j], customColumns) != -1) {
      let cssStyle = 'normalization';
      if (~userSelectedDisplay[j].indexOf('transliteration')) {
        cssStyle = 'transliteration';
      } else if (~userSelectedDisplay[j].indexOf('english_translation')) {
        cssStyle = '';
      }

      if (userSelectedDisplay[j].indexOf('english_translation') == -1
        && gMatchedWordIndices.hasOwnProperty(signatureId)) {
        // this is one of columns that should have highlighted data
        // from set with word indices to array
        columnData = columnData.trim();
        let matchedWords = [...gMatchedWordIndices[signatureId]];
        // sort in descending order
        matchedWords = matchedWords.sort(function (a, b) { return b - a; } );
        if (columnName.indexOf('transliteration') != -1) {
          // double space have special meaning => it's designates a word that is not
          // present in transliterated text, but is present in other texts. Very important!
          columnData = columnData.replace(/\s{2}/g, ' &nbsp; ');
        }
        let words = getWordBoundaries(columnData, gWordSearchRegexEsc, gWordPunctuationRegexEsc);
        var highlightedStr = columnData;
        for (let k = 0; k < matchedWords.length; k++) {
          let idx = matchedWords[k];
          let wordStart = words[idx].start;
          let wordEnd = words[idx].end;

          if (words[idx].text[0] == '§') {
            // this is a paragraph, do nothing
            continue;
          }

          highlightedStr = columnData.slice(0, wordStart)
            + '<span class="highlighted">'
            + words[idx].text
            + '</span>'
            + highlightedStr.slice(wordEnd);
        }
        columnData = highlightedStr;
      }
      // Smiley is a special symbol: word substitute when word is not present
      // We do not need to show it.
      columnData = columnData.replace(/ ☺ /g, ' ');

      if (~columnData.indexOf(paragraphSymbol)) {
        let parts = columnData.split(paragraphSymbol);
        let listHeader = '';
        listHeader = "Sides or/and reading variants:"

        paragraph += listHeader;
        paragraph += '<ul>';
        for (let k = 0; k < parts.length; k++) {
          let part = parts[k];

          if (!part.trim())
            continue;

          part = paragraphSymbol + part;
          paragraph += '<li><span class="' + cssStyle + '">' + part + '</span></li>';
        }
        paragraph += '</ul>';
      } else {
        // no parts in the columnData
        paragraph += '<span class="' + cssStyle + '">' + columnData + '</span>';
      }
      continue;
    }

    if (userSelectedDisplay[j] === 'crosses') {
      let numCrossesColumnIdx = columns.indexOf('num_crosses');
      let numCrosses = curRow[numCrossesColumnIdx];
      if (!numCrosses || numCrosses == 0) {
        paragraph += 'No crosses';
        continue;
      }

      paragraph += '<table class="crosses" border="1">';
      paragraph += '<thead><tr>';
      paragraph += '<th>A</th>';
      paragraph += '<th>B</th>';
      paragraph += '<th>C</th>';
      paragraph += '<th>D</th>';
      paragraph += '<th>E</th>';
      paragraph += '<th>F</th>';
      paragraph += '<th>G</th>';
      paragraph += '</th></thead>';
      paragraph += '<tbody>';

      let allCrosses = crossesForMeta(curRow[metaIdIdx]);
      for (let k = 0; k < allCrosses.length; k++) {
        if (allCrosses[k][0].length > 0) {
          // this is a cross from undefined group
          paragraph += '<tr><td colspan="7">' + allCrosses[k][0][0].name + '</td></tr>';
          continue;
        }
        paragraph += '<tr>';
        // we have 8 groups in total, 0 being free-text and not a real group
        for (let gr = 1; gr < 8; gr++) {
          let crossForms = allCrosses[k][gr];
          if (crossForms.length == 0) {
            paragraph += '<td><span class="null">&#8709;</span></td>';
            continue;
          }
          paragraph += '<td>';
          paragraph += allCrosses[k][gr].map(function (v, i) {
            let url = staticBase + v.name + '.png';
            let res = '<img src="' + url + '" alt="'+v.name+'" title="'+v.name+'" width="32" height="32">';
            if (v.isCerain == 0) {
              res += '?';
            }
            return res;
          }).join(', ');
          paragraph += '</td>';
        }
      }
      paragraph += '</tbody></table>';
      continue;
    }

    if (userSelectedDisplay[j] === 'signature_text') {
      if (signatureId in aliasByParent) {
        columnData += ' (' + aliasByParent[signatureId].join('|') + ')';
      }
    }

    if (columnData == '' && showHeaders) {
      columnData = '<i>Absent</i>';
    }
    paragraph += columnData;
  }
  paragraph += '</article>';

  renderParams.mainDisplay.innerHTML += paragraph;

  // prepare for the next run
  renderParams.curRowIdx += 1;
  renderIsDone = true;
  setTimeout(signatureRenderHelper, 10, renderParams);
}

/* Find all crosses related to particular metaId.
 * Returned variable is a multidimensional array. Dimensions:
 * 1. First dimension contains individual crosses.
 * 2. Second dimension denotes cross form group. There could only be 8 groups.
 * 3. Third dimension contains objects with 2 data fields (name, isCertain). Each object represents a particular cross form in a group.
 *    Note that some groups can be empty.
 */
function crossesForMeta(metaId) {
  // we do not check that this meta contains any crosses. This should be done in parent call
  let cc = db.exec("SELECT id FROM crosses WHERE meta_id = '" + metaId + "'");
  let contents = db.exec("SELECT cross_id, cross_forms.id, cross_forms.name, cross_forms.group_id, cross_definitions.is_certain FROM cross_definitions INNER JOIN cross_forms ON (cross_definitions.form_id = cross_forms.id) WHERE cross_id IN (SELECT id FROM crosses WHERE meta_id = '" + metaId + "') ORDER BY cross_id");
  if (!contents)
    return [];

  let lastCrossId = -1;
  let crosses = [];

  for (let i = 0; i < contents[0].values.length; i++) {
    let crossId = parseInt(contents[0].values[i][0], 10);
    if (crossId != lastCrossId) {
      lastCrossId = crossId;
      crosses.push(Array.apply(null, Array(8)).map(function() {return [];}));
    }

    let formName = contents[0].values[i][2];
    let groupId = contents[0].values[i][3];
    let isCertain = contents[0].values[i][4];

    crosses[crosses.length - 1][parseInt(groupId, 10)].push({name: formName, isCertain: isCertain});
  }
  return crosses;
}

function displayFields() {
  let displayOptions = [
    {
      value: 'signature_text',
      text: 'Signature'
    },
    {
      value: 'found_location',
      text: 'Found location'
    },
    {
      value: 'parish',
      text: 'Parish'
    },
    {
      value: 'district',
      text: 'District'
    },
    {
      value: 'municipality',
      text: 'Municipality'
    },
    {
      value: 'current_location',
      text: 'Current location'
    },
    {
      value: 'original_site',
      text: 'Original site'
    },
    {
      value: 'parish_code',
      text: 'Parish code'
    },
    {
      value: 'rune_type',
      text: 'Rune type'
    },
    {
      value: 'dating',
      text: 'Dating'
    },
    {
      value: 'style',
      text: 'Style'
    },
    {
      value: 'carver',
      text: 'Carver'
    },
    {
      value: 'material',
      text: 'Material'
    },
    {
      value: 'material_type',
      text: 'Material type'
    },
    {
      value: 'objectInfo',
      text: 'Object information'
    },
    {
      value: 'reference',
      text: 'References'
    },
    {
      value: 'additional',
      text: 'Other information'
    },
    {
      value: 'normalisation_norse',
      text: 'Normalization to Old West Norse'
    },
    {
      value: 'normalisation_scandinavian',
      text: 'Normalisation to Old Scandinavian'
    },
    {
      value: 'english_translation',
      text: 'Translation to English'
    },
    {
      value: 'transliteration',
      text: 'Transliterated runic text'
    },
    {
      value: 'num_crosses',
      text: 'Number of crosses'
    },
    {
      value: 'crosses',
      text: 'Cross form'
    },
    {
      value: 'images',
      text: 'Images'
    },
  ];
  return displayOptions;
}

function humanNames() {
  let namesMap = [
    {
      value: 'runes_personalname',
      text: 'Personal Name'
    },
    {
      value: 'search_transliteration',
      text: 'Transliterated runic text'
    },
    {
      value: 'normalisation_search_norse',
      text: 'Normalization to Old West Norse'
    },
    {
      value: 'normalisation_search_scandinavian',
      text: 'Normalisation to Old Scandinavian'
    },
  ];
  return namesMap;
}

function humanNameForColumnName(columnName) {
  let a = displayFields().find(x => x.value === columnName);
  if (a) {
    return a.text;
  }
  a = humanNames().find(x => x.value === columnName);
  if (a) {
    return a.text;
  }
  return "Undefined";
  //return displayFields().find(x => x.value === columnName).text;
}

function initMultiselect() {
  var displayOptions = displayFields();

  $.each(displayOptions, function (i, item) {
      if (jQuery.inArray(item.value, userSelectedDisplay) != -1) {
        $('#multiselect_to').append($('<option>', {
            value: item.value,
            text : item.text
        }));
        return;
      }
      $('#multiselect').append($('<option>', {
          value: item.value,
          text : item.text
      }));
  });

  $('#multiselect').multiselect({
    keepRenderingSort: true,
  });
  formatDialog = $('#divFormatDiaglog');
}

function setTooltip(btn, message) {
  let that = $(btn);
  that.attr('data-original-title', message).tooltip('show');
  // do not care about multiple calls to setTimeout
  setTimeout(function() {
    that.tooltip('hide');
  }, 500);
}

var clipboard = [];
$(function() {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', "{% static 'runes/runes.sqlite3' %}?v=1.1.3", true);
  xhr.responseType = 'arraybuffer';
  xhr.addEventListener("load", onDbLoaded);
  xhr.send();

  initMultiselect();
  formatDialog.hide();
  $('#alertObj').hide();

  $('.clip').each(function (i) {
    // prepare buttons for clipboard library
    $(this).attr('data-clipboard-text', $(this).html());
  });
  $('.clip').tooltip({
    container: 'body',
    placement: 'bottom',
    title: 'Copied123!',
    trigger: 'manual',
    delay: 10,
  });
  clipboard = new ClipboardJS('.btn');
  clipboard.on('success', function(e) {
    setTooltip(e.trigger, 'Copied!');
  });
  clipboard.on('error', function(e) {
    setTooltip(e.trigger, 'Failed!');
  });

  // customMarker = L.Marker.extend({
  //    options: {
  //       myId: -1,
  //    }
  // });
  myMap = L.map('mapDisplay').setView([57.481491, 18.485840], 8);
  let osmAttrib = 'Map data © <a href="https://openstreetmap.org">OpenStreetMap</a> contributors';
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    {
      minZoom: 1,
      maxZoom: 15,
      attribution: osmAttrib
    }
  ).addTo(myMap);
  markers = L.markerClusterGroup({
    showCoverageOnHover: false,
    removeOutsideVisibleBounds: false,
  });
  markers.on('click', function (a) {
    var section = document.getElementById(a.layer.options.inscription);
    section.parentNode.scrollTop = section.offsetTop;
  });
  markers.addTo(myMap);

  // Next phase, jstree creation/initialization
  $('#jstree')
  .on('ready.jstree', function () {
      $('#loading').hide();
      applyPagination();
  })
  .on('changed.jstree', function(node, eventObj) {
    if (eventObj.action == 'select_node') {
      displaySignatureInfo();
    }
  })
  .jstree({
      'core': {
          'animation': 0,
          'data': fetchTreeData,
      }
  });
});

// 45 sec timeout
setTimeout(function() {
  if ($('#loading').is(':visible')) {
    $(document.body).html("Seems that something went wrong and the app is not usable. Try to refresh the page or come later.");
    alert('Seems that something went wrong and the app is not usable. Try to refresh the page or come later.');
  }
}, 45000);
</script>

</body>
</html>
