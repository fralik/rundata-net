{% load static %}
{% load settings %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Rundata.info is a web version of ​​​Scandinavian Runic-text Data Base.">
    <title>Rundata-net</title>
    {% get_from_settings 'USE_GA' as use_ga %}
    {% if use_ga %}
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-116856737-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-116856737-2');
    </script>
    {% endif %}

    <link href="https://netdna.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="{% static 'runes/jstree/themes/default/style.min.css' %}" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.4/dist/leaflet.css"
     integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA=="
     crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css">
    <!--
    <link rel="stylesheet" href="{% static 'runes/css/MarkerCluster.css' %}" />
    <link rel="stylesheet" href="{% static 'runes/css/MarkerCluster.Default.css' %}" />
    -->
    <link rel="stylesheet" href="{% static 'runes/pixabay/jquery.auto-complete.css' %}" />
    <link href="{% static 'runes/leaflet.fullscreen/leaflet.fullscreen.css' %}" rel='stylesheet' />

    <link rel="apple-touch-icon" sizes="180x180" href="{% static 'apple-touch-icon.png' %}">
    <link rel="icon" type="image/png" sizes="32x32" href="{% static 'favicon-32x32.png' %}">
    <link rel="icon" type="image/png" sizes="16x16" href="{% static 'favicon-16x16.png' %}">
    <link rel="mask-icon" href="{% static 'safari-pinned-tab.svg' %}" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#2b5797">
    <meta name="theme-color" content="#ffffff">

    <style type="text/css">
      .my-fixed-height {
        max-height: 500px;
        min-height: 500px;
        height: 500px;
        margin-bottom: 15px;
      }
      .jstree-scrollable {
        overflow-y: scroll;
        max-height: 100%;
        height: 100%;
      }
      .border-1 {
        border: 1px solid #ccc;
      }
      .group-full-height {
        max-height: 100%;
        min-height: 100%;
        height: 100%;
      }
      .border-left-bottom {
        border-left: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
      }
      .border-bottom-right {
        border-right: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
      }
      .border-bottom {
        border-bottom: 1px solid #ccc;
      }
      body {
        font-family: 'Lucida Grande', 'Lucida Sans Unicode', 'Lucida Sans', 'DejaVu Sans', Verdana, Helvetica, sans-serif;
      }
      .transliteration {
        font-weight: bold;
      }
      .normalization {
        font-style: italic;
        font-weight: normal;
      }
      th {
        text-align: center;
      }
      span.null {
        font-weight: bold;
        color: #CCCCCC;
      }
      .white-text {
        color:#fff!important;
      }
      .navbar-static-top {
        margin-bottom: 0px;
      }

      .vertical-align {
        display: flex;
        align-items: center;
      }
      .inscription-section {
        border-bottom: 2px solid #999;
      }
      .zero-padding-left {
        padding-left: 0px;
      }
      .highlighted {
        color: red;
      }
      .top-margin {
        margin-top: 5px;
      }
      /**********************************
       * drop area styles
       **********************************/
      #drop-area {
        border: 2px dashed #dcc896;
        border-radius: 20px;
        /*margin: auto;*/
        margin-bottom: 20px;
        padding: 20px;
      }
      #drop-area.highlight {
        border-color: green;
      }
      .my-form {
        margin-bottom: 10px;
      }
      .my-form p {
        margin-top: 0;
      }
      .my-form .button {
        display: inline-block;
        padding: 10px;
        background: #fff;
        cursor: pointer;
        border-radius: 5px;
        border: 1px solid #ccc;
      }
      .my-form .button:hover {
        background: #ddd;
      }
      #fileElem {
        display: none;
      }
      #alertObj {
        display: none;
      }
      /********************************
       * drop area styles end
       */
       .row {
        /*border: 1px solid #ccc;*/
       }
      .pt-3,
      .py-3 {
        padding-top: 1rem !important;
      }
      .pb-3,
      .py-3 {
        padding-bottom: 1rem !important;
      }
      .pb-5,
      .py-5 {
        padding-bottom: 3rem !important;
      }
      .pb-6,
      .py-6 {
        padding-bottom: 9rem !important;
      }
    </style>
  </head>
<body style="">
  <nav class="navbar navbar-default navbar-static-top">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="#">Rundata-net</a>
      </div>
      <div id="navbar" class="navbar-collapse collapse">
        <ul class="nav navbar-nav">
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Map <span class="caret"></span></a>
            <ul class="dropdown-menu">
              <li><a href="#" id="mHideMap">Hide map</a></li>
              <li><a href="#"><div class="checkbox">
                <input type="checkbox" id="chkShowSelectedInscriptions">
                <label for="chkShowSelectedInscriptions">Show selected inscriptions only</label>
              </div></a></li>
            </ul>
          </li>

          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Import/Export <span class="caret"></span></a>
            <ul class="dropdown-menu">
              <li><a href="#" data-toggle="modal" data-target="#containerRuleIo">Search parameters</a></li>
              <li><a href="#" data-toggle="modal" data-target="#modalResultsIo">Results</a></li>
            </ul>
          </li>
        </ul>
        <ul class="nav navbar-nav navbar-right">
          <li class=""><a href="{% url 'runes:about' %}" target="_blank">About</a></li>
          <li class=""><a href="http://rundata-net.rtfd.io/" target="_blank">Help</a></li>
          <li class=""><a href="{% url 'runes:references' %}" target="_blank">Bibliography</a></li>
        </ul>
      </div> <!--/.navbar-collapse-->
    </div>
  </nav>

  <div class="container-fluid">
    <div class="row">
      <div class="col alert alert-danger" role="alert" id="alertObj"></div>
    </div>

    <div class="row">
      <div id="leftPanel" class="col-md-2 col-sm-2 my-fixed-height table-bordered" style="padding: 0;">
        <div class="list-group group-full-height" style="padding-right: 0px; position: relative;">
          <div id="jstree" class="jstree-scrollable"></div>
        </div>
      </div>

      <div id="mainDisplay" contentEditable="true" autocomplete="off" autocorrect="off" spellcheck="false" class="col-md-6 col-sm-8 table-bordered my-fixed-height pre-scrollable">
      </div>

      <div id="mapDisplay" class="col-md-4 col-sm-2 my-fixed-height"></div>
    </div>

    <div class="row">
      <div class="col-md-2" id="lblNumAvailable">6751 inscriptions.</div>
      <div class="col-md-6 col-sm-8">&nbsp;</div>
      <div class="col-md-4 col-sm-2">
      </div>
    </div>
    <div class="row">
      <div class="col-xs-12">&nbsp;</div>
    </div>

    <form class="row pb-3 vertical-align" role="group">
      <div class="col-md-2">
        Control buttons:
      </div>
      <div class="col-md-10" aria-label="">
        <button type="button" class="btn btn-default" data-toggle="modal" data-target="#divFormatDialog">Choose what to show about each inscription</button>
      </div>
    </form>

    <section role="group" class="row vertical-align py-3">
      <div class="col-md-2">Copy symbols to clipboard:</div>
      <div class="col-md-10 btn-group" role="group">
        <button type="button" class="btn btn-default clip" id="btnOUmlautSmall">ö</button>
        <button type="button" class="btn btn-default clip" id="btnOUmlaut">Ö</button>
        <button type="button" class="btn btn-default clip" id="btnAaSmall">å</button>
        <button type="button" class="btn btn-default clip" id="btnAa">Å</button>
        <button type="button" class="btn btn-default clip" id="btnAaUmlautSmall">ä</button>
        <button type="button" class="btn btn-default clip" id="btnAaUmlaut">Ä</button>
        <button type="button" class="btn btn-default clip" id="btnTh">þ</button>
        <button type="button" class="btn btn-default clip" id="btnEn">ñ</button>
        <button type="button" class="btn btn-default clip" id="btnDh">ð</button>
        <button type="button" class="btn btn-default clip" id="btnDh">ï</button>
        <button type="button" class="btn btn-default clip" id="btnAe">æ</button>
        <button type="button" class="btn btn-default clip" id="btnAe">Æ</button>
        <button type="button" class="btn btn-default clip" id="btnOe">ø</button>
        <button type="button" class="btn btn-default clip" id="btnOe">Ø</button>
        <button type="button" class="btn btn-default clip" id="btnOe2">œ</button>
        <button type="button" class="btn btn-default clip" id="btnOe2">Œ</button>
        <button type="button" class="btn btn-default clip" id="btnOhakeSmall">ô</button>
        <button type="button" class="btn btn-default clip" id="btnOhakeCapital">Ô</button>
      </div>
    </section>

    <div class="row py-3" role="group" aria-label="">
      <div class="col-md-offset-2 col-md-3">
        <button type="button" class="col-md-12 btn btn-success" id="btnSearch">Search</button>
      </div>
      <div class="col-md-2">
        <button type="button" class="col-md-12 btn btn-default" id="btnResetSearch">Reset search</button>
      </div>
      <button type="button" class="btn btn-default col-md-2" id="btnClearRules">Clear search parameters</button>
    </div>

    <div class="row pb-6">
      <div id="builder" class="col-xs-12"></div>
    </div>

  </div>

  <div id="divFormatDialog" class="modal fade" tabindex="-1" role="dialog" aria-labelledby="divFormatDialogLabel">
    <div class="modal-dialog modal-lg" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
          <h4 class="modal-title" id="divFormatDialogLabel">Configure inscription display</h4>
        </div>
        <div class="modal-body" style="padding-top: 1em; padding-left: 1em; padding-right: 1em;">
          <div class="row" style="padding-left: 1em; padding-right: 1em;">
            <p class="col alert alert-danger hidden" role="alert" id="formatDialogAlertObj"></p>
          </div>
          <div class="row" style="padding-left: 1em; padding-right: 1em;">
            <div class="col"><p>Here you can select which properties are shown on the main display when an inscription is selected. List on the left contains properties available for selection.
            List on the right contains properties selected for display.</p>
            <p>Check <em>Display headers</em> checkbox if you want to see property name as long as it's value. If unchecked, only the value is displayed.</p>
            </div>
          </div>
          <div class="row">
            <div class="col-sm-5">
              <select name="from[]" id="multiselect" class="form-control" size="8" multiple="multiple"></select>
              <div class="row">
                <form role="form" class="col-sm-6">
                  <div class="checkbox">
                    <input type="checkbox" id="chkDisplayHeaders" checked>
                    <label for="chkDisplayHeaders">Display headers</label>
                  </div>
                </form>
              </div>
            </div>

            <div class="col-sm-2">
              <button type="button" id="multiselect_rightAll" class="btn btn-block"><i class="glyphicon glyphicon-forward"></i></button>
              <button type="button" id="multiselect_rightSelected" class="btn btn-block"><i class="glyphicon glyphicon-chevron-right"></i></button>
              <button type="button" id="multiselect_leftSelected" class="btn btn-block"><i class="glyphicon glyphicon-chevron-left"></i></button>
              <button type="button" id="multiselect_leftAll" class="btn btn-block"><i class="glyphicon glyphicon-backward"></i></button>
            </div>

            <div class="col-sm-5">
              <select name="to[]" id="multiselect_to" class="form-control" size="8" multiple="multiple"></select>
              <div class="row">
                <div class="col-sm-6">
                  <button type="button" id="multiselect_move_up" class="btn btn-block"><i class="glyphicon glyphicon-arrow-up"></i></button>
                </div>
                <div class="col-sm-6">
                  <button type="button" id="multiselect_move_down" class="btn btn-block"><i class="glyphicon glyphicon-arrow-down"></i></button>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          <button type="button" class="btn btn-primary" id="btnApplyDisplayFormat">Apply changes</button>
        </div>
      </div>
    </div>
  </div>

  <div id="containerRuleIo" class="modal fade" tabindex="-1" role="dialog" aria-labelledby="containerRuleIoLabel">
    <div class="modal-dialog modal-lg" role="document">
      <div class="modal-content">

        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
          <h4 class="modal-title" id="containerRuleIoLabel">Export/import search parameters</h4>
        </div>

        <div class="modal-body">
          <div class="row">
            <p class="col-xs-12">
              Use the tool below to preserve your search rules between sessions. Clicking <em>Export</em> will give you search rules in text format. You can copy text and save it elsewhere. Next time you load work with Rundata-net you can import that text.
            </p>
          </div>

          <div class="row py-3">
            <div class="col-xs-12 btn-group" role="group" aria-label="">
              <button type="button" class="btn btn-default" id="btnRulesImport">Import</button>
              <button type="button" class="btn btn-default" id="btnRulesExport">Export</button>
            </div>
          </div>

          <div class="row">
            <div class="col-xs-12">
              <textarea id="ruleIo" rows="15" style="width: 100%;"></textarea>
            </div>
          </div>

        </div>

        <div class="modal-footer">
          <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
        </div>

      </div>
    </div>
  </div>

  <section role="dialog" class="modal fade" id="modalResultsIo" tabindex="-1" role="dialog" arial-labelledby="divResultsIoLabel">
    <div class="modal-dialog modal-lg" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
          <h4 class="modal-title" id="divResultsIoLabel">Export search results, import signatures</h4>
        </div>

        <div class="modal-body">
          <div class="row">
            <div class="col-xs-offset-1 col-xs-10">
              <p>Export search results in CSV format by clicking <em>Export</em> button bellow.<br>Read more about exporting <a href="https://rundata-net.readthedocs.io/en/latest/getting-started/user_guide.html#importing-and-exporting-results">in the documentation</a>.</p>
              <button type="button" class="col-xs-3 btn btn-default" id="btnExportResults"><b>Export search results</b></button>
            </div>
          </div>
          <div class="row">
            <div class="col-xs-12"><hr></div>
          </div>

          <div class="row">
            <div id="drop-area" class="col-xs-10 col-xs-offset-1">
              <form class="my-form" id="form-signature-import">
                <div class="form-group">
                  <p>Import file with signatures by dragging and dropping it in highlighted area or by selecting it. Read more about the possible file formats <a href="https://rundata-net.readthedocs.io/en/latest/getting-started/user_guide.html#importing-and-exporting-results">in the documentation</a>.</p>
                  <label for="fileElem" class="button">Select a file</label>
                  <input type="file" id="fileElem">
                </div>
              </form>
            </div>
          </div>
        </div>

        <div class="modal-footer">
          <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
        </div>

  </section>

  <aside id="loading" class="loading-screen" style="position:fixed; top:0; right:0; bottom:0; left:0; z-index:9999; background-color: #000; opacity: 0.6;">
    <div class="col-sm-8 col-sm-offset-2 col-md-6 col-md-offset-3 col-lg-4 col-lg-offset-4" style="position:absolute; top:50%; margin-top:-7em">
      <div class="page-header">
        <i class="text-primary fa fa-spin fa-fw pull-left fa-spinner fa-2x" style="text-shadow: 0px 0px 0ex;"></i>
        <hgroup class="" style="text-shadow: 0px 0px 0ex;">
          <h4 ng-switch-default="" class="white-text" id="loading-main-text">
            Loading<br>
            <small class="white-text" id="loading-sub-text">It can take up to a minute.</small>
          </h4>
        </hgroup>
      </div>
    </div>
  </aside>

<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<!-- query builder styles -->
<!-- <link href="{% static 'query-builder/bootstrap-datepicker3.min.css' %}" rel="stylesheet"> -->
<!-- <link href="{% static 'query-builder/bootstrap-slider.min.css' %}" rel="stylesheet"> -->
<link href="{% static 'query-builder/selectize.bootstrap3.css' %}" rel="stylesheet">
<link href="{% static 'query-builder/bootstrap-select.min.css' %}" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/awesome-bootstrap-checkbox/0.3.7/awesome-bootstrap-checkbox.css" rel="stylesheet">
<link href="{% static 'query-builder/query-builder.default.min.css' %}" rel="stylesheet">
<!--<link href="{% static 'runes/chosen/chosen.min.css' %}" rel="stylesheet">-->
<link href="{% static 'runes/jquery-ui/jquery-ui.min.css' %}" rel="stylesheet">
<!-- end of query builder styles -->

<script>
/**
 * detect IE
 * returns version of IE or false, if browser is not Internet Explorer
 */
function detectIE() {
  var ua = window.navigator.userAgent;

  // Test values; Uncomment to check result …

  // IE 10
  // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';

  // IE 11
  // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';

  // Edge 12 (Spartan)
  // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';

  // Edge 13
  // ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586';

  var msie = ua.indexOf('MSIE ');
  if (msie > 0) {
    // IE 10 or older => return version number
    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
  }

  var trident = ua.indexOf('Trident/');
  if (trident > 0) {
    // IE 11 => return version number
    var rv = ua.indexOf('rv:');
    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
  }

  var edge = ua.indexOf('Edge/');
  if (edge > 0) {
    // Edge (IE 12+) => return version number
    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
  }

  // other browser
  return false;
}

function isSafari() {
  return (navigator.userAgent.indexOf('Safari') != -1 && navigator.userAgent.indexOf('Chrome') == -1);
}

var ieVersion = detectIE();
if (ieVersion !== false && ieVersion <= 12) {
  alert('This version of Internet Explorer is not supported. Please update or use a different browser. Will redirect to About page.');
  window.location.href = "{% url 'runes:about' %}#browser-support";
}
if (isSafari()) {
  alert('It seems like you are using Safari. Safari is known to have issues. Will refirect you to About page.');
  window.location.href = "{% url 'runes:about' %}#browser-support";
}
</script>

<script src="https://unpkg.com/clipboard@2.0.0/dist/clipboard.min.js"></script>
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="{% static 'runes/jstree/jstree.js' %}"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bootbox.js/4.3.0/bootbox.min.js"></script>
<script src="{% static 'runes/interact.min.js' %}"></script>
<script src="{% static 'runes/sql.js' %}"></script>

<!-- begin of query builder js -->
<script src="{% static 'query-builder/moment.min.js' %}"></script>
<!-- <script src="{% static 'query-builder/bootstrap-datepicker.min.js' %}"></script> -->
<!--<script src="{% static 'query-builder/bootstrap-slider.min.js' %}"></script>-->
<script src="{% static 'query-builder/selectize.min.js' %}"></script>
<script src="{% static 'query-builder/bootstrap-select.min.js' %}"></script>
<script src="{% static 'query-builder/query-builder.standalone.min.js' %}"></script>
<script src="{% static 'query-builder/interact.min.js' %}"></script>
<!--<script type="text/javascript" src="{% static 'runes/chosen/chosen.jquery.min.js' %}"></script>-->
<script type="text/javascript" src="{% static 'runes/jquery-ui/jquery-ui.min.js' %}"></script>
<script src="{% static 'query-builder/my-templates.js' %}"></script>
<!-- end of query builder js -->

<script src="https://unpkg.com/leaflet@1.3.4/dist/leaflet-src.js"
 integrity="sha512-+ZaXMZ7sjFMiCigvm8WjllFy6g3aou3+GZngAtugLzrmPFKFK7yjSri0XnElvCTu/PrifAYQuxZTybAEkA8VOA=="
 crossorigin=""></script>
<script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster-src.js"></script>
<!-- <script src="{% static 'runes/leaflet.markercluster.js' %}"></script> -->

<script src="{% static 'runes/multiselect.min.js' %}"></script>
<script src="{% static 'runes/pixabay/jquery.auto-complete.min.js' %}"></script>
<!-- <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script> -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/clusterize.js/0.18.0/clusterize.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/clusterize.js/0.18.0/clusterize.js"></script>
<script src="{% static 'runes/papaparse.min.js' %}"></script>
<script src="{% static 'runes/leaflet.fullscreen/Leaflet.fullscreen.min.js' %}"></script>

<script type="text/javascript">
var entityMap = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '/': '&#x2F;',
  '`': '&#x60;',
  '=': '&#x3D;'
};

function escapeHtml (string) {
  return String(string).replace(/[&<>"'`=\/]/g, function (s) {
    return entityMap[s];
  });
}

// Globals:
// connection to the DB
var db = null;
// original data when no filter is applied.
// Used as cache, so we can skip quering the db again
var gOriginalData = [];
var gOriginalIds = [];
var gRootIds = []; // Map of parent/root inscription IDs
var gRootsJson = []; // JSON representation for gRootIds
var signatureNames = []; // names of all signatures in the DB
var signaturesSelectize = [];
var formatDialog = [];
var userSelectedDisplay = []; // list of user selected fields for display per inscription
var myMap = null; // Global handle to map object
var mapMarkers = {}; // Collection of created map markers. This is used in order to create
  // markers only once.
var markers = []; // Leaflet markers group
// Number of signatures selected by user
var gNumSelectedSignatures = [];
var lastShowHeaders = true; // last value of show headers checkbox in display format dialog
var gRegExpMap = {}; // Object of all regex expressions
var gRegExpMapG = {}; // Object of all regex expressions with global flag
var gWordIndices = {}; // Object that contains matched word indices across inscription text.
    // Words in this case are based on values prepared for search.
    // Each entry is an object itself where keys are column names and values
    // are arrays of matched words. Example entry of gWordIndices:
    // {search_transliteration: [1, 3, 5]; normalisation_search_norse: [3];}
var gMatchedWordIndices = {}; // A processed version of gWordIndices. It is a map that provides
    // information which words are matched for particular signature id. Key is signature id,
    // values set of matched word indices.
var gFoundPersonalNames = 0;
var gWordVariants = 0;
// regex that is used to separate words in displayed inscription texts.
//var gWordSearchRegex = new RegExp("((·|:|×|¤|'|\\+|÷|\\s)+|¶+)+", 'g');
var gWordSearchRegex = new RegExp("((\\s+|^(·|:|×|¤|'|\\+|÷|¶))(·|:|×|¤|'|\\+|÷|¶){0,1}\\s*)", 'g');
var gWordSearchRegexEsc = new RegExp(escapeHtml("((\\s+|^(·|:|×|¤|'|\\+|÷|¶))(·|:|×|¤|'|\\+|÷|¶){0,1}\\s*)"), 'g');
var gWordPunctuationRegex = new RegExp("(·|:|×|¤|'|\\+|÷|¶|\\(|\\)|\\[|\\])+");
var gWordPunctuationRegexEsc = new RegExp(escapeHtml("(·|:|×|¤|'|\\+|÷|¶|\\(|\\)|\\[|\\])+"));

// Whenever we need to render a batch of inscriptions, we identify each batch with gRenderBatchId. This can be
// used in situation when we need to render a batch when another batch is still in rendering process.
// I.e. we have batch 1 which is currently rendering. We have batch 2 that shall be rendered. In this case,
// batch 1 must be cancelled.
var gRenderBatchId = 0;
// True while rendering of signature information is in progress.
var gRenderInProgress = false;
// Global variable that is assigned with timer ID for displaySignatureInfo function call.
// If it is a valid ID, then we must not execute another call to displaySignatureInfo.
// Used to accumulate multiple jstree.changed events.
var gDisplayTimeout = -1;

// Map of aliases. Key is parent ID, value - list of alias names
// parent ID is SQLite index ID, it is not a signature!
var gAliasByParent = {};

// This is a key-value representation of all inscriptions in the database.
// Key is signature (i.e. 'Öl 1'), value is an object where each property is
// one of the displayFields() and value is it's corresponding value.
var gDbAsMap = {};

// Clusterize.js object for main isncription display
var gMainClusterize = null;

/*
  direction: 'up' or 'down',
  iteration: integer
  maxTries: integer,
  seekFactor: integer
*/
var gClusterizeParams = {};
// Indicates if we are in a state 'after user clicked reset'
var gAfterReset = false;
var gMainScrollArea = document.getElementById('mainDisplay');

// Key in the local storage under which users display options are saved.
// display options are information, which is displayed per inscription.
const gUserSelectedDisplayKey = "userSelectedDisplay";

// defaults.
userSelectedDisplay = getUserSelectedDisplay();

/////////////////////////////////////
// variables used for rendering. Have it here for speed.
/////////////////////////////////////
var staticBase = "{% static 'runes/images/cross_forms/' %}";
let highlightColumns = ['transliteration', 'normalisation_scandinavian', 'normalisation_norse'];
let customColumns = new Array(...highlightColumns);
customColumns.push('english_translation');
const paragraphSymbol = '§';
const sidesMarker = '§A';
const readingMarker = '§P';

// An extension of Leaflet marker that provides information about inscription
MarkerWithData = L.Marker.extend({
   options: {
      inscription: '',
   }
});

function displayStatistics() {
  var total = gRootsJson.length;
  if (total == 0) {
    $('#lblNumAvailable').html('Sorry, no inscriptions has been found.');
  } else {
    let numWords = 0;
    for (signId in gMatchedWordIndices) {
      numWords += gMatchedWordIndices[signId].size;
    }
    let infoStr = `${gRootsJson.length} inscriptions`;
    numWords -= gWordVariants;
    if (numWords > 0) {
      infoStr += `, ${numWords} words, ${gFoundPersonalNames} personal names`;
    }
    infoStr += '.';
    $('#lblNumAvailable').html(infoStr);
  }
}

function dbToJson(columnNames, values, rootsWithChildren = null) {
  let lostIdx = columnNames.indexOf('lost');
  let newReadingIdx = columnNames.indexOf('new_reading');

  let dbJson = values.map(function(v, i) {
      var hasChildren = false;

      let additional = '';
      if (lostIdx != -1 && newReadingIdx != -1) {
        let isLost = !!+v[lostIdx];
        let isNewReading = !!+v[newReadingIdx];

        if (isLost) {
          additional += "†";
        }
        if (isNewReading) {
          additional += '$';
        }
        if (additional.length > 0)
          additional = ' ' + additional;
      }

      return {
          id: v[0].toString(),
          text: v[1] + additional,
          normalizedText: v[1].normalize('NFD').replace(/[\u0300-\u036f]/g, ""),
          icon: false,
          children: hasChildren,
          id_numeric: v[0],
          signature: v[1],
      }
  });

  return dbJson;
}

function arraysEqual(a, b) {
  if (a === b) return true;
  if (a == null || b == null) return false;
  if (a.length != b.length) return false;

  for (var i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}

function storageAvailable(type) {
  var storage;
  try {
    storage = window[type];
    var x = '__storage_test__';
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  }
  catch(e) {
    return e instanceof DOMException && (
      // everything except Firefox
      e.code === 22 ||
      // Firefox
      e.code === 1014 ||
      // test name field too, because code might not be present
      // everything except Firefox
      e.name === 'QuotaExceededError' ||
      // Firefox
      e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&
      // acknowledge QuotaExceededError only if there's something already stored
      (storage && storage.length !== 0);
  }
}

function getUserSelectedDisplay() {
  var defaults = ['signature_text', 'transliteration', 'english_translation', 'found_location',
      'parish', 'municipality', 'district', 'current_location', 'images'];
  var fieldsToDisplay = defaults;

  if (storageAvailable('localStorage')) {
    storage = window['localStorage'];
    if (storage.getItem(gUserSelectedDisplayKey)) {
      fieldsToDisplay = JSON.parse(storage.getItem(gUserSelectedDisplayKey));
    }
  }
  return fieldsToDisplay;
}

function saveUserSelectedDisplay() {
  if (!storageAvailable('localStorage'))
    return;
  storage = window['localStorage'];

  var selectedValues = $('#multiselect_to option').map((index, el) => $(el).val()).toArray();
  // ensure it is an array and encode it as json string, because local storage can work with string only.
  var selectedValuesArray = JSON.stringify(selectedValues ? [].concat(selectedValues) : []);

  storage.setItem(gUserSelectedDisplayKey, selectedValuesArray);
}

function onDisplayFormatClicked(e) {
  e.preventDefault();

  var selectedValues = [];
  var alertObj = $('#formatDialogAlertObj');
  $('#multiselect_to option').each(function() { selectedValues.push($(this).val()); });
  if (selectedValues === null || selectedValues.length == 0) {
    alertObj.html('Nothing is selected for display! Please select at least one property.');
    alertObj.removeClass('hidden');
    alertObj.addClass('show');
    return;
  }

  if (alertObj.hasClass('show')) {
    alertObj.removeClass('show');
    alertObj.addClass('hidden');
  }

  if (selectedValues.length > 0) {
    const newShowHeaders = $('#chkDisplayHeaders').is(":checked");
    if (!arraysEqual(userSelectedDisplay, selectedValues) || newShowHeaders != lastShowHeaders) {
      userSelectedDisplay = selectedValues;

      displaySignatureInfo();

      lastShowHeaders = newShowHeaders;
    }
  }
  $(this).prev().click();
}

function onHideMapClicked() {
  $('#mapDisplay').toggle();
  var mainContainer = $('#mainDisplay');

  if ($('#mapDisplay').is(':visible')) {
    $('#mHideMap').html('Hide map');
    mainContainer.removeClass('col-md-10 col-sm-10');
    mainContainer.addClass('col-md-6 col-sm-8');
  } else {
    $('#mHideMap').html('Show map');
    mainContainer.removeClass('col-md-6 col-sm-8');
    mainContainer.addClass('col-md-10 col-sm-10');
  }
}

function selectizeFilter(fieldId) {
  var str = `SELECT DISTINCT ${fieldId} FROM all_data WHERE ${fieldId} NOT NULL AND ${fieldId} <> '' ORDER BY ${fieldId} COLLATE NOCASE;`;
  var contents = db.exec(str);
  var myOptions = contents[0].values.map(function (v) { return {text: v[0]} });

  return {
    id: fieldId,
    field: fieldId,
    label: humanNameForColumnName(fieldId),
    type: 'string',
    plugin: 'selectize',
    plugin_config: {
      valueField: 'text',
      labelField: 'text',
      searchField: 'text',
      sortField: 'text',
      maxItems: 1,
      plugins: ['restore_on_backspace'],
      valueSetter: function (rule, value) {
        rule.$el.find('.rule-value-container input')[0].selectize.setValue(value);
      },
      options: myOptions,
      create: true,
      createOnBlur: true,
      persist: true,
      dropdownDirection: 'up',
    }
  }
}

/* Dictionary with fields:
  .r => rule id, mandatory
  .l => label, mandatory
  .f => field id, optional. If not provided, .r is used.
  .v => default value, optional. If not provided, set to 0.
*/
function prepareBooleanRule(opt) {
  let fieldId = opt.f || opt.r;
  let defaultValue = opt.v || 0;

  return {
    id: opt.r,
    label: opt.l,
    type: 'integer',
    field: fieldId,
    input: 'radio',
    values: [
      {0: 'No'},
      {1: 'Yes'}
    ],
    default_value: defaultValue,
    operators: ['equal'],
  };
}

function prepareIntegerField(ruleId, opt) {
  if (!opt) opt = {};
  const fieldId = opt.fieldId || ruleId;
  const operators = opt.operators || ['equal', 'not equal', 'less', 'less or equal', 'greater', 'greater or equal', 'between', 'not between'];
  const size = opt.size || 10;

  return {
    id: ruleId,
    field: fieldId,
    label: humanNameForColumnName(fieldId),
    type: 'integer',
    size: size,
    operators: operators,
  }
}

function prepareAutoComplete(ruleId, opt) {
  if (!opt) opt = {};
  const fieldId = opt.fieldId || ruleId;
  const operators = opt.operators || ['equal', 'not_equal', 'begins_with',
        "not_begins_with", "contains", "not_contains", "ends_with",
        "not_ends_with", "is_empty", 'is_not_empty', "my_regex"];
  const type = opt.type || 'string';
  const size = opt.size || 70;

  let contents = [];
  if (ruleId.indexOf('normalisation') != -1) {
    let str = `SELECT DISTINCT search_value FROM ${ruleId}`;
    contents = db.exec(str);
  } else if (ruleId.indexOf('runes_personalname') != -1) {
    let str = `SELECT DISTINCT value FROM ${ruleId}`;
    contents = db.exec(str);
  } else if (ruleId.indexOf('transliteration') != -1) {
    let str = 'SELECT DISTINCT search_value FROM transliterated_text';
    contents = db.exec(str);
  } else {
    let str = `SELECT DISTINCT ${fieldId} FROM all_data WHERE ${fieldId} NOT NULL AND ${fieldId} <> '' ORDER BY ${fieldId} COLLATE NOCASE;`;
    contents = db.exec(str);
  }

  return {
    id: ruleId,
    field: fieldId,
    label: humanNameForColumnName(fieldId),
    type: type,
    plugin: 'autoComplete',
    plugin_config: {
      minChars: 0,
      delay: 100,
      source: function (term, suggest) {
        var matches = [];
        for (i = 0; i < contents[0].values.length; i++) {
          if (contents[0].values[i][0].startsWith(term))
            matches.push(contents[0].values[i][0]);
        }
        suggest(matches);
      },
      menuClass: ' clusterize-content ',
      attachToParent: true,
    },
    size: size,
    operators: operators,
  }
}

function resetSearchStats() {
  gWordIndices = {};
  gMatchedWordIndices = {};
  gFoundPersonalNames = 0;
  gWordVariants = 0;
}

// Applies user-defined filters in order to obtain valid IDs
// Returns true on success, false on any failure.
//
function applyFilters() {
  var result = $('#builder').queryBuilder('getSQL', false);
  if (!result || !result.sql.length) {
    return false;
  }

  resetSearchStats();

  result.sql = result.sql.replace("signature_text LIKE ('all_sweden%')", "signature_text LIKE ('Öl %') OR \
    signature_text LIKE ('Ög %') OR signature_text LIKE ('Sö %') OR signature_text LIKE ('Sm %') OR \
    signature_text LIKE ('Vg %') OR signature_text LIKE ('U %') OR signature_text LIKE ('Vs %') OR \
    signature_text LIKE ('Nä %') OR signature_text LIKE ('Vr %') OR signature_text LIKE ('Gs %') OR \
    signature_text LIKE ('Hs %') OR signature_text LIKE ('M %') OR signature_text LIKE ('Ån %') OR \
    signature_text LIKE ('D %') OR signature_text LIKE ('Hr %') OR signature_text LIKE ('J %') OR \
    signature_text LIKE ('Lp %') OR signature_text LIKE ('Ds %') OR signature_text LIKE ('Bo %') OR \
    signature_text LIKE ('G %') OR signature_text LIKE ('SE %')");

  console.log('Got SQL: ' + result.sql);
  var contents = db.exec("SELECT signature_id, signature_text, lost, new_reading, normalisation_scandinavian FROM all_data WHERE " + result.sql);
  if (contents.length == 0) {
    // no results
    gRootsJson = [];
    return true;
  }

  let signatureIdIdx = contents[0].columns.indexOf('signature_id');
  let normalisationScandinavianIdx = contents[0].columns.indexOf('normalisation_scandinavian');

  if (Object.keys(gWordIndices).length != 0) {
    contents[0].values = contents[0].values.filter(function checkIds(row) {
      id = row[signatureIdIdx];
      normalizedText = row[normalisationScandinavianIdx];

      if (!gWordIndices.hasOwnProperty(id))
        return true;

      let allKeys = Object.keys(gWordIndices[id]);
      let intersection = new Set(gWordIndices[id][allKeys[0]]);
      for (i = 1; i < allKeys.length; i++) {
        if (allKeys[i].indexOf('_par') != -1) {
          continue;
        }
        let b = new Set(gWordIndices[id][allKeys[i]]);
        intersection = new Set([...intersection].filter(x => b.has(x)));
        if (intersection.size == 0) {
          return false;
        }
      }

      let words = getWordBoundaries(normalizedText, gWordSearchRegex, gWordPunctuationRegex);
      let wordVariants = [];
      var counts = {};
      var countsPersonal = {};
      intersection.forEach(function (val) {
        // We do not need to count words that have isVariant > 0.
        // Do not count corresponding personal names
        gFoundPersonalNames += words[val].isPersonal;
        if (words[val].isVariant > 0) {
          let key = words[val].isVariant;
          counts[key] = (counts[key] || 0) + 1;
          if (words[val].isPersonal) {
            countsPersonal[key] = (countsPersonal[key] || 0) + 1;
          } else {
            countsPersonal[key] = (countsPersonal[key] || 0);
          }
        }
      });

      let countValues = [...Object.values(counts)];
      var personalBias = 0;
      if (countValues.length > 0) {
        let minCounts = Math.min(...countValues);
        let minIndex = countValues.indexOf(minCounts) + 1;

        if (!isNaN(minCounts))
          gWordVariants += minCounts * (countValues.length-1);
        if (!isNaN(countsPersonal[minIndex]))
          personalBias += countsPersonal[minIndex] * (countValues.length-1);
      }
      gFoundPersonalNames -= personalBias;

      gMatchedWordIndices[id] = intersection;
      return true;
    });
  }

  // hash map of inscription IDs that have children.
  var rootsWithChildren = db.exec("SELECT * FROM signatures_with_children");
  // make a hash map for quick read access
  rootsWithChildren = new Map(rootsWithChildren[0].values.map((v, i) => [v[0], 1]));

  gRootIds = new Map(contents[0].values.map((v, i) => [v[0], i]));
  gRootsJson = dbToJson(contents[0].columns, contents[0].values, rootsWithChildren);

  return true;
}


function range(size, startAt = 0) {
    return [...Array(size).keys()].map(i => i + startAt);
}

// extract starting indices of words from str
// Can be applied for string where words are separated by a single whitespace
function getWordStarts(str, regexStr) {
  if (regexStr === undefined) {
    regexStr = '\\s';
  }
  let r = new RegExp(regexStr, 'g');
  var matches = [-1];
  while ((arr = r.exec(str)) !== null) {
    matches.push(arr.index);
  }
  matches.push(str.length);

  return matches;
}

// Extracts word boundaries from inscription texts. These texts
// have multiple separators (whitespaces, punctuation) that often
// go together, i.e. space,punctuation,space
// returns array of objects. Each object:
// {start: num, end: num, text: string, isPersonal: 0 or 1, isVariant: [0...N] }
// isVariant - if word is located within a paragrapgh (i.e. §P) isVariant
// contains a numerical difference between paragraph character and 'P'. For §P
// isVariant is 1, for §Q isVariant is 1.
// str - search string
// reg - regex used to detect word boundaries
// purePunctuation - regex used to check if detected word is pure punctuational
function getWordBoundaries(str, reg, purePunctuation) {
  var words = [];
  var wordBegin = 0;
  //var purePunctuation = new RegExp("(·|:|×|¤|'|\\+|÷|¶|\\(|\\))+");
  var strReversed = str.split("").reverse().join("");
  let pCode = 'P'.charCodeAt();

  while ((arr = reg.exec(str)) !== null) {
    if (wordBegin == arr.index) {
      wordBegin += arr[0].length;
      continue;
    }
    let oneWord = {start: wordBegin, end: arr.index, isPersonal: 0, isVariant: 0};
    let wordText = str.slice(oneWord.start, oneWord.end);
    oneWord.text = wordText;
    // skip double sides character
    if (arr[0] == '¶¶')
      continue;

    punctuationCheck = purePunctuation.exec(oneWord.text);
    if (punctuationCheck !== null && punctuationCheck[0].length == oneWord.text.length)
    {
      wordBegin = arr.index + arr[0].length;
      continue;
    }

    if (wordText.startsWith('"') || wordText.startsWith("&quot;"))
      oneWord.isPersonal = 1;
    let reverseStart = str.length-1 - wordBegin;
    if ((parPos = strReversed.indexOf('§', reverseStart)) != -1) {
      if (strReversed[parPos-1].charCodeAt() - pCode >= 0) {
        oneWord.isVariant = strReversed[parPos-1].charCodeAt() - pCode + 1;
      }
    }

    words.push(oneWord);
    wordBegin = arr.index + arr[0].length;
  }
  if (wordBegin == 0) {
    if (str.length > 0) {
      let oneWord = {start: 0, end: str.length, text: str, isPersonal: 0, isVariant: 0};
      if (oneWord.text.startsWith('"') || oneWord.text.startsWith("&quot;"))
        oneWord.isPersonal = 1;

      let reverseStart = str.length-1;
      if ((parPos = strReversed.indexOf('§', reverseStart)) != -1) {
        if (strReversed[parPos-1].charCodeAt() - pCode >= 0) {
          oneWord.isVariant = strReversed[parPos-1].charCodeAt() - pCode + 1;
        }
      }

      punctuationCheck = purePunctuation.exec(oneWord.text);
      if (punctuationCheck === null || punctuationCheck[0].length != oneWord.text.length)
        words.push(oneWord);
    }
  } else {
    // let's add the final word
    if (wordBegin != str.length) {
      let oneWord = {start: wordBegin, end: str.length, isPersonal: 0, isVariant: 0};
      oneWord.text = str.slice(oneWord.start, oneWord.end);
      if (oneWord.text.startsWith('"') || oneWord.text.startsWith("&quot;"))
        oneWord.isPersonal = 1;

      let reverseStart = str.length-1 - wordBegin;
      if ((parPos = strReversed.indexOf('§', reverseStart)) != -1) {
        if (strReversed[parPos-1].charCodeAt() - pCode >= 0) {
          oneWord.isVariant = strReversed[parPos-1].charCodeAt() - pCode + 1;
        }
      }

      punctuationCheck = purePunctuation.exec(oneWord.text);
      if (punctuationCheck === null || punctuationCheck[0].length != oneWord.text.length)
        words.push(oneWord);
    }
  }
  return words;
}

// return words by index. Words are separated by a single space
function wordsByIndex(str, indices) {
  let allWords = str.split(' ');
  let words = [];
  indices.forEach(item => words.push(allWords[item]));
  return words;
}

function wordByCharPos(wordStarts, charPos) {
  for (i = 0; i < wordStarts.length - 1; i++) {
    if (charPos > wordStarts[i] && charPos < wordStarts[i+1]) {
      return i;
    }
  }
  return -1;
}

function onDbLoaded(e) {
  if (!this.response) {
    return;
  }

  var uInt8Array = new Uint8Array(this.response);
  db = new SQL.Database(uInt8Array);

  // add support for regexp searches
  db.create_function('regexp', function (regexValue, fieldData) {
    // do not recreate expression objects
    if (!gRegExpMap.hasOwnProperty(regexValue)) {
      gRegExpMap[regexValue] = new RegExp(regexValue);
      gRegExpMapG[regexValue] = new RegExp(regexValue, 'g');
    }
    let res = -1;
    if (gRegExpMap[regexValue].test(fieldData))
      res = 1;

    return res;
  });

  // Add support for searches across words
  db.create_function('wordRegexp', function (regexValue, fieldData, id, fieldName) {
    if (!gRegExpMap.hasOwnProperty(regexValue)) {
      gRegExpMap[regexValue] = new RegExp(regexValue);
      gRegExpMapG[regexValue] = new RegExp(regexValue, 'g');
    }

    // Test method doesn't really work with global regexps. At least
    // when regex is stored in a global variable, i.e. preserves state
    // between function calls
    if (gRegExpMap[regexValue].test(fieldData) == true) {
      // Use gRegExpMapG from now on. This is important!

      wordStarts = getWordStarts(fieldData);

      var matchIndices = [];
      while ((array1 = gRegExpMapG[regexValue].exec(fieldData)) !== null) {
        minWordIdx = wordByCharPos(wordStarts, array1.index);
        maxWordIdx = wordByCharPos(wordStarts, array1.index+array1[0].length-1);

        let wordIndices = range(maxWordIdx-minWordIdx+1, minWordIdx); // range of word indices
        if (!gWordIndices.hasOwnProperty(id)) {
          gWordIndices[id] = {};
        }
        if (!gWordIndices[id].hasOwnProperty(fieldName)) {
          gWordIndices[id][fieldName] = [];
        }
        gWordIndices[id][fieldName].push(...wordIndices);
      }
      return 1;
    }

    return -1;
  });

  // get all root signatures (that are not aliases)
  var contents = db.exec("SELECT signature_id, signature_text, lost, new_reading FROM all_data");
  var rootsWithChildren = db.exec("SELECT * FROM signatures_with_children");
  // make a hash map for quick read access
  rootsWithChildren = new Map(rootsWithChildren[0].values.map((v, i) => [v[0], 1]));

  gRootIds = new Map(contents[0].values.map((v, i) => [v[0], i]));
  gRootsJson = dbToJson(contents[0].columns, contents[0].values, rootsWithChildren);

  ////////////////////////////////////////////////////////////////////
  // fill in gAliasByParent. Must be done before convertDbToKeyMap!
  let aliasContents = db.exec('SELECT id, signature_text, parent_id FROM signatures WHERE parent_id NOT NULL');
  if (aliasContents && aliasContents.length > 0) {
    aliasContents[0].values.map(function (row, i) {
      let parent_id = row[2];
      let signature_text = row[1];

      if (!(parent_id in gAliasByParent)) {
        // we do not have an entry for that parent. initialize it
        gAliasByParent[parent_id] = [];
      }
      curValue = gAliasByParent[parent_id];
      curValue.push(signature_text);
      gAliasByParent[parent_id] = curValue;
    });
  }
  ////////////////////////////////////////////////////////////////////

  gOriginalData = gRootsJson;
  gOriginalIds = gRootIds;
  gDbAsMap = convertDbToKeyMap();

  contents = db.exec("SELECT signature_text FROM signatures");
  signatureNames = contents[0].values.map((v, i) => v[0]);

  contents = db.exec("SELECT id, signature_text FROM signatures");
  signaturesSelectize = dbToJson(contents[0].columns, contents[0].values);

  $('#jstree').jstree(true).refresh();

  contents = db.exec('SELECT meta_id, count(1) AS num FROM crosses GROUP BY meta_id ORDER BY num DESC LIMIT 1');
  var maxCrosses = contents[0].values[0][1];

  contents = db.exec('SELECT DISTINCT id, name from cross_forms ORDER BY name COLLATE NOCASE');
  var allCrossForms = contents[0].values.map((v, i) => ['<option value="'+v[0]+'">'+v[1]+'</option>']);

  contents = db.exec('SELECT DISTINCT id, name from material_types ORDER BY name COLLATE NOCASE');
  var allMaterialTypes = (contents[0].values);
  var materialTypeFilter = {
    id: 'material_type',
    field: 'materialType_id',
    label: 'Material type',
    type: 'string',
    plugin: 'autoComplete',
    plugin_config: {
      minChars: 0,
      delay: 100,
      source: function (term, suggest) {
        var matches = [];
        for (i = 0; i < allMaterialTypes.length; i++) {
          if (allMaterialTypes[i][1].startsWith(term))
            matches.push(allMaterialTypes[i][1]);
        }
        suggest(matches);
      }
    },
    operators: ['equal', 'not_equal', 'begins_with', 'not_begins_with', 'contains', 'not_contains',
      'ends_with', 'not_ends_with', 'is_empty', 'is_not_empty'],
  };

  /////////////////////////////////////
  // Initialzie QueryBuilder
  //////////////////////////////////////
  var glob_operators = ['equal', 'not_equal', 'begins_with_glob', "not_begins_with_glob", "contains_glob",
   "not_contains_glob", "ends_with", "not_ends_with", "is_empty", 'is_not_empty', "my_regex", "word_regexp"];
  var queryBuilderFilters = [
    {
      id: 'signature_text',
      field: 'signature_text',
      label: humanNameForColumnName('signature_text'),
      type: 'string',
      plugin: 'autoComplete',
      plugin_config: {
        minChars: 0,
        delay: 50,
        source: function(term, suggest) {
          var matches = [];
          for (i = 0; i < signaturesSelectize.length; i++) {
            if (signaturesSelectize[i].text.startsWith(term)) {
              matches.push(signaturesSelectize[i].text);
              continue;
            }
            // do not do the search if we got a match already
            if (signaturesSelectize[i].normalizedText.startsWith(term)) {
              matches.push(signaturesSelectize[i].text);
              continue;
            }
          }
          suggest(matches);
        },
        menuClass: 'clusterize-content ',
      },
      size: 40,
      operators: ['equal', 'not_equal', 'begins_with', "not_begins_with",
        "contains", "not_contains", "ends_with", "not_ends_with", "my_regex"],
    },
    {
      id: 'signature_country',
      field: 'signature_text',
      label: 'Country or Swedish province',
      type: 'string',
      input: 'select',
      multiple: true,
      operators: ['in'],
      valueSetter: function (rule, value) {
        rule.$el.find('.rule-value-container select')[0].selectize.setValue(value);
      },
      plugin: 'selectize',
      plugin_config: {
        plugins: ['remove_button'],
        options: [
          {text: 'Sweden, whole', v: 'all_sweden'},
          {text: 'Öland (Öl)', v: 'Öl '}, {text: 'Östergötland (Ög)', v: 'Ög '}, {text: 'Södermanland (Sö)', v: 'Sö '},
          {text: 'Småland (Sm)', v: 'Sm '}, {text: 'Västergötland (Vg)', v: 'Vg '}, {text: 'Uppand (U)', v: 'U '},
          {text: 'Västmanland (Vs)', v: 'Vs '}, {text: 'Närke (Nä)', v: 'Nä '}, {text: 'Värmland (Vr)', v: 'Vr '},
          {text: 'Gästrikland (Gs)', v: 'Gs '}, {text: 'Hälsingland (Hs)', v: 'Hs '}, {text: 'Medelpad (M)', v: 'M '},
          {text: 'Ångermanland (Ån)', v: 'Ån '}, {text: 'Dalarna (D)', v: 'D '}, {text: 'Härjedalen (Hr)', v: 'Hr '},
          {text: 'Jämtland (J)', v: 'J '}, {text: 'Lappland (Lp)', v: 'Lp '}, {text: 'Dalsland (Ds)', v: 'Ds '},
          {text: 'Bohuslän (Bo)', v: 'Bo '}, {text: 'Gotland (G)', v: 'G '}, {text: 'Sweden, other (SE)', v: 'SE '},
          {text: 'Denmark (DR)', v: 'DR '}, {text: 'Norway (N)', v: 'N '}, {text: 'Faroe Islands (FR)', v: 'FR '},
          {text: 'Greenland (GR)', v: 'GR '}, {text: 'Iceland (IS)', v: 'IS '}, {text: 'Finland (FI)', v: 'FI '},
          {text: 'Shetland (Sh)', v: 'Sh '}, {text: 'Orkney (Or)', v: 'Or '}, {text: 'Scotland (Sc)', v: 'Sc '},
          {text: 'England (E)', v: 'E '}, {text: 'Isle of Man (IM)', v: 'IM '}, {text: 'Ireland (IR)', v: 'IR '},
          {text: 'France (F)', v: 'F '}, {text: 'Netherlands (NL)', v: 'NL '}, {text: 'Germany (DE)', v: 'DE '},
          {text: 'Poland (PL)', v: 'PL '}, {text: 'Latvia (LV)', v: 'LV '}, {text: 'Russia (RU)', v: 'RU '},
          {text: 'Ukraine (UA)', v: 'UA '}, {text: 'Byzantium (By)', v: 'By '}, {text: 'Italy (IT)', v: 'IT '},
          {text: 'Other areas (X)', v: 'X '}],
        valueField: 'v',
        labelField: 'text',
        searchField: 'text',
        sortField: 'text',
        create: false,
        dropdownDirection: 'up',
        maxItems: null,
      },
    },
    prepareAutoComplete('found_location'),
    prepareAutoComplete('parish'),
    prepareAutoComplete('district'),
    prepareAutoComplete('municipality'),
    prepareAutoComplete('current_location'),
    prepareAutoComplete('original_site'),
    prepareAutoComplete('rune_type'),
    prepareAutoComplete('dating'),
    prepareIntegerField('year_from'),
    prepareIntegerField('year_to'),
    prepareAutoComplete('carver'),
    prepareAutoComplete('material'),
    prepareAutoComplete('normalisation_norse', {fieldId: 'normalisation_search_norse', operators: glob_operators}),
    prepareAutoComplete('normalisation_scandinavian', {fieldId: 'normalisation_search_scandinavian', operators: glob_operators}),
    prepareAutoComplete('english_translation'),
    prepareAutoComplete('transliteration', {fieldId: 'search_transliteration', operators: glob_operators}),
    prepareAutoComplete('style'),
    prepareAutoComplete('reference'),
    prepareAutoComplete('additional'),
    prepareAutoComplete('objectInfo'),
    prepareAutoComplete('runes_personalname'),
    prepareBooleanRule({'r':'has_personal_name', 'l':'Has personal name?', 'f':'num_names', 'v':1}),
    {
      id: 'alternatives',
      label: 'Has alternative(s)?',
      type: 'integer',
      input: 'radio',
      field: 'signature_id',
      values: [
          {1: 'Yes'},
          {0: 'No'}
      ],
      default_value: 1,
      operators: ['alternatives_in'],
    },
    prepareBooleanRule({'r':'lost', 'l':'Is lost?'}),
    prepareBooleanRule({'r':'new_reading', 'l':'New reading?'}),
    {
      id: 'num_crosses',
      label: 'Number of crosses',
      type: 'integer',
      input: 'number',
      validation: {
        min: 0,
        max: maxCrosses,
        step: 1,
        allow_empty_value: false,
      },
      default_value: 0,
      operators: ['equal', 'not_equal', 'less', 'less_or_equal', 'greater', 'greater_or_equal',
        'between', 'not_between'],
      size: 10,
    },
    {
      id: 'cross_form',
      label: 'Cross form',
      type: 'string',
      operators: ['cross_form'],
      input: function (rule, name) {
        //let $container = rule.$el.find('.rule-value-container');
        return '\
          <select name="'+name+'_1">\
          ' + allCrossForms +
          '</select>\
          <div>Certain?\
            <label><input type="radio" name="'+name+'_2" value="0">No</label>\
            <label><input type="radio" name="'+name+'_2" value="1" checked>Yes</label>\
          </div>';
      },
      valueGetter: function (rule) {
        let val1 = rule.$el.find('.rule-value-container [name$=_1]').val();
        let val2 = rule.$el.find('.rule-value-container [name$=_2]:checked').val();
        return {form: val1, is_certain: val2};
      },
      valueSetter: function (rule, value) {
        $(rule.$el.find('.rule-value-container [name$=_1]')[0]).val(value.form);
        var certainControls = rule.$el.find('.rule-value-container [name$=_2]');
        if (value.is_certain == '1') {
          $(certainControls[0]).prop('checked', false);
          $(certainControls[1]).prop('checked', true);
        } else {
          $(certainControls[0]).prop('checked', true);
          $(certainControls[1]).prop('checked', false);
        }
      },
    },
    materialTypeFilter,
    prepareBooleanRule({'r':'ornamental', 'l':'Is pure ornamental?', 'v': 1}),
  ];

  // Fix for Selectize
  $('#builder').on('afterCreateRuleInput.queryBuilder', function(e, rule) {
    if (rule.filter.plugin == 'selectize') {
      rule.$el.find('.rule-value-container').css('min-width', '200px')
        .find('.selectize-control').removeClass('form-control');
    }
  });

  $('#builder').queryBuilder({
    display_empty_filter: false,
    select_placeholder: '!!! Click here to choose search parameter !!!',
    operators: $.fn.queryBuilder.constructor.DEFAULTS.operators.concat([
      { type: 'alternatives_in',  nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'cross_form', nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'begins_with_glob',      nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'not_begins_with_glob',  nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'contains_glob',  nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'not_contains_glob',  nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'my_regex', nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'word_regexp', nb_inputs: 1, multiple: false, apply_to: ['string'] },
    ]),

    lang: {
      operators: {
        alternatives_in: ' ',
        cross_form: ' ',
        begins_with_glob: "begins with",
        not_begins_with_glob: "doesn't begin with",
        contains_glob: "contains",
        not_contains_glob: "doesn't contain",
        my_regex: 'matches expression',
        word_regexp: 'matches across words',
      },
      add_rule: 'Add search parameter',
      add_group: 'Add search group',
    },

    // SQL export (first half)
    sqlOperators: {
      alternatives_in: { op: 'IN' },
      cross_form: { op: 'IN' },
      //like_glob: {op: 'GLOB'},
      begins_with_glob: {op: 'GLOB ?', mod: '{0}*'},
      not_begins_with_glob: {op: 'NOT GLOB ?', mod: '{0}*'},
      contains_glob: { op: 'GLOB ?', mod: '*{0}*'},
      not_contains_glob: { op: 'NOT GLOB ?', mod: '*{0}*'},
      my_regex: { op: 'REGEXP ?', mod: '{0}'},
      word_regexp: { op: 'wordRegexp(?)', mod: '{0}'},
    },
    plugins: {
      'bt-tooltip-errors': null,
      'sortable': null,
      'not-group': null,
      'bt-selectpicker': {liveSearch: true, liveSearchStyle: 'startsWith'},
    },

    filters: queryBuilderFilters,
    sort_filters: true,
    templates: {
      group: gBuilderCustomGroup,
    },
  })
  // SQL export (second half)
  .on('ruleToSQL.queryBuilder.filter', function (e, rule, sqlValue, sqlOperator) {
    if (rule.operator === 'alternatives_in') {
      if (rule.value == 1) {
        e.value = rule.field + ' ' + sqlOperator() + ' signatures_with_children';
      } else {
        e.value = rule.field + ' IN root_signatures and ' + rule.field +
          ' NOT ' + sqlOperator() + ' signatures_with_children';
      }
    }
    if (rule.operator === 'cross_form') {
      e.value = 'id IN (SELECT meta_id FROM crosses WHERE crosses.id in (SELECT cross_id FROM cross_definitions WHERE form_id="' + rule.value[0].form + '" AND is_certain="' + rule.value[0].is_certain + '"))';
    }
    if (rule.id === 'material_type') {
      e.value = rule.field + ' IN (SELECT id FROM material_types WHERE name ' + sqlOperator(sqlValue) + ')';
    }
    if (rule.id === 'signature_country') {
      e.value = "(" + rule.value.map(function (v, i) { return rule.field + " LIKE ('"+v+"%')"; }).join(' OR ') + ")";
    }
    if (rule.id === 'has_personal_name') {
      if (rule.value == 1) {
        e.value = rule.field + '> 0';
      } else {
        e.value = rule.field + '= 0';
      }
    }
    if (rule.id === 'signature_text') {
      if (rule.operator === 'my_regex') {
        var csvData = Papa.parse(sqlValue, {
          delimiter: '|',
        });
        var numEntries = csvData.data[0].length;
        if (numEntries > 1) {
          sqlValue = sqlValue.replace(/\\"/g, '"'); // unescape values
          // trim individual signatures
          var values = [];
          for (var i = 0; i < numEntries; i++) {
            var signature = csvData.data[0][i].trim();
            values.push(signature);
          }
          sqlValue = values.join('|');
        }
      }
      e.value = 'signature_id IN (SELECT id FROM signatures WHERE ' + rule.field + ' ' + sqlOperator(sqlValue) + ' OR id IN (SELECT parent_id FROM signatures WHERE '
      + rule.field + ' ' + sqlOperator(sqlValue) + '))';
    }
    if (sqlOperator().indexOf('REGEXP') != -1) {
      // Let's convert it to a function call. A better approach might exist,
      // see ruleExpression in query-builder.standalone.js
      e.value = `regexp(${sqlValue}, ${rule.field}) == 1`;
    }
    if (sqlOperator().indexOf('wordRegexp') != -1) {
      e.value = `wordRegexp(${sqlValue}, ${rule.field}, id, '${rule.field}') == 1`;
    }
  })
  ;

  // if (!window.Selectize.prototype.positionDropdownOriginal) {
  //   window.Selectize.prototype.positionDropdownOriginal = window.Selectize.prototype.positionDropdown;
  //   window.Selectize.prototype.positionDropdown = function () {
  //     this.settings.dropdownDirection = 'up';
  //     if (this.settings.dropdownDirection === 'up') {
  //       let $control = this.$control;
  //       let offset = this.settings.dropdownParent === 'body' ? $control.offset() : $control.position();

  //       this.$dropdown.css({
  //         width: $control.outerWidth(),
  //         top: offset.top - this.$dropdown.outerHeight(),
  //         left: offset.left
  //       });
  //       this.$dropdown.addClass('direction-' + this.settings.dropdownDirection);
  //       this.$control.addClass('direction-' + this.settings.dropdownDirection);
  //       this.$wrapper.addClass('direction-' + this.settings.dropdownDirection);
  //     } else {
  //       window.Selectize.prototype.positionDropdownOriginal.apply(this, arguments);
  //     }
  //   };
  // }

  // button handlers
  $('#btnApplyDisplayFormat').on('click', onDisplayFormatClicked);
  $('#chkShowSelectedInscriptions').on('change', function() {
    clearMarkers();
    makeMarkers();
  });

  // seems that the data has been loaded. Do not need this timer any more.
  clearTimeout(gLoadingTimer);
}

function dismissAlert() {
  if ($('#alertObj').is(":visible")) {
    $('#alertObj').hide(500);
  }
}
// Data provider for jsTree.
function fetchTreeData(obj, cb) {
  if (obj.id === '#') {
    if (db === null) {
        // we need to load the database first
        return;
    }

    cb.call(this, gRootsJson);
  }
}

function displaySignatureInfo() {
  let indices = $('#jstree').jstree(true).get_selected();
  if (indices.length == 0)
    return;

  if (gRenderInProgress) {
    gRenderInProgress = false;
    setTimeout(displaySignatureInfo, 300);
    return;
  }
  let mainDisplayDom = document.getElementById('mainDisplay');
  mainDisplayDom.innerHTML = "<img src='{% static 'runes/jstree/themes/default/throbber.gif' %}'><br>";
  gRenderInProgress = true;
  setTimeout(renderSignatures, 100);
}

function renderSignatures() {
  if (!gRenderInProgress)
    return;

  let html = inscriptions2markup();
  let mainDisplayDom = document.getElementById('mainDisplay');
  mainDisplayDom.innerHTML = html;
  gRenderInProgress = false;
}

/* Once db is loaded convert all content to key-value object
*/
function convertDbToKeyMap() {
  // Get all displayable column names and convert them to comma-separated string
  let allDisplayColumns = displayFields();
  allDisplayColumns.unshift({value: 'latitude', text: 'latitude'});
  allDisplayColumns.unshift({value: 'longitude', text: 'longitude'});
  allDisplayColumns.unshift({value: 'signature_id', text: 'some'});
  allDisplayColumns.unshift({value: 'id', text: 'meta_id'});

  allDisplayColumns = allDisplayColumns.reduce(function (result, field) {
    if (field.value === 'images' || field.value === 'crosses')
      return result;

    if (field.value !== 'images') {
      result.push(field.value);
    }
    return result;
  }, []);

  let contents = db.exec("SELECT " + allDisplayColumns + " FROM all_data");
  let allRows = contents[0].values;
  let dbMap = {};
  let columns = contents[0].columns;
  let signatureColumn = columns.indexOf('signature_text');
  let metaColumn = columns.indexOf('id');
  let numCrossesColumn = columns.indexOf('num_crosses');
  let latitudeColumn = columns.indexOf('latitude');
  let longitudeColumn = columns.indexOf('longitude');
  let signatureIdColumn = columns.indexOf('id'); // it is actually meta ID

  let customColumns = ['transliteration', 'english_translation', 'normalisation_scandinavian', 'normalisation_norse'];

  for (var i = 0; i < allRows.length; i++) {
    let row = allRows[i];
    let rowObj = {};
    let signatureId = row[signatureIdColumn];

    for (var j = 0; j < allDisplayColumns.length; j++) {
      let columnName = allDisplayColumns[j];

      // we need to skip some columns
      if (columnName === 'signature_id'
          || columnName === 'latitude'
          || columnName === 'longitude')
        continue;

      let humanName = humanNameForColumnName(columnName);
      let columnData = row[j];

      //columnData = escapeHtml(columnData);

      if (columnName === 'signature_text') {
        if (signatureId in gAliasByParent) {
          columnData += ' (' + gAliasByParent[signatureId].join('|') + ')';
          rowObj['aliases'] = gAliasByParent[signatureId].join(';');
        } else {
          rowObj['aliases'] = '';
        }
      }

      rowObj[columnName] = columnData;
      rowObj[columnName + 'html'] = escapeHtml(columnData);
    }

    /////////////////////////////////////
    // fill in images
    let directImagesQuery = db.exec("SELECT id, link_url, direct_url FROM runes_imagelink WHERE "
      + "direct_url <> '' AND meta_id = " + row[metaColumn] + " LIMIT 9");
    let indirectImagesQuery = [];
    let directImagesValue = [];
    let indirectImagesValue = [];

    if (directImagesQuery.length > 0) {
      let ids = directImagesQuery[0].values.map((v, i) => v[0]);
      ids = ids.join(',');
      indirectImagesQuery = db.exec("SELECT link_url, direct_url FROM runes_imagelink WHERE meta_id = '" + row[metaColumn] + "' AND id NOT IN (" + ids + ")");
      directImagesValue = directImagesQuery[0].values;
    } else {
      indirectImagesQuery = db.exec("SELECT link_url, direct_url FROM runes_imagelink WHERE meta_id = '" + row[metaColumn] + "'");
    }

    if (indirectImagesQuery.length > 0) {
      indirectImagesValue = indirectImagesQuery[0].values;
    }

    let allImagesQuery = db.exec("SELECT link_url FROM runes_imagelink WHERE meta_id = " + row[metaColumn]);
    let allImages = [];
    if (allImagesQuery.length > 0) {
      allImages = allImagesQuery[0].values;
    }

    rowObj['directImages'] = directImagesValue;
    rowObj['indirectImages'] = indirectImagesValue;
    let indirectImages = 'No images.';
    if (rowObj['indirectImages'].length > 0) {
      indirectImages = '<ul>';
      rowObj['indirectImages'].map(function (v, i) {
        indirectImages += `<li><a href="${v[0]}" contentEditable="false" target="_blank">${v[0]}</a></li>`;
      });
      indirectImages += '</ul>';
    }
    rowObj['indirectImageshtml'] = indirectImages;
    rowObj['images'] = allImages;

    // make image gallery of direct image links
    let directImages = '';
    if (rowObj['directImages'].length > 0) {
      directImages = '<div class="container-fluid"><div class="row">';
      rowObj['directImages'].map(function (v, i) {
          if (i % 3 == 0) {
            directImages += "</div>";
            if (i < 9)
              directImages += '<div class="row">';
          }
          directImages += `<div class="col-md-4"><a href="${v[1]}" contentEditable="false" target="_blank"><img src="${v[2]}" class="img-responsive"></a></div>`;
      });
      directImages += '</div></div>';
    }
    rowObj['directImageshtml'] = directImages;
    /////////////////////////////////////

    /////////////////////////////////////
    // fill in crosses
    let numCrosses = row[numCrossesColumn];
    if (numCrosses > 0) {
      rowObj['crosses'] = crossesForMeta(row[metaColumn]);
    } else {
      rowObj['crosses'] = [];
    }
    /////////////////////////////////////

    rowObj['signature_text_raw'] = row[signatureColumn];
    rowObj['latitude'] = row[latitudeColumn];
    rowObj['longitude'] = row[longitudeColumn];

    dbMap[signatureId] = rowObj;
  }

  return dbMap;
}

function clearMarkers() {
  markers.clearLayers();
}

function makeMarkers() {
  let markersLatLon = [];
  let sourceObj = gRootsJson;

  const showSelected = $('#chkShowSelectedInscriptions').is(':checked');
  if (showSelected) {
    console.log('Need to show selected only');
    let indices = $('#jstree').jstree(true).get_selected();
    if (indices.length == 0) {
      return;
    }
    sourceObj = [];
    for (let i = 0; i < indices.length; i++) {
      let needle = parseInt(indices[i], 10);
      if (gRootIds.has(needle)) {
        let idx = gRootIds.get(needle);
        sourceObj.push(gRootsJson[idx]);
      }
    }
  }

  for (let i = 0; i < sourceObj.length; i++) {
    let signatureName = sourceObj[i].signature;
    let marker = '';
    let row = sourceObj[i].id;
    let inscriptionData = gDbAsMap[sourceObj[i].id];

    if (row in mapMarkers) {
      marker = mapMarkers[row];
    } else {
      let lat = parseFloat(inscriptionData.latitude);
      let lon = parseFloat(inscriptionData.longitude);
      if ((!isNaN(lat) && !isNaN(lon)) && (lat != 0 && lon != 0)) {
        marker = new MarkerWithData([lat, lon], {
          signature: signatureName,
          id: gRootsJson[i].id,
        });
        let popupText = "<b>" + signatureName + "</b>";
        //marker.bindPopup(popupText);
        marker.bindTooltip(signatureName, {permanent: true});
        mapMarkers[row] = marker;
      }
    }

    if (marker instanceof Object) {
      markers.addLayers(marker);
      markersLatLon.push(marker.getLatLng());
    }
  }

  if (markersLatLon.length > 0) {
    let markersBounds = L.latLngBounds(markersLatLon);
    myMap.fitBounds(markersBounds);
  }
  return markersLatLon;
}

/* Scroll to a signature selected in jsTree or simply to 0 top offset
 */
function scrollToSelectedSignature() {
  var nodes = $('#jstree').jstree(true).get_selected(true);
  if (nodes === undefined || nodes.length == 0) {
    gMainScrollArea.scrollTop = 0;
    hideLoading();
    return;
  }

  scrollToInscription(nodes[0].original.signature, nodes[0].id, true);
}

/* Scroll main display so that it shows the desired inscription.
 * signature is a textual signature, i.e. 'IR 3'
 * inscriptionId is a corresponding DB row ID. For example, 5.
 * updateTree is true or false. True - scrolls jsTree as well.
 */
function scrollToInscription(signature, inscriptionId, updateTree) {
  var section = document.getElementById(signature);
  if (section) {
    gMainScrollArea.scrollTop = section.offsetTop;
  } else {
  var el = document.getElementById(inscriptionId + '_anchor');
    if (el) {
      $('#jstree').scrollTop(el.offsetTop);
    }

    $('#jstree').jstree(true).deselect_all();
    $('#jstree').jstree(true).select_node(inscriptionId);
  }
}

// Next step in scrolling: determine which direction shall be scroll to
function scrollToInscriptionStep2(rowClicked, signature, inscriptionId, updateTree) {
  var visibleNodes = $('#mainDisplay > .inscription-section');
  var firstVisibleId = document.getElementById($(visibleNodes[0]).attr('dbId'));
  var rowVisible = $('.jstree-node').index(firstVisibleId);

  if (rowVisible > rowClicked)
    gClusterizeParams.direction = 'down';
  if (gMainClusterize.getRowsAmount() > 3000) {
    gClusterizeParams.seekFactor = 60;
  }

  scrollToInscriptionStep3(signature, inscriptionId, updateTree);
}

// Next step - scroll more in the desired direction
function scrollToInscriptionStep3(signature, inscriptionId, updateTree) {
  var shift = gMainClusterize.options.cluster_height * 0.5;
  if (gClusterizeParams.direction === 'down')
    shift = shift * -1;
  var newTop = gMainScrollArea.scrollTop + shift;
  gMainScrollArea.scrollTop = newTop;
  gClusterizeParams.iteration++;

  setTimeout(scrollToInscription, 2, signature, inscriptionId, updateTree);
}

// Get all inscriptions from jsTree and convert it to array of HTML tags,
// which are ready for rendering.
function inscriptions2markup() {

  // array of all inscription IDs/signatures
  let signatures = $('#jstree').jstree(true).get_selected();

  // array of all inscription IDs/signatures
  //let signatures = gRootsJson.map((obj, i) => obj.id);;

  // we have no nodes in the tree
  if (signatures.length == 0)
    return [];

  const showHeaders = $('#chkDisplayHeaders').is(":checked");

  let markupData = [];

  for (let i = 0; i < signatures.length; i++) {
    let signatureId = signatures[i];

    let inscriptionData = gDbAsMap[signatureId];
    let signatureName = inscriptionData['signature_text_raw'];

    let paragraph = `<article signature="${signatureName}" id="${signatureName}" dbId="${signatureId}" class="inscription-section">`;

    for (let j = 0; j < userSelectedDisplay.length; j++) {
      let columnName = userSelectedDisplay[j];
      let humanName = humanNameForColumnName(columnName);
      let columnData = '';
      if (columnName in inscriptionData)
        columnData = inscriptionData[columnName + 'html'];

      if (showHeaders) {
        paragraph += '<h4>' + humanName + '</h4>';
      } else if (paragraph.length > 0 && columnData !== '') {
        paragraph += '<br>';
      }

      //columnData = escapeHtml(columnData);

      if (columnName === 'images') {
        if (inscriptionData['directImages'].length == 0) {
          paragraph += inscriptionData['indirectImageshtml'];
          continue;
        }
        paragraph += inscriptionData['directImageshtml'];
        if (inscriptionData['indirectImages'].length > 0) {
          // add image links as they have not been added yet
          paragraph += '<br>' + inscriptionData['indirectImageshtml'];
        }

        continue;
      }

      if (jQuery.inArray(columnName, customColumns) != -1) {
        let cssStyle = 'normalization';
        if (~columnName.indexOf('transliteration')) {
          cssStyle = 'transliteration';
        } else if (~columnName.indexOf('english_translation')) {
          cssStyle = '';
        }

        if (columnName.indexOf('english_translation') == -1
            && gMatchedWordIndices.hasOwnProperty(signatureId)) {
          // this is one of the columns that should have highlighted data

          columnData = columnData.trim();
          // from set with word indices to array
          let matchedWords = [...gMatchedWordIndices[signatureId]];
          // sort in descending order
          matchedWords = matchedWords.sort(function (a, b) { return b - a; } );
          if (columnName.indexOf('transliteration') != -1) {
            // double space have special meaning => it's designates a word that is not
            // present in transliterated text, but is present in other texts. Very important!
            columnData = columnData.replace(/\s{2}/g, ' &nbsp; ');
          }
          let words = getWordBoundaries(columnData, gWordSearchRegexEsc, gWordPunctuationRegexEsc);
          var highlightedStr = columnData;
          for (let k = 0; k < matchedWords.length; k++) {
            let idx = matchedWords[k];
            let wordStart = words[idx].start;
            let wordEnd = words[idx].end;

            if (words[idx].text[0] == '§') {
              // this is a paragraph, do nothing
              continue;
            }

            highlightedStr = columnData.slice(0, wordStart)
              + '<span class="highlighted">'
              + words[idx].text
              + '</span>'
              + highlightedStr.slice(wordEnd);
          }
          columnData = highlightedStr;
        }

        // Smiley is a special symbol: word substitute when word is not present
        // We do not need to show it.
        columnData = columnData.replace(/ ☺ /g, ' ');

        if (~columnData.indexOf(paragraphSymbol)) {
          let parts = columnData.split(paragraphSymbol);
          let listHeader = '';
          listHeader = "Sides or/and reading variants:"

          paragraph += listHeader;
          paragraph += '<ul>';
          for (let k = 0; k < parts.length; k++) {
            let part = parts[k];

            if (!part.trim())
              continue;

            part = paragraphSymbol + part;
            paragraph += '<li><span class="' + cssStyle + '">' + part + '</span></li>';
          }
          paragraph += '</ul>';
        } else {
          // no parts in the columnData
          paragraph += '<span class="' + cssStyle + '">' + columnData + '</span>';
        }
        continue;
      }

      if (columnName === 'crosses') {
        if (inscriptionData.num_crosses == 0) {
          paragraph += 'No crosses.';
          continue;
        }

        paragraph += '<table class="crosses" border="1">';
        paragraph += '<thead><tr>';
        paragraph += '<th>A</th>';
        paragraph += '<th>B</th>';
        paragraph += '<th>C</th>';
        paragraph += '<th>D</th>';
        paragraph += '<th>E</th>';
        paragraph += '<th>F</th>';
        paragraph += '<th>G</th>';
        paragraph += '</th></thead>';
        paragraph += '<tbody>';

        let allCrosses = inscriptionData['crosses'];
        for (let k = 0; k < allCrosses.length; k++) {
          if (allCrosses[k][0].length > 0) {
            // this is a cross from undefined group
            paragraph += '<tr><td colspan="7">' + allCrosses[k][0][0].name + '</td></tr>';
            continue;
          }
          paragraph += '<tr>';
          // we have 8 groups in total, 0 being free-text and not a real group
          for (let gr = 1; gr < 8; gr++) {
            let crossForms = allCrosses[k][gr];
            if (crossForms.length == 0) {
              paragraph += '<td><span class="null">&#8709;</span></td>';
              continue;
            }
            paragraph += '<td>';
            paragraph += allCrosses[k][gr].map(function (v, i) {
              let url = staticBase + v.name + '.png';
              let res = '<img src="' + url + '" alt="'+v.name+'" title="'+v.name+'" width="32" height="32">';
              if (v.isCerain == 0) {
                res += '?';
              }
              return res;
            }).join(', ');
            paragraph += '</td>';
          }
        }
        paragraph += '</tbody></table>';
        continue;
      }

      if (columnData == '' && showHeaders) {
        columnData = '<i>Absent, not in the database.</i>';
      }
      paragraph += columnData;
    }
    paragraph += '</article>';

    markupData.push(paragraph);
  }

  return markupData;
}

/* Find all crosses related to particular metaId.
 * Returned variable is a multidimensional array. Dimensions:
 * 1. First dimension contains individual crosses.
 * 2. Second dimension denotes cross form group. There could only be 8 groups.
 * 3. Third dimension contains objects with 2 data fields (name, isCertain). Each object represents a particular cross form in a group.
 *    Note that some groups can be empty.
 */
function crossesForMeta(metaId) {
  // we do not check that this meta contains any crosses. This should be done in parent call
  let cc = db.exec("SELECT id FROM crosses WHERE meta_id = '" + metaId + "'");
  let contents = db.exec("SELECT cross_id, cross_forms.id, cross_forms.name, cross_forms.group_id, cross_definitions.is_certain FROM cross_definitions INNER JOIN cross_forms ON (cross_definitions.form_id = cross_forms.id) WHERE cross_id IN (SELECT id FROM crosses WHERE meta_id = '" + metaId + "') ORDER BY cross_id");
  if (!contents)
    return [];

  let lastCrossId = -1;
  let crosses = [];

  for (let i = 0; i < contents[0].values.length; i++) {
    let crossId = parseInt(contents[0].values[i][0], 10);
    if (crossId != lastCrossId) {
      lastCrossId = crossId;
      crosses.push(Array.apply(null, Array(8)).map(function() {return [];}));
    }

    let formName = contents[0].values[i][2];
    let groupId = contents[0].values[i][3];
    let isCertain = contents[0].values[i][4];

    crosses[crosses.length - 1][parseInt(groupId, 10)].push({name: formName, isCertain: isCertain});
  }
  return crosses;
}

function displayFields() {
  let displayOptions = [
    {
      value: 'signature_text',
      text: 'Signature',
    },
    {
      value: 'found_location',
      text: 'Found location',
    },
    {
      value: 'parish',
      text: 'Parish',
    },
    {
      value: 'district',
      text: 'District',
    },
    {
      value: 'municipality',
      text: 'Municipality',
    },
    {
      value: 'current_location',
      text: 'Current location',
    },
    {
      value: 'original_site',
      text: 'Original site',
    },
    {
      value: 'parish_code',
      text: 'Parish code',
    },
    {
      value: 'rune_type',
      text: 'Rune type',
    },
    {
      value: 'dating',
      text: 'Dating',
    },
    {
      value: 'year_from',
      text: 'Year (from)',
    },
    {
      value: 'year_to',
      text: 'Year (to)',
    },
    {
      value: 'style',
      text: 'Style',
    },
    {
      value: 'carver',
      text: 'Carver',
    },
    {
      value: 'material',
      text: 'Material',
    },
    {
      value: 'material_type',
      text: 'Material type',
    },
    {
      value: 'objectInfo',
      text: 'Object information',
    },
    {
      value: 'reference',
      text: 'References',
    },
    {
      value: 'additional',
      text: 'Other information',
    },
    {
      value: 'normalisation_norse',
      text: 'Normalization to Old West Norse',
    },
    {
      value: 'normalisation_scandinavian',
      text: 'Normalisation to Old Scandinavian',
    },
    {
      value: 'english_translation',
      text: 'Translation to English',
    },
    {
      value: 'transliteration',
      text: 'Transliterated runic text',
    },
    {
      value: 'num_crosses',
      text: 'Number of crosses',
    },
    {
      value: 'crosses',
      text: 'Cross form',
    },
    {
      value: 'images',
      text: 'Images',
    },
  ];
  let sortOrder = ['signature_text', 'transliteration', 'normalisation_scandinavian', 'normalisation_norse',
    'english_translation', 'found_location', 'parish', 'municipality', 'district', 'current_location',
    'original_site', 'images', 'rune_type', 'carver', 'num_crosses', 'crosses', 'dating', 'style',
    'material_type', 'material', 'objectInfo', 'reference', 'additional'];
  let sortValue = 1;
  if (storageAvailable('localStorage'))
  {
    var storage = window['localStorage'];
    if (storage.getItem(gUserSelectedDisplayKey)) {
      var savedItems = JSON.parse(storage.getItem(gUserSelectedDisplayKey));
      savedItems.forEach(function (val) {
        let idx = displayOptions.findIndex(o => o.value === val);
        if (idx != -1) {
          displayOptions[idx].sortValue = sortValue++;
        }
      });
    }
  }
  sortOrder.forEach(function (val) {
    let idx = displayOptions.findIndex(o => o.value === val);
    if (idx != -1 && !displayOptions[idx].hasOwnProperty('sortValue')) {
      displayOptions[idx].sortValue = sortValue;
      sortValue += 1;
    }
  });
  return displayOptions;
}

function humanNames() {
  let namesMap = [
    {
      value: 'runes_personalname',
      text: 'Personal Name'
    },
    {
      value: 'search_transliteration',
      text: 'Transliterated runic text'
    },
    {
      value: 'normalisation_search_norse',
      text: 'Normalization to Old West Norse'
    },
    {
      value: 'normalisation_search_scandinavian',
      text: 'Normalisation to Old Scandinavian'
    },
  ];
  return namesMap;
}

function humanNameForColumnName(columnName) {
  let a = displayFields().find(x => x.value === columnName);
  if (a) {
    return a.text;
  }
  a = humanNames().find(x => x.value === columnName);
  if (a) {
    return a.text;
  }
  return columnName;
}

function initMultiselect() {
  var displayOptions = displayFields();

  $.each(displayOptions, function (i, item) {
      if (jQuery.inArray(item.value, userSelectedDisplay) != -1) {
        $('#multiselect_to').append($('<option>', {
            value: item.value,
            text : item.text,
            sortValue: item.sortValue,
        }));
        return;
      }
      $('#multiselect').append($('<option>', {
          value: item.value,
          text : item.text,
          sortValue: item.sortValue,
      }));
  });

  $('#multiselect').multiselect({
    keepRenderingSortRight: false,
    skipInitSortRight: false,
    sort: {
      left: function (a, b) {
        aValue = parseInt($(a).attr('sortValue'));
        bValue = parseInt($(b).attr('sortValue'));

        return aValue > bValue ? 1 : -1;
      },
      right: function (a, b) {
        aValue = parseInt($(a).attr('sortValue'));
        bValue = parseInt($(b).attr('sortValue'));

        return aValue > bValue ? 1 : -1;
      }
    },
    afterMoveUp: () => resortDisplayOptions(),
    afterMoveDown: () => resortDisplayOptions(),
    afterMoveToRight: () => resortDisplayOptions(),
    afterMoveToLeft: () => resortDisplayOptions(),
  });
  formatDialog = $('#divFormatDialog');
}

/*
 * Preserve the sorting after user interacts with the display options
 */
function resortDisplayOptions()
{
  var newSort = 0;
  $('#multiselect_to option').each(function() { $(this).attr('sortValue', newSort++); });
  $('#multiselect option').each(function() { $(this).attr('sortValue', newSort++); });
  saveUserSelectedDisplay();
}

function setTooltip(btn, message) {
  let that = $(btn);
  that.attr('data-original-title', message).tooltip('show');
  // do not care about multiple calls to setTimeout
  setTimeout(function() {
    that.tooltip('hide');
  }, 900);
}

function doSearch() {
  if (applyFilters()) {
    clearMarkers();
    makeMarkers();

    // skip_loading, forget_state
    $('#jstree').jstree(true).refresh(false, true);

    displayStatistics();
  }
}

function selectFirstSignature() {
  let root = $('#jstree').jstree(true).get_node('#');
  $('#jstree').jstree(true).select_node(root.children[0]);
}

// Import list of signatures provided from a file
// Function argument fileContent is the actual file content.
function importSignaturesHandler(fileContent) {
  if (fileContent === null) {
    return;
  }
  if (/[\x00-\x08\x0E-\x1F]/.test(fileContent)) {
    alert("Seems like the file you've selected is not textual. Please select a different file.");
    hideLoading();
    return;
  }

  var csvData = Papa.parse(fileContent);
  var numLines = csvData.data.length;
  let firstDataRow = 0;
  let signatureColumn = 0;
  let multiline = false;
  let numEntries = 0;
  let values = [];

  if (numLines > 1) {
    let signatureCandidate = csvData.data[0].findIndex(item => 'signature' === item.toLowerCase());
    if (signatureCandidate != -1) {
      firstDataRow = 1;
      signatureColumn = signatureCandidate;
    }

    numEntries = csvData.data.length;
    for (var i = firstDataRow; i < numEntries; i++) {
      // iterate over rows
      values.push(csvData.data[i][signatureColumn]);
    }
  } else {
    // single line, treat every value as a signature
    numEntries = csvData.data[0].length;
    for (var i = 0; i < numEntries; i++) {
      // iterate over columns
      values.push(csvData.data[0][i]);
    }
  }

  var rule = [{
    id: "signature_text",
    field: "signature_text",
    type: "string",
    input: "text",
    operator: "my_regex",
    value: values.join('$|') + '$',
  }];

  var allRules = {
    condition: 'OR',
    rules: rule,
    not: false,
  };

  $('#builder').queryBuilder('setRules', allRules, true);
  doSearch();
  hideLoading();
}

function showLoading() {
  $('#loading').show();
}

function hideLoading() {
  $('#loading').hide();
}

var clipboard = [];
$(function() {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', "{% static 'runes/runes.sqlite3' %}?v=1.1.4", true);
  xhr.responseType = 'arraybuffer';
  xhr.addEventListener("load", onDbLoaded);
  xhr.send();
  // hideLoading();

  initMultiselect();
  formatDialog.hide();
  $('#alertObj').hide();

  $('.clip').each(function (i) {
    // prepare buttons for clipboard library
    $(this).attr('data-clipboard-text', $(this).html());
  });
  $('.clip').tooltip({
    container: 'body',
    placement: 'bottom',
    title: 'Copied123!',
    trigger: 'manual',
    delay: 10,
  });
  clipboard = new ClipboardJS('.btn');
  clipboard.on('success', function(e) {
    setTooltip(e.trigger, 'Copied to clipboard!');
  });
  clipboard.on('error', function(e) {
    setTooltip(e.trigger, 'Failed!');
  });

  myMap = L.map('mapDisplay', {
    fullscreenControl: true,
  }).setView([56.607512, 16.439838], 8);
  let osmAttrib = '© <a href="https://openstreetmap.org">OpenStreetMap</a> contributors';
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    {
      maxZoom: 18,
      attribution: osmAttrib
    }
  ).addTo(myMap);
  markers = L.markerClusterGroup({
    showCoverageOnHover: true,
    chunkedLoading: true,
    maxClusterRadius: 60,
  });
  markers.on('click', function (a) {
    scrollToInscription(a.layer.options.signature, a.layer.options.id);
  });
  markers.addTo(myMap);
  myMap.on('fullscreenchange', function () {
    gMainClusterize.refresh();
    if (!myMap.isFullscreen()) {
      gMainScrollArea.scrollTop = 0;
    }
  });

  // Next phase, jstree creation/initialization
  $('#jstree')
  .on('ready.jstree', function () {
      // if (gMainClusterize === null) {
      //   gMainClusterize = new Clusterize({
      //     rows: inscriptions2markup(),
      //     scrollId: 'mainScrollArea',
      //     contentId: 'mainDisplay',
      //     callbacks: {
      //       clusterChanged: function () {
      //       }
      //     },
      //   });
      // } else {
      //   gMainClusterize.update(inscriptions2markup());
      // }

      clearMarkers();
      makeMarkers();
      displayStatistics();

      hideLoading();
      // let's check if this is the first time user visits us
      if (document.cookie.split(';').filter((item) => item.includes('visited=')).length == 0) {
        // it is the first time
        var about_url = "{% url 'runes:about' %}";
        $('#alertObj').html('Looks like you are visiting Rundata.info for the first time. If this is the case, then it might be beneficial to read the <a href="http://rundata-net.rtfd.io/" target="_blank">help</a> and visit <a href="' + about_url + '" target="_blank">About</a> page BEFORE you continue!<br>If you have been here before, just ignore this message.<br>This message will disappear in one minute. <a href="#" onclick="dismissAlert(); return false;" title="Click to close this alert">Dismiss this message now!</button>');
        $('#alertObj').show(500);
        setTimeout(dismissAlert, 60000);
        document.cookie = "visited=true; expires=Fri, 31 Dec 9999 23:59:59 GMT";
      }
      $('#jstree').jstree(true).select_node('1');
  })
  .on('refresh.jstree', function() {
      $('#jstree').scrollTop(0);
      selectFirstSignature();
  })
  .on('changed.jstree', function(node, eventObj) {
    if (eventObj.action == 'select_node') {
      if ($('#chkShowSelectedInscriptions').is(':checked')) {
        clearMarkers();
        makeMarkers();
      }
      displaySignatureInfo();
    }
  })
  .jstree({
      'core': {
          'animation': 0,
          'data': fetchTreeData,
          'multiple': true,
      }
  });

  $('#btnClearRules').on('click', function() {
    $('#builder').queryBuilder('reset');
  });

  $('#btnRulesExport').on('click', function() {
    var result = $('#builder').queryBuilder('getRules');

    if (!$.isEmptyObject(result)) {
      $('#ruleIo').val(JSON.stringify(result, null, 2));
    }
  });

  $('#btnRulesImport').on('click', function() {
    var rules = JSON.parse($('#ruleIo').val());
    $('#builder').queryBuilder('setRules', rules, true);
  });

  $('#btnSearch').on('click', function() {
    doSearch();
  });
  $('#btnResetSearch').on('click', function() {
    gRootsJson = gOriginalData;
    gRootIds = gOriginalIds;
    resetSearchStats();
    clearMarkers();
    makeMarkers();

    // skip_loading, forget_state
    $('#jstree').jstree(true).refresh(false, true);

    displayStatistics();
  });

  function onCsvWorkerMessage(e) {
    var csvBody = e.data.csv;
    var columns = e.data.columns;
    var csv = '\ufeff'; // add unicode BOM
    for (var i = 0; i < columns.length; i++) {
      csv += humanNameForColumnName(columns[i]) + ',';
      if (columns[i] === 'signature_text') {
        csv += 'Alternative signatures' + ',';
      }
    }
    csv = csv.slice(0, -1) + '\r\n';
    csv += csvBody;

    var exportedFilename = 'rundata-net_results.csv';
    var blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    if (navigator.msSaveBlob) { // IE 10+
        navigator.msSaveBlob(blob, exportedFilename);
    } else {
      var link = document.createElement("a");
      if (link.download !== undefined) { // feature detection
          // Browsers that support HTML5 download attribute
          var url = URL.createObjectURL(blob);
          link.setAttribute("href", url);
          link.setAttribute("download", exportedFilename);
          link.style.visibility = 'hidden';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
      }
    }
  }

  $('#btnExportResults').on('click', function() {
    var myWorker = new Worker("{% static 'runes/csv.worker.js' %}");
    myWorker.onmessage = onCsvWorkerMessage;
    myWorker.postMessage({
      inscriptions: gDbAsMap,
      rows: gRootsJson,
      columns: userSelectedDisplay.concat(['latitude', 'longitude']),
    });
  });

  let dropArea = document.getElementById('drop-area');
  ;['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    dropArea.addEventListener(eventName, preventDefaults, false)
  })
  ;['dragenter', 'dragover'].forEach(eventName => {
    dropArea.addEventListener(eventName, highlight, false)
  })

  ;['dragleave', 'drop'].forEach(eventName => {
    dropArea.addEventListener(eventName, unhighlight, false)
  })
  dropArea.addEventListener('drop', handleDrop, false)
  document.getElementById('fileElem').addEventListener('change', handleImportWrapper, false);

  function handleDrop(e) {
    let dt = e.dataTransfer;
    let files = dt.files;

    handleFiles(files);
    closeResultsIoModal();
  }
  // Event handler that stops event propagation. Used for drag and drop support
  function preventDefaults (e) {
    e.preventDefault()
    e.stopPropagation()
  }
  function highlight(e) {
    dropArea.classList.add('highlight')
  }

  function unhighlight(e) {
    dropArea.classList.remove('highlight')
  }
  function handleImportWrapper(evt) {
    handleFiles(evt.target.files);
    closeResultsIoModal();

    // reset form, so that we can import the same file again if we need to
    $('form#form-signature-import').get(0).reset();
  }
  function handleFiles(files) {
    //([...files]).forEach(uploadFile)
    if (files.length == 0) {
      return;
    }
    var fileReader = new FileReader();
    var file = files[0]; // be sure to take just a single file
    fileReader.onloadend = function(evt) {
      if (evt.target.readyState == FileReader.DONE) {
        $('#loading-sub-text').html('This dialog will disappear once data is ready');
        showLoading();
        setTimeout(importSignaturesHandler, 10, evt.target.result);
      }
    }
    fileReader.readAsText(file);
  }
  function closeResultsIoModal() {
    var obj = $('#modalResultsIo');
    obj.modal('hide');
  }

  $('#mHideMap').on('click', onHideMapClicked);

});

// 45 sec timeout
var gLoadingTimer = setTimeout(function() {
  if ($('#loading').is(':visible')) {
    $(document.body).html("Seems that something went wrong and the app is not usable. Try to refresh the page or come later.");
    alert('Seems that something went wrong and the app is not usable. Try to refresh the page or come later.');
  }
}, 90000);
//$('#loading').hide();
</script>

</body>
</html>
