{% load static %}
{% load settings %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Rundata.info is a web version of ​​​Scandinavian Runic-text Data Base.">
    <title>Rundata-net</title>
    {% get_from_settings 'USE_GA' as use_ga %}
    {% if use_ga %}
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-116856737-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-116856737-2');
    </script>
    {% endif %}

    <link href="https://netdna.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="{% static 'runes/jstree/themes/default/style.min.css' %}" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.4/dist/leaflet.css"
     integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA=="
     crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css">
    <!--
    <link rel="stylesheet" href="{% static 'runes/css/MarkerCluster.css' %}" />
    <link rel="stylesheet" href="{% static 'runes/css/MarkerCluster.Default.css' %}" />
    -->
    <link rel="stylesheet" href="{% static 'runes/pixabay/jquery.auto-complete.css' %}" />

    <link rel="apple-touch-icon" sizes="180x180" href="{% static 'apple-touch-icon.png' %}">
    <link rel="icon" type="image/png" sizes="32x32" href="{% static 'favicon-32x32.png' %}">
    <link rel="icon" type="image/png" sizes="16x16" href="{% static 'favicon-16x16.png' %}">
    <link rel="mask-icon" href="{% static 'safari-pinned-tab.svg' %}" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#2b5797">
    <meta name="theme-color" content="#ffffff">

    <style type="text/css">
      .my-fixed-height {
        max-height: 500px;
        min-height: 500px;
        height: 500px;
        margin-bottom: 15px;
      }
      .jstree-scrollable {
        overflow-y: scroll;
        max-height: 100%;
        height: 100%;
      }
      .border-1 {
        border: 1px solid #ccc;
      }
      .group-full-height {
        max-height: 100%;
        min-height: 100%;
        height: 100%;
      }
      .border-left-bottom {
        border-left: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
      }
      .border-bottom-right {
        border-right: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
      }
      .border-bottom {
        border-bottom: 1px solid #ccc;
      }
      body {
        font-family: 'Lucida Grande', 'Lucida Sans Unicode', 'Lucida Sans', 'DejaVu Sans', Verdana, Helvetica, sans-serif;
      }
      .transliteration {
        font-weight: bold;
      }
      .normalization {
        font-style: italic;
        font-weight: normal;
      }
      th {
        text-align: center;
      }
      span.null {
        font-weight: bold;
        color: #CCCCCC;
      }
      .white-text {
        color:#fff!important;
      }
      .navbar-static-top {
        margin-bottom: 0px;
      }

      .vertical-align {
        display: flex;
        align-items: center;
      }
      .inscription-section {
        border-bottom: 2px solid #999;
      }
      .search-status {
        padding-left: 10px;
      }
      .zero-padding-left {
        padding-left: 0px;
      }
      .highlighted {
        color: red;
      }
      .top-margin {
        margin-top: 5px;
      }
      /**********************************
       * drop area styles
       **********************************/
      #drop-area {
        border: 2px dashed #dcc896;
        border-radius: 20px;
        /*margin: auto;*/
        margin-bottom: 20px;
        padding: 20px;
      }
      #drop-area.highlight {
        border-color: green;
      }
      .my-form {
        margin-bottom: 10px;
      }
      .my-form p {
        margin-top: 0;
      }
      .my-form .button {
        display: inline-block;
        padding: 10px;
        background: #fff;
        cursor: pointer;
        border-radius: 5px;
        border: 1px solid #ccc;
      }
      .my-form .button:hover {
        background: #ddd;
      }
      #fileElem {
        display: none;
      }
      /********************************
       * drop area styles end
       */
    </style>
  </head>
<body style="">
  <nav class="navbar navbar-default navbar-static-top">
    <div class="container">
      <div class="navbar-header">
        <a class="navbar-brand" href="#">Rundata-net</a>
      </div>
      <ul class="nav navbar-nav navbar-right">
        <li class=""><a href="{% url 'runes:about' %}" target="_blank">About</a></li>
        <li class=""><a href="http://rundata-net.rtfd.io/" target="_blank">Help</a></li>
        <li class=""><a href="{% url 'runes:references' %}" target="_blank">Bibliography</a></li>
      </ul>
    </div>
  </nav>

  <div class="container-fluid">
    <div class="row">
      <div class="col alert alert-danger hidden" role="alert" id="alertObj"></div>
    </div>

    <div class="row">
      <div id="leftPanel" class="col-md-2 col-sm-2 my-fixed-height table-bordered" style="padding: 0;">
        <div class="list-group group-full-height" style="padding-right: 0px; position: relative;">
          <div id="jstree" class="jstree-scrollable"></div>
        </div>
      </div>

      <div id="mainScrollArea" class="clusterize-scroll col-md-6 col-sm-8 table-bordered my-fixed-height">
        <div id="mainDisplay" contentEditable="true" autocomplete="off" autocorrect="off" spellcheck="false" class="clusterize-content">
          <div class="clusterize-no-data">Loading data...</div>
        </div>
      </div>

      <div id="mapDisplay" class="col-md-4 col-sm-2 my-fixed-height"></div>
    </div>
    <div class="row">
      <div class="col search-status" id="lblNumAvailable"></div>
    </div>
    <div class="row">
      <div class="col">&nbsp;</div>
    </div>

    <div class="row" role="group" aria-label="">
      <div class="col-md-offset-2 col-md-3">
        <button type="button" class="col-md-12 btn btn-success" id="btnSearch">Search</button>
      </div>
      <div class="col-md-2">
        <button type="button" class="col-md-12 btn btn-default" id="btnResetSearch">Reset search</button>
      </div>
    </div>

    <form class="row top-margin" role="group">
      <!--<div class="checkbox col-md-2">
        <input type="checkbox" id="chkApplyFilters">
        <label for="chkApplyFilters">Apply filter(s)</label>
      </div>-->
      <div class="col-md-2 zero-padding-left">
        Control buttons:
      </div>
      <div class="col-md-10" aria-label="">
        <div class="btn-group" role="group" aria-label="">
          <button type="button" class="btn btn-default" data-toggle="modal" data-target="#divFormatDialog">Configure main display</button>
          <button type="button" class="btn btn-default" id="btnShowMap">Hide map</button>
        </div>
        <div class="btn-group" role="group" aria-label="">
          <button type="button" class="btn btn-default" id="btnRuleExporter">Show rule manager</button>
          <button type="button" class="btn btn-default" id="btnClearRules">Clear all rules</button>
        </div>
        <div class="btn-group" role="group" aria-label="">
          <button type="button" class="btn btn-default" id="btnImportResults">Show import tool</button>
          <button type="button" class="btn btn-default" id="btnExportResults">Export results</button>
        </div>
      </div>
    </form>

    <section role="group" class="row vertical-align top-margin">
      <div class="col-md-2 zero-padding-left">Copy symbols to clipboard:</div>
      <div class="col-md-10 btn-group" role="group">
        <button type="button" class="btn clip" id="btnOUmlautSmall">ö</button>
        <button type="button" class="btn clip" id="btnOUmlaut">Ö</button>
        <button type="button" class="btn clip" id="btnAaSmall">å</button>
        <button type="button" class="btn clip" id="btnAa">Å</button>
        <button type="button" class="btn clip" id="btnAaUmlautSmall">ä</button>
        <button type="button" class="btn clip" id="btnAaUmlaut">Ä</button>
        <button type="button" class="btn clip" id="btnTh">þ</button>
        <button type="button" class="btn clip" id="btnEn">ñ</button>
        <button type="button" class="btn clip" id="btnDh">ð</button>
        <button type="button" class="btn clip" id="btnDh">ï</button>
        <button type="button" class="btn clip" id="btnAe">æ</button>
        <button type="button" class="btn clip" id="btnAe">Æ</button>
        <button type="button" class="btn clip" id="btnOe">ø</button>
        <button type="button" class="btn clip" id="btnOe">Ø</button>
        <button type="button" class="btn clip" id="btnOe2">œ</button>
        <button type="button" class="btn clip" id="btnOe2">Œ</button>
        <button type="button" class="btn clip" id="btnOhakeSmall">ô</button>
        <button type="button" class="btn clip" id="btnOhakeCapital">Ô</button>
      </div>
    </section>
    <section role="group" class="row"><div class="col">&nbsp;</div></section>

    <section role="dialog" class="row" id="containerImportSignatures">
      <div id="drop-area" class="col-md-8 col-md-offset-1">
        <form class="my-form">
          <div class="form-group">
            <p>Import file with signatures by dragging and dropping or selecting it. Read more about the possible file formats in the documentation.</p>
            <label for="fileElem" class="button">Select a file</label>
            <input type="file" id="fileElem">
          </div>
        </form>
      </div>
    </section>

    <div id="divFormatDialog" class="modal fade bs-example-modal-lg" tabindex="-1" role="dialog" aria-labelledby="divFormatDialogLabel">
      <div class="modal-dialog modal-lg" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title" id="divFormatDialogLabel">Configure inscription display</h4>
          </div>
          <div class="model-body" style="padding-top: 1em; padding-left: 1em; padding-right: 1em;">
            <div class="row" style="padding-left: 1em; padding-right: 1em;">
              <p class="col alert alert-danger hidden" role="alert" id="formatDialogAlertObj"></p>
            </div>
            <div class="row" style="padding-left: 1em; padding-right: 1em;">
              <div class="col"><p>Here you can select which properties are shown on the main display when an inscription is selected. List on the left contains properties available for selection.
              List on the right contains properties selected for display.</p>
              <p>Check <em>Display headers</em> checkbox if you want to see property name as long as it's value. If unchecked, only the value is displayed.</p>
              </div>
            </div>
            <div class="row">
              <div class="col-sm-5">
                <select name="from[]" id="multiselect" class="form-control" size="8" multiple="multiple"></select>
                <div class="row">
                  <form role="form" class="col-sm-6">
                    <div class="checkbox">
                      <input type="checkbox" id="chkDisplayHeaders" checked>
                      <label for="chkDisplayHeaders">Display headers</label>
                    </div>
                  </form>
                </div>
              </div>

              <div class="col-sm-2">
                <button type="button" id="multiselect_rightAll" class="btn btn-block"><i class="glyphicon glyphicon-forward"></i></button>
                <button type="button" id="multiselect_rightSelected" class="btn btn-block"><i class="glyphicon glyphicon-chevron-right"></i></button>
                <button type="button" id="multiselect_leftSelected" class="btn btn-block"><i class="glyphicon glyphicon-chevron-left"></i></button>
                <button type="button" id="multiselect_leftAll" class="btn btn-block"><i class="glyphicon glyphicon-backward"></i></button>
              </div>

              <div class="col-sm-5">
                <select name="to[]" id="multiselect_to" class="form-control" size="8" multiple="multiple"></select>
                <div class="row">
                  <div class="col-sm-6">
                    <button type="button" id="multiselect_move_up" class="btn btn-block"><i class="glyphicon glyphicon-arrow-up"></i></button>
                  </div>
                  <div class="col-sm-6">
                    <button type="button" id="multiselect_move_down" class="btn btn-block"><i class="glyphicon glyphicon-arrow-down"></i></button>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
            <button type="button" class="btn btn-primary" id="btnApplyDisplayFormat">Apply changes</button>
          </div>
        </div>
      </div>
    </div>

    <div id="containerRuleIo" class="row container-fluid">
      <div class="row">
        <div class="col-md-6" style="margin-left: 2%">Use the tool below to preserve your search rules between sessions. Clicking Export will give you
        search rules in text format. You can copy text and save it elsewhere. Next time you load work
        with Rundata-net you can import that text.</div>
      </div>
      <div class="row">
        <div class="col-md-10 btn-group" role="group" aria-label="" style="margin-left: 2%">
          <button type="button" class="btn btn-default" id="btnRulesExport">Export</button>
          <button type="button" class="btn btn-default" id="btnRulesImport">Import</button>
        </div>
      </div>
      <form class="row" style="margin-left: 2%">
        <textarea id="ruleIo" class="col-md-6 col-xs-10" rows="15"></textarea>
      </form>
    </div>

    <div class="row">
      <div id="builder" class="col"></div>
    </div>
    <div class="row">
      <div class="col">&nbsp;</div>
    </div>
    <div class="row">
      <div class="col">&nbsp;</div>
    </div>
    <div class="row">
      <div class="col">&nbsp;</div>
    </div>
    <div class="row">
      <div class="col">&nbsp;</div>
    </div>
    <div class="row">
      <div class="col">&nbsp;</div>
    </div>
    <div class="row">
      <div class="col">&nbsp;</div>
    </div>

  </div>

  <aside id="loading" class="loading-screen" style="position:fixed; top:0; right:0; bottom:0; left:0; z-index:9999; background-color: #000; opacity: 0.6;">
    <div class="col-sm-8 col-sm-offset-2 col-md-6 col-md-offset-3 col-lg-4 col-lg-offset-4" style="position:absolute; top:50%; margin-top:-7em">
      <div class="page-header">
        <i class="text-primary fa fa-spin fa-fw pull-left fa-spinner fa-2x" style="text-shadow: 0px 0px 0ex;"></i>
        <hgroup class="" style="text-shadow: 0px 0px 0ex;">
          <h4 ng-switch-default="" class="white-text" id="loading-main-text">
            Loading<br>
            <small class="white-text" id="loading-sub-text">It can take up to a minute.</small>
          </h4>
        </hgroup>
      </div>
    </div>
  </aside>

<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<!-- query builder styles -->
<!-- <link href="{% static 'query-builder/bootstrap-datepicker3.min.css' %}" rel="stylesheet"> -->
<!-- <link href="{% static 'query-builder/bootstrap-slider.min.css' %}" rel="stylesheet"> -->
<link href="{% static 'query-builder/selectize.bootstrap3.css' %}" rel="stylesheet">
<link href="{% static 'query-builder/bootstrap-select.min.css' %}" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/awesome-bootstrap-checkbox/0.3.7/awesome-bootstrap-checkbox.css" rel="stylesheet">
<link href="{% static 'query-builder/query-builder.default.min.css' %}" rel="stylesheet">
<!--<link href="{% static 'runes/chosen/chosen.min.css' %}" rel="stylesheet">-->
<link href="{% static 'runes/jquery-ui/jquery-ui.min.css' %}" rel="stylesheet">
<!-- end of query builder styles -->

<script>
/**
 * detect IE
 * returns version of IE or false, if browser is not Internet Explorer
 */
function detectIE() {
  var ua = window.navigator.userAgent;

  // Test values; Uncomment to check result …

  // IE 10
  // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';

  // IE 11
  // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';

  // Edge 12 (Spartan)
  // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';

  // Edge 13
  // ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586';

  var msie = ua.indexOf('MSIE ');
  if (msie > 0) {
    // IE 10 or older => return version number
    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
  }

  var trident = ua.indexOf('Trident/');
  if (trident > 0) {
    // IE 11 => return version number
    var rv = ua.indexOf('rv:');
    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
  }

  var edge = ua.indexOf('Edge/');
  if (edge > 0) {
    // Edge (IE 12+) => return version number
    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
  }

  // other browser
  return false;
}

var ieVersion = detectIE();
if (ieVersion !== false && ieVersion <= 12) {
  alert('This version of Internet Explorer is not supported. Please update or use a different browser. Will redirect to About page.');
  window.location.href = "{% url 'runes:about' %}#browser-support";
}
</script>

<script src="https://unpkg.com/clipboard@2.0.0/dist/clipboard.min.js"></script>
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="{% static 'runes/jstree/jstree.js' %}"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bootbox.js/4.3.0/bootbox.min.js"></script>
<script src="{% static 'runes/interact.min.js' %}"></script>
<script src="{% static 'runes/sql.js' %}"></script>

<!-- begin of query builder js -->
<script src="{% static 'query-builder/moment.min.js' %}"></script>
<!-- <script src="{% static 'query-builder/bootstrap-datepicker.min.js' %}"></script> -->
<!--<script src="{% static 'query-builder/bootstrap-slider.min.js' %}"></script>-->
<script src="{% static 'query-builder/selectize.min.js' %}"></script>
<script src="{% static 'query-builder/bootstrap-select.min.js' %}"></script>
<script src="{% static 'query-builder/query-builder.standalone.min.js' %}"></script>
<script src="{% static 'query-builder/interact.min.js' %}"></script>
<!--<script type="text/javascript" src="{% static 'runes/chosen/chosen.jquery.min.js' %}"></script>-->
<script type="text/javascript" src="{% static 'runes/jquery-ui/jquery-ui.min.js' %}"></script>
<!-- end of query builder js -->

<script src="https://unpkg.com/leaflet@1.3.4/dist/leaflet-src.js"
 integrity="sha512-+ZaXMZ7sjFMiCigvm8WjllFy6g3aou3+GZngAtugLzrmPFKFK7yjSri0XnElvCTu/PrifAYQuxZTybAEkA8VOA=="
 crossorigin=""></script>
<script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster-src.js"></script>
<!-- <script src="{% static 'runes/leaflet.markercluster.js' %}"></script> -->

<script src="{% static 'runes/multiselect.min.js' %}"></script>
<script src="{% static 'runes/pixabay/jquery.auto-complete.min.js' %}"></script>
<!-- <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script> -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/clusterize.js/0.18.0/clusterize.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/clusterize.js/0.18.0/clusterize.js"></script>
<script src="{% static 'runes/papaparse.min.js' %}"></script>

<script type="text/javascript">
var entityMap = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '/': '&#x2F;',
  '`': '&#x60;',
  '=': '&#x3D;'
};

function escapeHtml (string) {
  return String(string).replace(/[&<>"'`=\/]/g, function (s) {
    return entityMap[s];
  });
}

// Globals:
// connection to the DB
var db = null;
// original data when no filter is applied.
// Used as cache, so we can skip quering the db again
var gOriginalData = [];
var gRootIds = []; // Map of parent/root inscription IDs
var gRootsJson = []; // JSON representation for gRootIds
var signatureNames = []; // names of all signatures in the DB
var signaturesSelectize = [];
var formatDialog = [];
var userSelectedDisplay = []; // list of user selected fields for display per inscription
var myMap = null; // Global handle to map object
var mapMarkers = {}; // Collection of created map markers. This is used in order to create
  // markers only once.
var markers = []; // Leaflet markers group
// Number of signatures selected by user
var gNumSelectedSignatures = [];
// A flag that indicates if a single inscription rendering is done or still in process.
// When rendering is done, we can render another item.
var gSingleRenderIsDone = false;
var gBatchRenderIsDone = true;
var gStopRendering = false;
var lastShowHeaders = true; // last value of show headers checkbox in display format dialog
var gRegExpMap = {}; // Object of all regex expressions
var gRegExpMapG = {}; // Object of all regex expressions with global flag
var gWordIndices = {}; // Object that contains matched word indices across inscription text.
    // Words in this case are based on values prepared for search.
    // Each entry is an object itself where keys are column names and values
    // are arrays of matched words. Example entry of gWordIndices:
    // {search_transliteration: [1, 3, 5]; normalisation_search_norse: [3];}
var gMatchedWordIndices = {}; // A processed version of gWordIndices. It is a map that provides
    // information which words are matched for particular signature id. Key is signature id,
    // values set of matched word indices.
var gFoundPersonalNames = 0;
var gWordVariants = 0;
// regex that is used to separate words in displayed inscription texts.
//var gWordSearchRegex = new RegExp("((·|:|×|¤|'|\\+|÷|\\s)+|¶+)+", 'g');
var gWordSearchRegex = new RegExp("((\\s+|^(·|:|×|¤|'|\\+|÷|¶))(·|:|×|¤|'|\\+|÷|¶){0,1}\\s*)", 'g');
var gWordSearchRegexEsc = new RegExp(escapeHtml("((\\s+|^(·|:|×|¤|'|\\+|÷|¶))(·|:|×|¤|'|\\+|÷|¶){0,1}\\s*)"), 'g');
var gWordPunctuationRegex = new RegExp("(·|:|×|¤|'|\\+|÷|¶|\\(|\\)|\\[|\\])+");
var gWordPunctuationRegexEsc = new RegExp(escapeHtml("(·|:|×|¤|'|\\+|÷|¶|\\(|\\)|\\[|\\])+"));
// Whenever we need to render a batch of inscriptions, we identify each batch with gRenderBatchId. This can be
// used in situation when we need to render a batch when another batch is still in rendering process.
// I.e. we have batch 1 which is currently rendering. We have batch 2 that shall be rendered. In this case,
// batch 1 must be cancelled.
var gRenderBatchId = 0;
// Global variable that is assigned with timer ID for displaySignatureInfo function call.
// If it is a valid ID, then we must not execute another call to displaySignatureInfo.
// Used to accumulate multiple jstree.changed events.
var gDisplayTimeout = -1;

// Map of aliases. Key is parent ID, value - list of alias names
// parent ID is SQLite index ID, it is not a signature!
var gAliasByParent = {};

// This is a key-value representation of all inscriptions in the database.
// Key is signature (i.e. 'Öl 1'), value is an object where each property is
// one of the displayFields() and value is it's corresponding value.
var gDbAsMap = {};

// Clusterize.js object for main isncription display
var gMainClusterize = null;

var gClusterizeParams = {};
var gMainScrollArea = document.getElementById('mainScrollArea');

// defaults. TODO: should be replaced with reading from local storage memory
userSelectedDisplay = ['signature_text', 'transliteration', 'english_translation', 'found_location',
    'parish', 'municipality', 'district', 'current_location', 'images'];

/////////////////////////////////////
// variables used for rendering. Have it here for speed.
/////////////////////////////////////
var staticBase = "{% static 'runes/images/cross_forms/' %}";
let highlightColumns = ['transliteration', 'normalisation_scandinavian', 'normalisation_norse'];
let customColumns = new Array(...highlightColumns);
customColumns.push('english_translation');
const paragraphSymbol = '§';
const sidesMarker = '§A';
const readingMarker = '§P';

// An extension of Leaflet marker that provides information about inscription
MarkerWithData = L.Marker.extend({
   options: {
      inscription: '',
   }
});

function displayStatistics() {
  var total = gRootsJson.length;
  if (total == 0) {
    $('#lblNumAvailable').html('Sorry, no inscriptions has been found.');
  } else {
    let numWords = 0;
    for (signId in gMatchedWordIndices) {
      numWords += gMatchedWordIndices[signId].size;
    }
    let infoStr = `${gRootsJson.length} inscriptions`;
    numWords -= gWordVariants;
    if (numWords > 0) {
      infoStr += `, ${numWords} words, ${gFoundPersonalNames} personal names`;
    }
    infoStr += '.';
    $('#lblNumAvailable').html(infoStr);
  }
}

function dbToJson(columnNames, values, rootsWithChildren = null) {
  let lostIdx = columnNames.indexOf('lost');
  let newReadingIdx = columnNames.indexOf('new_reading');

  let dbJson = values.map(function(v, i) {
      var hasChildren = false;
      //if (rootsWithChildren !== null && rootsWithChildren.has(v[0])) {
          //hasChildren = true;
      //}

      let additional = '';
      if (lostIdx != -1 && newReadingIdx != -1) {
        let isLost = !!+v[lostIdx];
        let isNewReading = !!+v[newReadingIdx];

        if (isLost) {
          additional += "†";
        }
        if (isNewReading) {
          additional += '$';
        }
        if (additional.length > 0)
          additional = ' ' + additional;
      }

      return {
          id: v[0].toString(),
          text: v[1] + additional,
          normalizedText: v[1].normalize('NFD').replace(/[\u0300-\u036f]/g, ""),
          icon: false,
          children: hasChildren,
          id_numeric: v[0],
          signature: v[1],
      }
  });

  return dbJson;
}

function arraysEqual(a, b) {
  if (a === b) return true;
  if (a == null || b == null) return false;
  if (a.length != b.length) return false;

  for (var i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}

function onDisplayFormatClicked(e) {
  e.preventDefault();

  var selectedValues = [];
  var alertObj = $('#formatDialogAlertObj');
  $('#multiselect_to option').each(function() { selectedValues.push($(this).val()); });
  if (selectedValues === null || selectedValues.length == 0) {
    alertObj.html('Nothing is selected for display! Please select at least one property.');
    alertObj.removeClass('hidden');
    alertObj.addClass('show');
    return;
  }

  if (alertObj.hasClass('show')) {
    alertObj.removeClass('show');
    alertObj.addClass('hidden');
  }

  if (selectedValues.length > 0) {
    const newShowHeaders = $('#chkDisplayHeaders').is(":checked");
    if (!arraysEqual(userSelectedDisplay, selectedValues) || newShowHeaders != lastShowHeaders) {
      userSelectedDisplay = selectedValues;

      //displaySignatureInfo(false);
      $('#loading').show();
      gMainClusterize.update(inscriptions2markup());
      $('#loading').hide();

      lastShowHeaders = newShowHeaders;
    }
  }
  $(this).prev().click();
}

function onShowMapClicked() {
  $('#mapDisplay').toggle();
  if ($('#mapDisplay').is(':visible')) {
    $('#btnShowMap').html('Hide map');
    $('#mainDisplay').removeClass('col-md-10');
    $('#mainDisplay').addClass('col-md-6');
  } else {
    $('#btnShowMap').html('Show map');
    $('#mainDisplay').removeClass('col-md-6');
    $('#mainDisplay').addClass('col-md-10');
  }
}

function selectizeFilter(fieldId) {
  var str = `SELECT DISTINCT ${fieldId} FROM all_data WHERE ${fieldId} NOT NULL AND ${fieldId} <> '' ORDER BY ${fieldId} COLLATE NOCASE;`;
  var contents = db.exec(str);
  var myOptions = contents[0].values.map(function (v) { return {text: v[0]} });

  return {
    id: fieldId,
    field: fieldId,
    label: humanNameForColumnName(fieldId),
    type: 'string',
    plugin: 'selectize',
    plugin_config: {
      valueField: 'text',
      labelField: 'text',
      searchField: 'text',
      sortField: 'text',
      maxItems: 1,
      plugins: ['restore_on_backspace'],
      valueSetter: function (rule, value) {
        rule.$el.find('.rule-value-container input')[0].selectize.setValue(value);
      },
      options: myOptions,
      create: true,
      createOnBlur: true,
      persist: true,
      dropdownDirection: 'up',
    }
  }
}

/* Dictionary with fields:
  .r => rule id, mandatory
  .l => label, mandatory
  .f => field id, optional. If not provided, .r is used.
  .v => default value, optional. If not provided, set to 0.
*/
function prepareBooleanRule(opt) {
  let fieldId = opt.f || opt.r;
  let defaultValue = opt.v || 0;

  return {
    id: opt.r,
    label: opt.l,
    type: 'integer',
    field: fieldId,
    input: 'radio',
    values: [
      {0: 'No'},
      {1: 'Yes'}
    ],
    default_value: defaultValue,
    operators: ['equal'],
  };
}

function prepareAutoComplete(ruleId, opt) {
  if (!opt) opt = {};
  let fieldId = opt.fieldId || ruleId;
  let operators = opt.operators || ['equal', 'not_equal', 'begins_with',
        "not_begins_with", "contains", "not_contains", "ends_with",
        "not_ends_with", "is_empty", 'is_not_empty', "my_regex"];

  let contents = [];
  if (ruleId.indexOf('normalisation') != -1) {
    let str = `SELECT DISTINCT search_value FROM ${ruleId}`;
    contents = db.exec(str);
  } else if (ruleId.indexOf('runes_personalname') != -1) {
    let str = `SELECT DISTINCT value FROM ${ruleId}`;
    contents = db.exec(str);
  } else if (ruleId.indexOf('transliteration') != -1) {
    let str = 'SELECT DISTINCT search_value FROM transliterated_text';
    contents = db.exec(str);
  } else {
    let str = `SELECT DISTINCT ${fieldId} FROM all_data WHERE ${fieldId} NOT NULL AND ${fieldId} <> '' ORDER BY ${fieldId} COLLATE NOCASE;`;
    contents = db.exec(str);
  }

  return {
    id: ruleId,
    field: fieldId,
    label: humanNameForColumnName(fieldId),
    type: 'string',
    plugin: 'autoComplete',
    plugin_config: {
      minChars: 0,
      delay: 100,
      source: function (term, suggest) {
        var matches = [];
        for (i = 0; i < contents[0].values.length; i++) {
          if (contents[0].values[i][0].startsWith(term))
            matches.push(contents[0].values[i][0]);
        }
        suggest(matches);
      },
      menuClass: ' clusterize-content ',
      attachToParent: true,
    },
    size: 70,
    operators: operators,
  }
}

function resetSearchStats() {
  gWordIndices = {};
  gMatchedWordIndices = {};
  gFoundPersonalNames = 0;
  gWordVariants = 0;
}

// Applies user-defined filters in order to obtain valid IDs
// Returns true on success, false on any failure.
//
function applyFilters() {
  var result = $('#builder').queryBuilder('getSQL', false);
  if (!result || !result.sql.length) {
    return false;
  }

  resetSearchStats();

  console.log('Got SQL: ' + result.sql);
  var contents = db.exec("SELECT signature_id, signature_text, lost, new_reading, normalisation_scandinavian FROM all_data WHERE " + result.sql);
  if (contents.length == 0) {
    // no results
    gRootsJson = [];
    return true;
  }

  let signatureIdIdx = contents[0].columns.indexOf('signature_id');
  let normalisationScandinavianIdx = contents[0].columns.indexOf('normalisation_scandinavian');

  if (Object.keys(gWordIndices).length != 0) {
    contents[0].values = contents[0].values.filter(function checkIds(row) {
      id = row[signatureIdIdx];
      normalizedText = row[normalisationScandinavianIdx];

      if (!gWordIndices.hasOwnProperty(id))
        return true;

      let allKeys = Object.keys(gWordIndices[id]);
      let intersection = new Set(gWordIndices[id][allKeys[0]]);
      for (i = 1; i < allKeys.length; i++) {
        if (allKeys[i].indexOf('_par') != -1) {
          continue;
        }
        let b = new Set(gWordIndices[id][allKeys[i]]);
        intersection = new Set([...intersection].filter(x => b.has(x)));
        if (intersection.size == 0) {
          return false;
        }
      }

      let words = getWordBoundaries(normalizedText, gWordSearchRegex, gWordPunctuationRegex);
      let wordVariants = [];
      var counts = {};
      var countsPersonal = {};
      intersection.forEach(function (val) {
        // We do not need to count words that have isVariant > 0.
        // Do not count corresponding personal names
        gFoundPersonalNames += words[val].isPersonal;
        if (words[val].isVariant > 0) {
          let key = words[val].isVariant;
          counts[key] = (counts[key] || 0) + 1;
          if (words[val].isPersonal) {
            countsPersonal[key] = (countsPersonal[key] || 0) + 1;
          } else {
            countsPersonal[key] = (countsPersonal[key] || 0);
          }
        }
      });

      let countValues = [...Object.values(counts)];
      var personalBias = 0;
      if (countValues.length > 0) {
        let minCounts = Math.min(...countValues);
        let minIndex = countValues.indexOf(minCounts) + 1;

        if (!isNaN(minCounts))
          gWordVariants += minCounts * (countValues.length-1);
        if (!isNaN(countsPersonal[minIndex]))
          personalBias += countsPersonal[minIndex] * (countValues.length-1);
      }
      gFoundPersonalNames -= personalBias;

      gMatchedWordIndices[id] = intersection;
      return true;
    });
  }

  // hash map of inscription IDs that have children.
  var rootsWithChildren = db.exec("SELECT * FROM signatures_with_children");
  // make a hash map for quick read access
  rootsWithChildren = new Map(rootsWithChildren[0].values.map((v, i) => [v[0], 1]));

  gRootsJson = dbToJson(contents[0].columns, contents[0].values, rootsWithChildren);

  return true;
}


function range(size, startAt = 0) {
    return [...Array(size).keys()].map(i => i + startAt);
}

// extract starting indices of words from str
// Can be applied for string where words are separated by a single whitespace
function getWordStarts(str, regexStr) {
  if (regexStr === undefined) {
    regexStr = '\\s';
  }
  let r = new RegExp(regexStr, 'g');
  var matches = [-1];
  while ((arr = r.exec(str)) !== null) {
    matches.push(arr.index);
  }
  matches.push(str.length);

  return matches;
}

// Extracts word boundaries from inscription texts. These texts
// have multiple separators (whitespaces, punctuation) that often
// go together, i.e. space,punctuation,space
// returns array of objects. Each object:
// {start: num, end: num, text: string, isPersonal: 0 or 1, isVariant: [0...N] }
// isVariant - if word is located within a paragrapgh (i.e. §P) isVariant
// contains a numerical difference between paragraph character and 'P'. For §P
// isVariant is 1, for §Q isVariant is 1.
// str - search string
// reg - regex used to detect word boundaries
// purePunctuation - regex used to check if detected word is pure punctuational
function getWordBoundaries(str, reg, purePunctuation) {
  var words = [];
  var wordBegin = 0;
  //var purePunctuation = new RegExp("(·|:|×|¤|'|\\+|÷|¶|\\(|\\))+");
  var strReversed = str.split("").reverse().join("");
  let pCode = 'P'.charCodeAt();

  while ((arr = reg.exec(str)) !== null) {
    if (wordBegin == arr.index) {
      wordBegin += arr[0].length;
      continue;
    }
    let oneWord = {start: wordBegin, end: arr.index, isPersonal: 0, isVariant: 0};
    let wordText = str.slice(oneWord.start, oneWord.end);
    oneWord.text = wordText;
    // skip double sides character
    if (arr[0] == '¶¶')
      continue;

    punctuationCheck = purePunctuation.exec(oneWord.text);
    if (punctuationCheck !== null && punctuationCheck[0].length == oneWord.text.length)
    {
      wordBegin = arr.index + arr[0].length;
      continue;
    }

    if (wordText.startsWith('"') || wordText.startsWith("&quot;"))
      oneWord.isPersonal = 1;
    let reverseStart = str.length-1 - wordBegin;
    if ((parPos = strReversed.indexOf('§', reverseStart)) != -1) {
      if (strReversed[parPos-1].charCodeAt() - pCode >= 0) {
        oneWord.isVariant = strReversed[parPos-1].charCodeAt() - pCode + 1;
      }
    }

    words.push(oneWord);
    wordBegin = arr.index + arr[0].length;
  }
  if (wordBegin == 0) {
    if (str.length > 0) {
      let oneWord = {start: 0, end: str.length, text: str, isPersonal: 0, isVariant: 0};
      if (oneWord.text.startsWith('"') || oneWord.text.startsWith("&quot;"))
        oneWord.isPersonal = 1;

      let reverseStart = str.length-1;
      if ((parPos = strReversed.indexOf('§', reverseStart)) != -1) {
        if (strReversed[parPos-1].charCodeAt() - pCode >= 0) {
          oneWord.isVariant = strReversed[parPos-1].charCodeAt() - pCode + 1;
        }
      }

      punctuationCheck = purePunctuation.exec(oneWord.text);
      if (punctuationCheck === null || punctuationCheck[0].length != oneWord.text.length)
        words.push(oneWord);
    }
  } else {
    // let's add the final word
    if (wordBegin != str.length) {
      let oneWord = {start: wordBegin, end: str.length, isPersonal: 0, isVariant: 0};
      oneWord.text = str.slice(oneWord.start, oneWord.end);
      if (oneWord.text.startsWith('"') || oneWord.text.startsWith("&quot;"))
        oneWord.isPersonal = 1;

      let reverseStart = str.length-1 - wordBegin;
      if ((parPos = strReversed.indexOf('§', reverseStart)) != -1) {
        if (strReversed[parPos-1].charCodeAt() - pCode >= 0) {
          oneWord.isVariant = strReversed[parPos-1].charCodeAt() - pCode + 1;
        }
      }

      punctuationCheck = purePunctuation.exec(oneWord.text);
      if (punctuationCheck === null || punctuationCheck[0].length != oneWord.text.length)
        words.push(oneWord);
    }
  }
  return words;
}

// return words by index. Words are separated by a single space
function wordsByIndex(str, indices) {
  let allWords = str.split(' ');
  let words = [];
  indices.forEach(item => words.push(allWords[item]));
  return words;
}

function wordByCharPos(wordStarts, charPos) {
  for (i = 0; i < wordStarts.length - 1; i++) {
    if (charPos > wordStarts[i] && charPos < wordStarts[i+1]) {
      return i;
    }
  }
  return -1;
}

function onDbLoaded(e) {
  if (!this.response) {
    return;
  }

  var uInt8Array = new Uint8Array(this.response);
  db = new SQL.Database(uInt8Array);

  // add support for regexp searches
  db.create_function('regexp', function (regexValue, fieldData) {
    // do not recreate expression objects
    if (!gRegExpMap.hasOwnProperty(regexValue)) {
      gRegExpMap[regexValue] = new RegExp(regexValue);
      gRegExpMapG[regexValue] = new RegExp(regexValue, 'g');
    }
    let res = -1;
    if (gRegExpMap[regexValue].test(fieldData))
      res = 1;

    return res;
  });

  // Add support for searches across words
  db.create_function('wordRegexp', function (regexValue, fieldData, id, fieldName) {
    if (!gRegExpMap.hasOwnProperty(regexValue)) {
      gRegExpMap[regexValue] = new RegExp(regexValue);
      gRegExpMapG[regexValue] = new RegExp(regexValue, 'g');
    }

    // Test method doesn't really work with global regexps. At least
    // when regex is stored in a global variable, i.e. preserves state
    // between function calls
    if (gRegExpMap[regexValue].test(fieldData) == true) {
      // Use gRegExpMapG from now on. This is important!

      wordStarts = getWordStarts(fieldData);

      var matchIndices = [];
      while ((array1 = gRegExpMapG[regexValue].exec(fieldData)) !== null) {
        minWordIdx = wordByCharPos(wordStarts, array1.index);
        maxWordIdx = wordByCharPos(wordStarts, array1.index+array1[0].length-1);

        let wordIndices = range(maxWordIdx-minWordIdx+1, minWordIdx); // range of word indices
        if (!gWordIndices.hasOwnProperty(id)) {
          gWordIndices[id] = {};
        }
        if (!gWordIndices[id].hasOwnProperty(fieldName)) {
          gWordIndices[id][fieldName] = [];
        }
        gWordIndices[id][fieldName].push(...wordIndices);
      }
      return 1;
    }

    return -1;
  });

  // get all root signatures (that are not aliases)
  var contents = db.exec("SELECT signature_id, signature_text, lost, new_reading FROM all_data");
  var rootsWithChildren = db.exec("SELECT * FROM signatures_with_children");
  // make a hash map for quick read access
  rootsWithChildren = new Map(rootsWithChildren[0].values.map((v, i) => [v[0], 1]));

  gRootIds = new Map(contents[0].values.map((v, i) => [v[0], 1]));
  gRootsJson = dbToJson(contents[0].columns, contents[0].values, rootsWithChildren);

  ////////////////////////////////////////////////////////////////////
  // fill in gAliasByParent. Must be done before convertDbToKeyMap!
  let aliasContents = db.exec('SELECT id, signature_text, parent_id FROM signatures WHERE parent_id NOT NULL');
  if (aliasContents && aliasContents.length > 0) {
    aliasContents[0].values.map(function (row, i) {
      let parent_id = row[2];
      let signature_text = row[1];

      if (!(parent_id in gAliasByParent)) {
        // we do not have an entry for that parent. initialize it
        gAliasByParent[parent_id] = [];
      }
      curValue = gAliasByParent[parent_id];
      curValue.push(signature_text);
      gAliasByParent[parent_id] = curValue;
    });
  }
  ////////////////////////////////////////////////////////////////////

  gOriginalData = gRootsJson;
  gDbAsMap = convertDbToKeyMap();

  contents = db.exec("SELECT signature_text FROM signatures");
  signatureNames = contents[0].values.map((v, i) => v[0]);

  contents = db.exec("SELECT id, signature_text FROM signatures");
  signaturesSelectize = dbToJson(contents[0].columns, contents[0].values);

  $('#jstree').jstree(true).refresh();

  contents = db.exec('SELECT meta_id, count(1) AS num FROM crosses GROUP BY meta_id ORDER BY num DESC LIMIT 1');
  var maxCrosses = contents[0].values[0][1];

  contents = db.exec('SELECT DISTINCT id, name from cross_forms ORDER BY name COLLATE NOCASE');
  var allCrossForms = contents[0].values.map((v, i) => ['<option value="'+v[0]+'">'+v[1]+'</option>']);

  contents = db.exec('SELECT DISTINCT id, name from material_types ORDER BY name COLLATE NOCASE');
  var allMaterialTypes = (contents[0].values);
  var materialTypeFilter = {
    id: 'material_type',
    field: 'materialType_id',
    label: 'Material type',
    type: 'string',
    plugin: 'autoComplete',
    plugin_config: {
      minChars: 0,
      delay: 100,
      source: function (term, suggest) {
        var matches = [];
        for (i = 0; i < allMaterialTypes.length; i++) {
          if (allMaterialTypes[i][1].startsWith(term))
            matches.push(allMaterialTypes[i][1]);
        }
        suggest(matches);
      }
    },
    operators: ['equal', 'not_equal', 'begins_with', 'not_begins_with', 'contains', 'not_contains',
      'ends_with', 'not_ends_with', 'is_empty', 'is_not_empty'],
  };

  /////////////////////////////////////
  // Initialzie QueryBuilder
  //////////////////////////////////////
  var glob_operators = ['equal', 'not_equal', 'begins_with_glob', "not_begins_with_glob", "contains_glob",
   "not_contains_glob", "ends_with", "not_ends_with", "is_empty", 'is_not_empty', "my_regex", "word_regexp"];
  var queryBuilderFilters = [
    {
      id: 'signature_text',
      field: 'signature_text',
      label: humanNameForColumnName('signature_text'),
      type: 'string',
      plugin: 'autoComplete',
      plugin_config: {
        minChars: 0,
        delay: 50,
        source: function(term, suggest) {
          var matches = [];
          for (i = 0; i < signaturesSelectize.length; i++) {
            if (signaturesSelectize[i].text.startsWith(term)) {
              matches.push(signaturesSelectize[i].text);
              continue;
            }
            // do not do the search if we got a match already
            if (signaturesSelectize[i].normalizedText.startsWith(term)) {
              matches.push(signaturesSelectize[i].text);
              continue;
            }
          }
          suggest(matches);
        },
        menuClass: 'clusterize-content ',
      },
      size: 40,
      operators: ['equal', 'not_equal', 'begins_with', "not_begins_with", "contains", "not_contains",
        "ends_with", "not_ends_with", "my_regex"],
    },
    {
      id: 'signature_country',
      field: 'signature_text',
      label: 'Country',
      type: 'string',
      input: 'select',
      multiple: true,
      operators: ['in'],
      valueSetter: function (rule, value) {
        rule.$el.find('.rule-value-container select')[0].selectize.setValue(value);
      },
      plugin: 'selectize',
      plugin_config: {
        plugins: ['remove_button'],
        options: [{text: 'Öland (Öl)', v: 'Öl '}, {text: 'Östergötland (Ög)', v: 'Ög '}, {text: 'Södermanland (Sö)', v: 'Sö '},
          {text: 'Småland (Sm)', v: 'Sm '}, {text: 'Västergötland (Vg)', v: 'Vg '}, {text: 'Uppand (U)', v: 'U '},
          {text: 'Västmanland (Vs)', v: 'Vs '}, {text: 'Närke (Nä)', v: 'Nä '}, {text: 'Värmland (Vr)', v: 'Vr '},
          {text: 'Gästrikland (Gs)', v: 'Gs '}, {text: 'Hälsingland (Hs)', v: 'Hs '}, {text: 'Medelpad (M)', v: 'M '},
          {text: 'Ångermanland (Ån)', v: 'Ån '}, {text: 'Dalarna (D)', v: 'D '}, {text: 'Härjedalen (Hr)', v: 'Hr '},
          {text: 'Jämtland (J)', v: 'J '}, {text: 'Lappland (Lp)', v: 'Lp '}, {text: 'Dalsland (Ds)', v: 'Ds '},
          {text: 'Bohuslän (Bo)', v: 'Bo '}, {text: 'Gotland (G)', v: 'G '}, {text: 'Sweden other (SE)', v: 'SE '},
          {text: 'Denmark (DR)', v: 'DR '}, {text: 'Norway (N)', v: 'N '}, {text: 'Faroe Islands (FR)', v: 'FR '},
          {text: 'Greenland (GR)', v: 'GR '}, {text: 'Iceland (IS)', v: 'IS '}, {text: 'Finland (FI)', v: 'FI '},
          {text: 'Shetland (Sh)', v: 'Sh '}, {text: 'Orkney (Or)', v: 'Or '}, {text: 'Scotland (Sc)', v: 'Sc '},
          {text: 'England (E)', v: 'E '}, {text: 'Isle of Man (IM)', v: 'IM '}, {text: 'Ireland (IR)', v: 'IR '},
          {text: 'France (F)', v: 'F '}, {text: 'Netherlands (NL)', v: 'NL '}, {text: 'Germany (DE)', v: 'DE '},
          {text: 'Poland (PL)', v: 'PL '}, {text: 'Latvia (LV)', v: 'LV '}, {text: 'Russia (RU)', v: 'RU '},
          {text: 'Ukraine (UA)', v: 'UA '}, {text: 'Byzantium (By)', v: 'By '}, {text: 'Italy (IT)', v: 'IT '},
          {text: 'Other areas (X)', v: 'X '}],
        valueField: 'v',
        labelField: 'text',
        searchField: 'text',
        sortField: 'text',
        create: false,
        dropdownDirection: 'up',
        maxItems: null,
      },
    },
    prepareAutoComplete('found_location'),
    prepareAutoComplete('parish'),
    prepareAutoComplete('district'),
    prepareAutoComplete('municipality'),
    prepareAutoComplete('current_location'),
    prepareAutoComplete('original_site'),
    prepareAutoComplete('rune_type'),
    prepareAutoComplete('dating'),
    prepareAutoComplete('carver'),
    prepareAutoComplete('material'),
    prepareAutoComplete('normalisation_norse', {fieldId: 'normalisation_search_norse', operators: glob_operators}),
    prepareAutoComplete('normalisation_scandinavian', {fieldId: 'normalisation_search_scandinavian', operators: glob_operators}),
    prepareAutoComplete('english_translation'),
    prepareAutoComplete('transliteration', {fieldId: 'search_transliteration', operators: glob_operators}),
    prepareAutoComplete('style'),
    prepareAutoComplete('reference'),
    prepareAutoComplete('additional'),
    prepareAutoComplete('objectInfo'),
    prepareAutoComplete('runes_personalname'),
    prepareBooleanRule({'r':'has_personal_name', 'l':'Has personal name?', 'f':'num_names', 'v':1}),
    {
      id: 'alternatives',
      label: 'Has alternative(s)?',
      type: 'integer',
      input: 'radio',
      field: 'signature_id',
      values: [
          {1: 'Yes'},
          {0: 'No'}
      ],
      default_value: 1,
      operators: ['alternatives_in'],
    },
    prepareBooleanRule({'r':'lost', 'l':'Is lost?'}),
    prepareBooleanRule({'r':'new_reading', 'l':'New reading?'}),
    {
      id: 'num_crosses',
      label: 'Number of crosses',
      type: 'integer',
      input: 'number',
      validation: {
        min: 0,
        max: maxCrosses,
        step: 1,
        allow_empty_value: false,
      },
      default_value: 0,
      operators: ['equal', 'not_equal', 'less', 'less_or_equal', 'greater', 'greater_or_equal',
        'between', 'not_between'],
      size: 10,
    },
    {
      id: 'cross_form',
      label: 'Cross form',
      type: 'string',
      operators: ['cross_form'],
      input: function (rule, name) {
        //let $container = rule.$el.find('.rule-value-container');
        return '\
          <select name="'+name+'_1">\
          ' + allCrossForms +
          '</select>\
          <div>Certain?\
            <label><input type="radio" name="'+name+'_2" value="0">No</label>\
            <label><input type="radio" name="'+name+'_2" value="1" checked>Yes</label>\
          </div>';
      },
      valueGetter: function (rule) {
        let val1 = rule.$el.find('.rule-value-container [name$=_1]').val();
        let val2 = rule.$el.find('.rule-value-container [name$=_2]:checked').val();
        return {form: val1, is_certain: val2};
      },
      valueSetter: function (rule, value) {
        $(rule.$el.find('.rule-value-container [name$=_1]')[0]).val(value.form);
        var certainControls = rule.$el.find('.rule-value-container [name$=_2]');
        if (value.is_certain == '1') {
          $(certainControls[0]).prop('checked', false);
          $(certainControls[1]).prop('checked', true);
        } else {
          $(certainControls[0]).prop('checked', true);
          $(certainControls[1]).prop('checked', false);
        }
      },
    },
    materialTypeFilter,
    prepareBooleanRule({'r':'ornamental', 'l':'Is pure ornamental?', 'v': 1}),
  ];

  // Fix for Selectize
  $('#builder').on('afterCreateRuleInput.queryBuilder', function(e, rule) {
    if (rule.filter.plugin == 'selectize') {
      rule.$el.find('.rule-value-container').css('min-width', '200px')
        .find('.selectize-control').removeClass('form-control');
    }
  });

  $('#builder').queryBuilder({
    operators: $.fn.queryBuilder.constructor.DEFAULTS.operators.concat([
      { type: 'alternatives_in',  nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'cross_form', nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'begins_with_glob',      nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'not_begins_with_glob',  nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'contains_glob',  nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'not_contains_glob',  nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'my_regex', nb_inputs: 1, multiple: false, apply_to: ['string'] },
      { type: 'word_regexp', nb_inputs: 1, multiple: false, apply_to: ['string'] },
    ]),

    lang: {
      operators: {
        alternatives_in: ' ',
        cross_form: ' ',
        begins_with_glob: "begins with",
        not_begins_with_glob: "doesn't begin with",
        contains_glob: "contains",
        not_contains_glob: "doesn't contain",
        my_regex: 'matches expression',
        word_regexp: 'matches across words',
      }
    },

    // SQL export (first half)
    sqlOperators: {
      alternatives_in: { op: 'IN' },
      cross_form: { op: 'IN' },
      //like_glob: {op: 'GLOB'},
      begins_with_glob: {op: 'GLOB ?', mod: '{0}*'},
      not_begins_with_glob: {op: 'NOT GLOB ?', mod: '{0}*'},
      contains_glob: { op: 'GLOB ?', mod: '*{0}*'},
      not_contains_glob: { op: 'NOT GLOB ?', mod: '*{0}*'},
      my_regex: { op: 'REGEXP ?', mod: '{0}'},
      word_regexp: { op: 'wordRegexp(?)', mod: '{0}'},
    },
    plugins: {
      'bt-tooltip-errors': null,
      'sortable': null,
      'not-group': null,
      'bt-selectpicker': {liveSearch: true, liveSearchStyle: 'startsWith'},
    },

    filters: queryBuilderFilters,
    sort_filters: true,
  })
  // SQL export (second half)
  .on('ruleToSQL.queryBuilder.filter', function (e, rule, sqlValue, sqlOperator) {
    if (rule.operator === 'alternatives_in') {
      if (rule.value == 1) {
        e.value = rule.field + ' ' + sqlOperator() + ' signatures_with_children';
      } else {
        e.value = rule.field + ' IN root_signatures and ' + rule.field +
          ' NOT ' + sqlOperator() + ' signatures_with_children';
      }
    }
    if (rule.operator === 'cross_form') {
      e.value = 'id IN (SELECT meta_id FROM crosses WHERE crosses.id in (SELECT cross_id FROM cross_definitions WHERE form_id="' + rule.value[0].form + '" AND is_certain="' + rule.value[0].is_certain + '"))';
    }
    if (rule.id === 'material_type') {
      e.value = rule.field + ' IN (SELECT id FROM material_types WHERE name ' + sqlOperator(sqlValue) + ')';
    }
    if (rule.id === 'signature_country') {
      e.value = "(" + rule.value.map(function (v, i) { return rule.field + " LIKE ('"+v+"%')"; }).join(' OR ') + ")";
    }
    if (rule.id === 'has_personal_name') {
      if (rule.value == 1) {
        e.value = rule.field + '> 0';
      } else {
        e.value = rule.field + '= 0';
      }
    }
    if (rule.id === 'signature_text') {
      e.value = 'signature_id IN (SELECT id FROM signatures WHERE ' + rule.field + ' ' + sqlOperator(sqlValue) + ' OR id IN (SELECT parent_id FROM signatures WHERE '
      + rule.field + ' ' + sqlOperator(sqlValue) + '))';
    }
    if (sqlOperator().indexOf('REGEXP') != -1) {
      // Let's convert it to a function call. A better approach might exist,
      // see ruleExpression in query-builder.standalone.js
      e.value = `regexp(${sqlValue}, ${rule.field}) == 1`;
    }
    if (sqlOperator().indexOf('wordRegexp') != -1) {
      e.value = `wordRegexp(${sqlValue}, ${rule.field}, id, '${rule.field}') == 1`;
    }
  })
  ;

  // if (!window.Selectize.prototype.positionDropdownOriginal) {
  //   window.Selectize.prototype.positionDropdownOriginal = window.Selectize.prototype.positionDropdown;
  //   window.Selectize.prototype.positionDropdown = function () {
  //     this.settings.dropdownDirection = 'up';
  //     if (this.settings.dropdownDirection === 'up') {
  //       let $control = this.$control;
  //       let offset = this.settings.dropdownParent === 'body' ? $control.offset() : $control.position();

  //       this.$dropdown.css({
  //         width: $control.outerWidth(),
  //         top: offset.top - this.$dropdown.outerHeight(),
  //         left: offset.left
  //       });
  //       this.$dropdown.addClass('direction-' + this.settings.dropdownDirection);
  //       this.$control.addClass('direction-' + this.settings.dropdownDirection);
  //       this.$wrapper.addClass('direction-' + this.settings.dropdownDirection);
  //     } else {
  //       window.Selectize.prototype.positionDropdownOriginal.apply(this, arguments);
  //     }
  //   };
  // }

  // button handlers
  $('#btnApplyDisplayFormat').on('click', onDisplayFormatClicked);
  $('#btnShowMap').on('click', onShowMapClicked);

  // seems that the data has been loaded. Do not need this timer any more.
  clearTimeout(gLoadingTimer);
}

function scrollToSelectedSignature() {
  var nodes = $('#jstree').jstree(true).get_selected();
  if (nodes === undefined || nodes.length == 0) {
    return;
  }

  var signature = document.getElementById(nodes[0]);
  signature.parentNode.parentNode.scrollTop = signature.offsetTop;
}

// Data provider for jsTree.
function fetchTreeData(obj, cb) {
  if (obj.id === '#') {
    if (db === null) {
        // we need to load the database first
        return;
    }

    cb.call(this, gRootsJson);
  }
}

/* Once db is loaded convert all content to key-value object
*/
function convertDbToKeyMap() {
  // Get all displayable column names and convert them to comma-separated string
  let allDisplayColumns = displayFields();
  allDisplayColumns.unshift({value: 'latitude', text: 'latitude'});
  allDisplayColumns.unshift({value: 'longitude', text: 'longitude'});
  allDisplayColumns.unshift({value: 'signature_id', text: 'some'});
  allDisplayColumns.unshift({value: 'id', text: 'meta_id'});

  allDisplayColumns = allDisplayColumns.reduce(function (result, field) {
    if (field.value === 'images' || field.value === 'crosses')
      return result;

    if (field.value !== 'images') {
      result.push(field.value);
    }
    return result;
  }, []);

  let contents = db.exec("SELECT " + allDisplayColumns + " FROM all_data");
  let allRows = contents[0].values;
  let dbMap = {};
  let columns = contents[0].columns;
  let signatureColumn = columns.indexOf('signature_text');
  let metaColumn = columns.indexOf('id');
  let numCrossesColumn = columns.indexOf('num_crosses');
  let latitudeColumn = columns.indexOf('latitude');
  let longitudeColumn = columns.indexOf('longitude');
  let signatureIdColumn = columns.indexOf('id'); // it is actually meta ID

  let customColumns = ['transliteration', 'english_translation', 'normalisation_scandinavian', 'normalisation_norse'];

  for (var i = 0; i < allRows.length; i++) {
    let row = allRows[i];
    let rowObj = {};
    let signatureId = row[signatureIdColumn];

    for (var j = 0; j < allDisplayColumns.length; j++) {
      let columnName = allDisplayColumns[j];

      // we need to skip some columns
      if (columnName === 'signature_id'
          || columnName === 'latitude'
          || columnName === 'longitude')
        continue;

      let humanName = humanNameForColumnName(columnName);
      let columnData = row[j];

      //columnData = escapeHtml(columnData);

      if (columnName === 'signature_text') {
        if (signatureId in gAliasByParent) {
          columnData += ' (' + gAliasByParent[signatureId].join('|') + ')';
          rowObj['aliases'] = gAliasByParent[signatureId].join(';');
        } else {
          rowObj['aliases'] = '';
        }
      }

      rowObj[columnName] = columnData;
      rowObj[columnName + 'html'] = escapeHtml(columnData);
    }

    /////////////////////////////////////
    // fill in images
    let directImagesQuery = db.exec("SELECT id, link_url, direct_url FROM runes_imagelink WHERE "
      + "direct_url <> '' AND meta_id = " + row[metaColumn] + " LIMIT 9");
    let indirectImagesQuery = [];
    let directImagesValue = [];
    let indirectImagesValue = [];

    if (directImagesQuery.length > 0) {
      let ids = directImagesQuery[0].values.map((v, i) => v[0]);
      ids = ids.join(',');
      indirectImagesQuery = db.exec("SELECT link_url, direct_url FROM runes_imagelink WHERE meta_id = '" + row[metaColumn] + "' AND id NOT IN (" + ids + ")");
      directImagesValue = directImagesQuery[0].values;
    } else {
      indirectImagesQuery = db.exec("SELECT link_url, direct_url FROM runes_imagelink WHERE meta_id = '" + row[metaColumn] + "'");
    }

    if (indirectImagesQuery.length > 0) {
      indirectImagesValue = indirectImagesQuery[0].values;
    }

    let allImagesQuery = db.exec("SELECT link_url FROM runes_imagelink WHERE meta_id = " + row[metaColumn]);
    let allImages = [];
    if (allImagesQuery.length > 0) {
      allImages = allImagesQuery[0].values;
    }

    rowObj['directImages'] = directImagesValue;
    rowObj['indirectImages'] = indirectImagesValue;
    let indirectImages = 'No images.';
    if (rowObj['indirectImages'].length > 0) {
      indirectImages = '<ul>';
      rowObj['indirectImages'].map(function (v, i) {
        indirectImages += `<li><a href="${v[0]}" contentEditable="false" target="_blank">${v[0]}</a></li>`;
      });
      indirectImages += '</ul>';
    }
    rowObj['indirectImageshtml'] = indirectImages;
    rowObj['images'] = allImages;

    // make image gallery of direct image links
    let directImages = '';
    if (rowObj['directImages'].length > 0) {
      directImages = '<div class="container-fluid"><div class="row">';
      rowObj['directImages'].map(function (v, i) {
          if (i % 3 == 0) {
            directImages += "</div>";
            if (i < 9)
              directImages += '<div class="row">';
          }
          directImages += `<div class="col-md-4"><a href="${v[1]}" contentEditable="false" target="_blank"><img src="${v[2]}" class="img-responsive"></a></div>`;
      });
      directImages += '</div></div>';
    }
    rowObj['directImageshtml'] = directImages;
    /////////////////////////////////////

    /////////////////////////////////////
    // fill in crosses
    let numCrosses = row[numCrossesColumn];
    if (numCrosses > 0) {
      rowObj['crosses'] = crossesForMeta(row[metaColumn]);
    } else {
      rowObj['crosses'] = [];
    }
    /////////////////////////////////////

    rowObj['signature_text_raw'] = row[signatureColumn];
    rowObj['latitude'] = row[latitudeColumn];
    rowObj['longitude'] = row[longitudeColumn];

    dbMap[signatureId] = rowObj;
  }

  return dbMap;
}

function clearMarkers() {
  for (let key in mapMarkers) {
    if (mapMarkers.hasOwnProperty(key)) {
      mapMarkers[key].remove();
    }
  }
  markers.clearLayers();
}

function makeMarkers() {
  let markersLatLon = [];

  for (let i = 0; i < gRootsJson.length; i++) {
    let signatureName = gRootsJson[i].signature;
    let marker = '';
    let row = gRootsJson[i].id;
    let inscriptionData = gDbAsMap[gRootsJson[i].id];

    if (row in mapMarkers) {
      marker = mapMarkers[row];
    } else {
      let lat = parseFloat(inscriptionData.latitude);
      let lon = parseFloat(inscriptionData.longitude);
      if ((!isNaN(lat) && !isNaN(lon)) && (lat != 0 && lon != 0)) {
        marker = new MarkerWithData([lat, lon], {
          signature: signatureName,
          id: gRootsJson[i].id,
        });
        let popupText = "<b>" + signatureName + "</b>";
        //marker.bindPopup(popupText);
        marker.bindTooltip(signatureName, {permanent: true});
        mapMarkers[row] = marker;

        markers.addLayer(marker);
        markersLatLon.push(marker.getLatLng());
      }
    }
    //if (marker instanceof Object) {
      // markers.addLayers(marker);
      // markersLatLon.push(marker.getLatLng());
    //}
  }

  if (markersLatLon.length > 0) {
    let markersBounds = L.latLngBounds(markersLatLon);
    myMap.fitBounds(markersBounds);
  }
  return markersLatLon;
}

/* Scroll main display so that it shows the desired inscription.
 * signature is a textual signature, i.e. 'IR 3'
 * inscriptionId is a corresponding DB row ID. For example, 5.
 */
function scrollToInscription(signature, inscriptionId, updateTree) {
  var section = document.getElementById(signature);
  if (updateTree === undefined) {
    updateTree = true;
  }

  if (section) {
    gMainScrollArea.scrollTop = section.offsetTop;
  } else {
    // isncription had not been loaded into DOM
    var approxItemHeight = gMainClusterize.options.item_height;
    var rowId = inscriptionId;
    var approxItemScrollTop = rowId * approxItemHeight;

    scrollForRow({
      approxItemScrollTop: approxItemScrollTop,
      direction: 'up',
      iteration: 0,
      maxTries: 100000,
      signatureId: signature,
    });
  }
  if (updateTree) {
    var el = document.getElementById(inscriptionId + '_anchor');
    console.log('Searched for ' + inscriptionId + '_anchor');
    if (el) {
      $('#jstree').scrollTop(el.offsetTop);
      $('#jstree').jstree(true).deselect_all(true);
      $('#jstree').jstree(true).select_node(inscriptionId, true);
    }
  }
}

// Scroll main display
// _params is an object with one used value: approxItemScrollTop.
// approxItemScrollTop - value to which main display will be scrolled.
function scrollForRow(_params) {
  gMainScrollArea.scrollTop = _params.approxItemScrollTop;
  gClusterizeParams = _params;
}

// Helper function used during search for inscription on the main display.
// This function examines current content of main display and if inscription
// is not present, it will continue the search.
// If inscription is present, we will scroll the main display to it.
function onMainClusterChanged() {
  if (!Object.keys(gClusterizeParams) || Object.keys(gClusterizeParams).length == 0)
    return;
  if (!gMainClusterize)
    return;

  var section = document.getElementById(gClusterizeParams.signatureId);
  if (section !== null) {
    // Seems like we found the section. We can not scroll directly to it,
    // because offsetTop can still change soon due to image loading. So,
    // let's make an async call.
    setTimeout(scrollToInscription, 30, gClusterizeParams.signatureId);
    gClusterizeParams = {};
  } else {
    // Our row is not in a cluster, let's check neighbouring clusters.
    // Let's imagine we are in cluster number 5. Go check at 4th, then 6th,
    // then 3rd, then 7th...
    // Until we find our row or until we reach the limit from params.maxTries

    var shift = ++gClusterizeParams.iteration * (gMainClusterize.options.cluster_height );
    gClusterizeParams.approxItemScrollTop += shift * (gClusterizeParams.direction == 'up' ? -1 : 1);
    gClusterizeParams.direction = gClusterizeParams.direction == 'up' ? 'down' : 'up';
    if (gClusterizeParams.iteration < gClusterizeParams.maxTries)
      scrollForRow(gClusterizeParams);
  }
}

// Get all inscriptions from jsTree and convert it to array of HTML tags,
// which are ready for rendering.
function inscriptions2markup() {
  // array of all isncription IDs/signatures
  let signatures = gRootsJson.map((obj, i) => obj.id);;

  // we have no nodes in the tree
  if (signatures.length == 0)
    return [];

  const showHeaders = $('#chkDisplayHeaders').is(":checked");

  let markupData = [];

  for (let i = 0; i < signatures.length; i++) {
    let signatureId = signatures[i];

    let inscriptionData = gDbAsMap[signatureId];
    let signatureName = inscriptionData['signature_text_raw'];

    let paragraph = `<article signature="${signatureName}" id="${signatureName}" class="inscription-section">`;

    for (let j = 0; j < userSelectedDisplay.length; j++) {
      let columnName = userSelectedDisplay[j];
      let humanName = humanNameForColumnName(columnName);
      let columnData = '';
      if (columnName in inscriptionData)
        columnData = inscriptionData[columnName + 'html'];

      if (showHeaders) {
        paragraph += '<h4>' + humanName + '</h4>';
      } else if (paragraph.length > 0 && columnData !== '') {
        paragraph += '<br>';
      }

      //columnData = escapeHtml(columnData);

      if (columnName === 'images') {
        if (inscriptionData['directImages'].length == 0) {
          paragraph += inscriptionData['indirectImageshtml'];
          continue;
        }
        paragraph += inscriptionData['directImageshtml'];
        if (inscriptionData['indirectImages'].length > 0) {
          // add image links as they have not been added yet
          paragraph += '<br>' + inscriptionData['indirectImageshtml'];
        }

        continue;
      }

      if (jQuery.inArray(columnName, customColumns) != -1) {
        let cssStyle = 'normalization';
        if (~columnName.indexOf('transliteration')) {
          cssStyle = 'transliteration';
        } else if (~columnName.indexOf('english_translation')) {
          cssStyle = '';
        }

        if (columnName.indexOf('english_translation') == -1
            && gMatchedWordIndices.hasOwnProperty(signatureId)) {
          // this is one of the columns that should have highlighted data

          columnData = columnData.trim();
          // from set with word indices to array
          let matchedWords = [...gMatchedWordIndices[signatureId]];
          // sort in descending order
          matchedWords = matchedWords.sort(function (a, b) { return b - a; } );
          if (columnName.indexOf('transliteration') != -1) {
            // double space have special meaning => it's designates a word that is not
            // present in transliterated text, but is present in other texts. Very important!
            columnData = columnData.replace(/\s{2}/g, ' &nbsp; ');
          }
          let words = getWordBoundaries(columnData, gWordSearchRegexEsc, gWordPunctuationRegexEsc);
          var highlightedStr = columnData;
          for (let k = 0; k < matchedWords.length; k++) {
            let idx = matchedWords[k];
            let wordStart = words[idx].start;
            let wordEnd = words[idx].end;

            if (words[idx].text[0] == '§') {
              // this is a paragraph, do nothing
              continue;
            }

            highlightedStr = columnData.slice(0, wordStart)
              + '<span class="highlighted">'
              + words[idx].text
              + '</span>'
              + highlightedStr.slice(wordEnd);
          }
          columnData = highlightedStr;
        }

        // Smiley is a special symbol: word substitute when word is not present
        // We do not need to show it.
        columnData = columnData.replace(/ ☺ /g, ' ');

        if (~columnData.indexOf(paragraphSymbol)) {
          let parts = columnData.split(paragraphSymbol);
          let listHeader = '';
          listHeader = "Sides or/and reading variants:"

          paragraph += listHeader;
          paragraph += '<ul>';
          for (let k = 0; k < parts.length; k++) {
            let part = parts[k];

            if (!part.trim())
              continue;

            part = paragraphSymbol + part;
            paragraph += '<li><span class="' + cssStyle + '">' + part + '</span></li>';
          }
          paragraph += '</ul>';
        } else {
          // no parts in the columnData
          paragraph += '<span class="' + cssStyle + '">' + columnData + '</span>';
        }
        continue;
      }

      if (columnName === 'crosses') {
        if (inscriptionData.num_crosses == 0) {
          paragraph += 'No crosses.';
          continue;
        }

        paragraph += '<table class="crosses" border="1">';
        paragraph += '<thead><tr>';
        paragraph += '<th>A</th>';
        paragraph += '<th>B</th>';
        paragraph += '<th>C</th>';
        paragraph += '<th>D</th>';
        paragraph += '<th>E</th>';
        paragraph += '<th>F</th>';
        paragraph += '<th>G</th>';
        paragraph += '</th></thead>';
        paragraph += '<tbody>';

        let allCrosses = inscriptionData['crosses'];
        for (let k = 0; k < allCrosses.length; k++) {
          if (allCrosses[k][0].length > 0) {
            // this is a cross from undefined group
            paragraph += '<tr><td colspan="7">' + allCrosses[k][0][0].name + '</td></tr>';
            continue;
          }
          paragraph += '<tr>';
          // we have 8 groups in total, 0 being free-text and not a real group
          for (let gr = 1; gr < 8; gr++) {
            let crossForms = allCrosses[k][gr];
            if (crossForms.length == 0) {
              paragraph += '<td><span class="null">&#8709;</span></td>';
              continue;
            }
            paragraph += '<td>';
            paragraph += allCrosses[k][gr].map(function (v, i) {
              let url = staticBase + v.name + '.png';
              let res = '<img src="' + url + '" alt="'+v.name+'" title="'+v.name+'" width="32" height="32">';
              if (v.isCerain == 0) {
                res += '?';
              }
              return res;
            }).join(', ');
            paragraph += '</td>';
          }
        }
        paragraph += '</tbody></table>';
        continue;
      }

      if (columnData == '' && showHeaders) {
        columnData = '<i>Absent, not in the database.</i>';
      }
      paragraph += columnData;
    }
    paragraph += '</article>';

    markupData.push(paragraph);
  }

  return markupData;
}

function displayinscriptions(makeMarkers) {
  if (makeMarkers === undefined) {
    makeMarkers = true;
  }

  if (!gBatchRenderIsDone) {
    // We are currently rendering another batch of signature selections
    // Cancell it and come back later
    gStopRendering = true;
    setTimeout(displayinscriptions, 100, makeMarkers);
    return;
  }
  gBatchRenderIsDone = false;
  gDisplayTimeout = -1;

  $('#mainDisplay').empty();

  // in order to get information about all nodes in a tree, we need to select
  // all of them first
  let currentSelection = $('#jstree').jstree(true).get_selected();
  $('#jstree').jstree(true).select_all(true);
  let signatures = $('#jstree').jstree(true).get_selected();
  $('#jstree').jstree(true).deselect_all(true);
  $('#jstree').jstree(true).select_node(currentSelection, true);

  // we have no nodes in the tree
  if (signatures.length == 0)
    return;

  const showHeaders = $('#chkDisplayHeaders').is(":checked");
  let mainDisplayDom = document.getElementById('mainDisplay');

  let renderParams = {
    mainDisplay: mainDisplayDom,
    signatures: signatures,
    userSelectedDisplay: userSelectedDisplay,
    showHeaders: showHeaders,
  }

  // Set to true, so that we can begin to render
  gSingleRenderIsDone = true;
  renderParams.mainDisplay.innerHTML += "<img src='{% static 'runes/jstree/themes/default/throbber.gif' %}'><br>";

  setTimeout(renderHelper, 10, renderParams);
}

function renderHelper(params) {
  if (params.signatures.length > 0) {
    if (gStopRendering) {
      params.signatures = [];
      renderHelper(params);
      return;
    }

    if (!gSingleRenderIsDone) {
      // Rendering is in process, we have to wait and come back here later
      setTimeout(renderHelper, 50, params);
      return;
    }

    setTimeout(renderInscription, 10, params);
  } else {
    let idx = renderParams.mainDisplay.innerHTML.indexOf('<article');
    if (idx != -1) {
      renderParams.mainDisplay.innerHTML = renderParams.mainDisplay.innerHTML.slice(idx);
    }
    gBatchRenderIsDone = true;
    gStopRendering = false;
  }
}

function renderInscription(params) {
  gSingleRenderIsDone = false;
  let signatureId = params.signatures.shift();
  let userSelectedDisplay = params.userSelectedDisplay;
  let showHeaders = params.showHeaders;

  let inscriptionData = gDbAsMap[signatureId];
  let signatureName = inscriptionData['signature_text_raw'];

  let paragraph = `<article signature="${signatureName}" id="${signatureName}" class="inscription-section">`;
  let staticBase = "{% static 'runes/images/cross_forms/' %}";

  for (let j = 0; j < userSelectedDisplay.length; j++) {
    let columnName = userSelectedDisplay[j];
    let humanName = humanNameForColumnName(columnName);
    let columnData = '';
    if (columnName in inscriptionData)
      columnData = inscriptionData[columnName];

    if (showHeaders) {
      paragraph += '<h4>' + humanName + '</h4>';
    } else if (paragraph.length > 0 && columnData !== '') {
      paragraph += '<br>';
    }

    columnData = escapeHtml(columnData);

    if (columnName === 'images') {
      let indirectImages = 'No images.';
      if (inscriptionData['indirectImages'].length > 0) {
        indirectImages = '<ul>';
        inscriptionData['indirectImages'].map(function (v, i) {
          indirectImages += `<li><a href="${v[0]}" contentEditable="false" target="_blank">${v[0]}</a></li>`;
        });
        indirectImages += '</ul>';
      }
      if (inscriptionData['directImages'].length == 0) {
        paragraph += indirectImages;
        continue;
      }

      // output image gallery
      paragraph += '<div class="container-fluid"><div class="row">';
      inscriptionData['directImages'].map(function (v, i) {
        if (i % 3 == 0) {
          paragraph += "</div>";
          if (i < 9)
            paragraph += '<div class="row">';
        }
        paragraph += `<div class="col-md-4"><a href="${v[1]}" contentEditable="false" target="_blank"><img src="${v[2]}" class="img-responsive"></a></div>`;
      });
      paragraph += '</div></div>';

      if (inscriptionData['indirectImages'].length > 0) {
        // add image links as they have not been added yet
        paragraph += '<br>' + indirectImages;
      }

      continue;
    }

    if (columnName === 'crosses') {
      if (inscriptionData.num_crosses == 0) {
        paragraph += 'No crosses.';
        continue;
      }

      paragraph += '<table class="crosses" border="1">';
      paragraph += '<thead><tr>';
      paragraph += '<th>A</th>';
      paragraph += '<th>B</th>';
      paragraph += '<th>C</th>';
      paragraph += '<th>D</th>';
      paragraph += '<th>E</th>';
      paragraph += '<th>F</th>';
      paragraph += '<th>G</th>';
      paragraph += '</th></thead>';
      paragraph += '<tbody>';

      let allCrosses = inscriptionData['crosses'];
      for (let k = 0; k < allCrosses.length; k++) {
        if (allCrosses[k][0].length > 0) {
          // this is a cross from undefined group
          paragraph += '<tr><td colspan="7">' + allCrosses[k][0][0].name + '</td></tr>';
          continue;
        }
        paragraph += '<tr>';
        // we have 8 groups in total, 0 being free-text and not a real group
        for (let gr = 1; gr < 8; gr++) {
          let crossForms = allCrosses[k][gr];
          if (crossForms.length == 0) {
            paragraph += '<td><span class="null">&#8709;</span></td>';
            continue;
          }
          paragraph += '<td>';
          paragraph += allCrosses[k][gr].map(function (v, i) {
            let url = staticBase + v.name + '.png';
            let res = '<img src="' + url + '" alt="'+v.name+'" title="'+v.name+'" width="32" height="32">';
            if (v.isCerain == 0) {
              res += '?';
            }
            return res;
          }).join(', ');
          paragraph += '</td>';
        }
      }
      paragraph += '</tbody></table>';
      continue;
    }

    if (columnData == '' && showHeaders) {
      columnData = '<i>Absent, not in the database.</i>';
    }
    paragraph += columnData;
  }
  paragraph += '</article>';

  params.mainDisplay.innerHTML += paragraph;

  // prepare for the next run
  gSingleRenderIsDone = true;
  setTimeout(renderHelper, 10, params);
}

/* Display inscription information for selected signatures.
 *
 * This function is called every time we need to show inscription details.
 * Normally it will be called when user selects one or multiple signatures.
 * Optional makeMarkers parameter controlls creation of map markers.
 */
function displaySignatureInfo(makeMarkers) {
  if (makeMarkers === undefined) {
    makeMarkers = true;
  }

  if (!gBatchRenderIsDone) {
    // We are currently rendering another batch of signature selections
    // Cancell it and come back later
    gStopRendering = true;
    setTimeout(displaySignatureInfo, 100, makeMarkers);
    return;
  }
  gBatchRenderIsDone = false;
  gDisplayTimeout = -1;

  $('#mainDisplay').empty();
  if (makeMarkers) {
    for (let key in mapMarkers) {
      if (mapMarkers.hasOwnProperty(key)) {
        mapMarkers[key].remove();
      }
    }
    markers.clearLayers();
  }

  let indices = $('#jstree').jstree(true).get_selected();
  if (indices.length == 0)
    return;

  let finalText = '';
  let customColumns = ['transliteration', 'english_translation', 'normalisation_scandinavian', 'normalisation_norse'];

  const paragraphSymbol = '§';
  const sidesMarker = '§A';
  const readingMarker = '§P';
  let staticBase = "{% static 'runes/images/cross_forms/' %}";
  const showHeaders = $('#chkDisplayHeaders').is(":checked");

  let markersLatLon = [];

  let indicesStr = indices.join(',');
  let contents = db.exec("SELECT * FROM all_data where signature_id IN (" + indicesStr + ")");
  if (!contents || contents.length == 0)
    return;

  // Map of aliases. Key is parent ID, value - list of alias names
  let aliasByParent = {};
  let aliasContents = db.exec('SELECT id, signature_text, parent_id FROM signatures WHERE parent_id IN (' + indicesStr + ')');
  if (aliasContents && aliasContents.length > 0) {
    aliasContents[0].values.map(function (v, i) {
      if (!(v[2] in aliasByParent)) {
        aliasByParent[v[2]] = [];
      }
      curValue = aliasByParent[v[2]];
      curValue.push(v[1]);
      aliasByParent[v[2]] = curValue;
    });
  }

  let latIdx = contents[0].columns.indexOf('latitude');
  let lonIdx = contents[0].columns.indexOf('longitude');
  let signNameIdx = 0;
  let metaIdIdx = contents[0].columns.indexOf('id');
  let mainDisplayDom = document.getElementById('mainDisplay');

  let renderParams = {
    latIdx: latIdx,
    lonIdx: lonIdx,
    metaIdIdx: metaIdIdx,
    userSelectedDisplay: userSelectedDisplay,
    showHeaders: showHeaders,
    mainDisplay: mainDisplayDom,
    allRows: contents[0].values,
    curRowIdx: 0,
    columns: contents[0].columns,
    aliasByParent: aliasByParent,
    signNameIdx: signNameIdx,
    batchId: gRenderBatchId,
  };

  gNumSelectedSignatures = indices.length;

  if ($('#mapDisplay').is(':visible') && makeMarkers) {
    for (let i = 0; i < indices.length; i++) {
      let row = indices[i];
      let signatureName = contents[0].values[i][signNameIdx];

      // handle map marker only if map is visible
      let marker = '';
      if (row in mapMarkers) {
        marker = mapMarkers[row];
      } else {
        let lat = parseFloat(contents[0].values[i][latIdx]);
        let lon = parseFloat(contents[0].values[i][lonIdx]);
        if ((!isNaN(lat) && !isNaN(lon)) && (lat != 0 && lon != 0)) {
          marker = new MarkerWithData([lat, lon], {inscription: signatureName});
          let popupText = "<b>" + signatureName + "</b>";
          //marker.bindPopup(popupText);
          marker.bindTooltip(signatureName, {permanent: true});
          mapMarkers[row] = marker;
        }
      }
      if (marker instanceof Object) {
        markers.addLayer(marker);
        markersLatLon.push(marker.getLatLng());
      }
    }

    if (markersLatLon.length > 0) {
      let markersBounds = L.latLngBounds(markersLatLon);
      myMap.fitBounds(markersBounds);
    }
  }

  // Set to true, so that we can begin to render
  gSingleRenderIsDone = true;
  renderParams.mainDisplay.innerHTML += "<img src='{% static 'runes/jstree/themes/default/throbber.gif' %}'><br>";
  setTimeout(signatureRenderHelper, 10, renderParams);
}

function signatureRenderHelper(renderParams) {
  if (gNumSelectedSignatures == 0) {
    return;
  }

  if (renderParams.curRowIdx < gNumSelectedSignatures) {
    if (gStopRendering) {
      renderParams.curRowIdx = gNumSelectedSignatures + 1;
      signatureRenderHelper(renderParams);
      return;
    }

    if (!gSingleRenderIsDone) {
      // Rendering is in process, we have to wait and come back here later
      setTimeout(signatureRenderHelper, 50, renderParams);
      return;
    }

    setTimeout(renderSignature, 20, renderParams);
  } else {
    let idx = renderParams.mainDisplay.innerHTML.indexOf('<article');
    if (idx != -1) {
      renderParams.mainDisplay.innerHTML = renderParams.mainDisplay.innerHTML.slice(idx);
    }
    gBatchRenderIsDone = true;
    gStopRendering = false;
  }
}

// Depends on global variables: db
function renderSignature(renderParams) {
  gSingleRenderIsDone = false;

  let curRow = renderParams.allRows[renderParams.curRowIdx];
  let userSelectedDisplay = renderParams.userSelectedDisplay;
  let showHeaders = renderParams.showHeaders;
  let metaIdIdx = renderParams.metaIdIdx;
  let columns = renderParams.columns;
  let aliasByParent = renderParams.aliasByParent;
  let signatureName = curRow[renderParams.signNameIdx];

  let highlightColumns = ['transliteration', 'normalisation_scandinavian', 'normalisation_norse'];
  let customColumns = new Array(...highlightColumns);
  customColumns.push('english_translation');
  const paragraphSymbol = '§';
  const sidesMarker = '§A';
  const readingMarker = '§P';
  let staticBase = "{% static 'runes/images/cross_forms/' %}";
  let signIdIdx = columns.indexOf('signature_id');
  let signatureId = curRow[signIdIdx];

  let paragraph = `<article signature="${signatureName}" id="${signatureName}" class="inscription-section">`;

  for (let j = 0; j < userSelectedDisplay.length; j++) {
    let columnName = userSelectedDisplay[j];
    let humanName = humanNameForColumnName(columnName);
    let columnIdx = columns.indexOf(columnName);
    let columnData = curRow[columnIdx];

    if (showHeaders) {
      paragraph += '<h4>' + humanName + '</h4>';
    } else if (paragraph.length > 0 && columnData !== '') {
      paragraph += '<br>';
    }

    columnData = escapeHtml(columnData);

    if (userSelectedDisplay[j] == 'images') {
      let directImages = db.exec("SELECT id, link_url, direct_url FROM runes_imagelink WHERE meta_id = '" + curRow[metaIdIdx] + "' AND direct_url <> '' LIMIT 9");
      let dbImages = [];
      if (directImages.length > 0) {
        let ids = directImages[0].values.map(function (v, i) { return v[0]; });
        ids = ids.join(',');
        dbImages = db.exec("SELECT link_url, direct_url FROM runes_imagelink WHERE meta_id = '" + curRow[metaIdIdx] + "' AND id NOT IN (" + ids + ")");
      } else {
        dbImages = db.exec("SELECT link_url, direct_url FROM runes_imagelink WHERE meta_id = '" + curRow[metaIdIdx] + "'");
      }
      let indirectImages = 'No images.';
      if (dbImages.length > 0) {
        indirectImages = '<ul>';
        dbImages[0].values.map(function (v, i) {
          indirectImages += `<li><a href="${v[0]}" contentEditable="false" target="_blank">${v[0]}</a></li>`;
        });
        indirectImages += '</ul>';
      }

      if (directImages.length == 0) {
        paragraph += indirectImages;
        continue;
      }

      paragraph += '<div class="container-fluid"><div class="row">';
      directImages[0].values.map(function (v, i) {
        if (i % 3 == 0) {
          paragraph += "</div>";
          if (i < 9)
            paragraph += '<div class="row">';
        }
        paragraph += `<div class="col-md-4"><a href="${v[1]}" contentEditable="false" target="_blank"><img src="${v[2]}" class="img-responsive"></a></div>`;
      });
      paragraph += '</div></div>';

      if (indirectImages !== 'No images.') {
        paragraph += '<br>' + indirectImages;
      }

      continue;
    }

    if (jQuery.inArray(columnName, customColumns) != -1) {
      let cssStyle = 'normalization';
      if (~columnName.indexOf('transliteration')) {
        cssStyle = 'transliteration';
      } else if (~columnName.indexOf('english_translation')) {
        cssStyle = '';
      }

      if (columnName.indexOf('english_translation') == -1
        && gMatchedWordIndices.hasOwnProperty(signatureId)) {
        // this is one of columns that should have highlighted data
        // from set with word indices to array
        columnData = columnData.trim();
        let matchedWords = [...gMatchedWordIndices[signatureId]];
        // sort in descending order
        matchedWords = matchedWords.sort(function (a, b) { return b - a; } );
        if (columnName.indexOf('transliteration') != -1) {
          // double space have special meaning => it's designates a word that is not
          // present in transliterated text, but is present in other texts. Very important!
          columnData = columnData.replace(/\s{2}/g, ' &nbsp; ');
        }
        let words = getWordBoundaries(columnData, gWordSearchRegexEsc, gWordPunctuationRegexEsc);
        var highlightedStr = columnData;
        for (let k = 0; k < matchedWords.length; k++) {
          let idx = matchedWords[k];
          let wordStart = words[idx].start;
          let wordEnd = words[idx].end;

          if (words[idx].text[0] == '§') {
            // this is a paragraph, do nothing
            continue;
          }

          highlightedStr = columnData.slice(0, wordStart)
            + '<span class="highlighted">'
            + words[idx].text
            + '</span>'
            + highlightedStr.slice(wordEnd);
        }
        columnData = highlightedStr;
      }
      // Smiley is a special symbol: word substitute when word is not present
      // We do not need to show it.
      columnData = columnData.replace(/ ☺ /g, ' ');

      if (~columnData.indexOf(paragraphSymbol)) {
        let parts = columnData.split(paragraphSymbol);
        let listHeader = '';
        listHeader = "Sides or/and reading variants:"

        paragraph += listHeader;
        paragraph += '<ul>';
        for (let k = 0; k < parts.length; k++) {
          let part = parts[k];

          if (!part.trim())
            continue;

          part = paragraphSymbol + part;
          paragraph += '<li><span class="' + cssStyle + '">' + part + '</span></li>';
        }
        paragraph += '</ul>';
      } else {
        // no parts in the columnData
        paragraph += '<span class="' + cssStyle + '">' + columnData + '</span>';
      }
      continue;
    }

    if (userSelectedDisplay[j] === 'crosses') {
      let numCrossesColumnIdx = columns.indexOf('num_crosses');
      let numCrosses = curRow[numCrossesColumnIdx];
      if (!numCrosses || numCrosses == 0) {
        paragraph += 'No crosses';
        continue;
      }

      paragraph += '<table class="crosses" border="1">';
      paragraph += '<thead><tr>';
      paragraph += '<th>A</th>';
      paragraph += '<th>B</th>';
      paragraph += '<th>C</th>';
      paragraph += '<th>D</th>';
      paragraph += '<th>E</th>';
      paragraph += '<th>F</th>';
      paragraph += '<th>G</th>';
      paragraph += '</th></thead>';
      paragraph += '<tbody>';

      let allCrosses = crossesForMeta(curRow[metaIdIdx]);
      for (let k = 0; k < allCrosses.length; k++) {
        if (allCrosses[k][0].length > 0) {
          // this is a cross from undefined group
          paragraph += '<tr><td colspan="7">' + allCrosses[k][0][0].name + '</td></tr>';
          continue;
        }
        paragraph += '<tr>';
        // we have 8 groups in total, 0 being free-text and not a real group
        for (let gr = 1; gr < 8; gr++) {
          let crossForms = allCrosses[k][gr];
          if (crossForms.length == 0) {
            paragraph += '<td><span class="null">&#8709;</span></td>';
            continue;
          }
          paragraph += '<td>';
          paragraph += allCrosses[k][gr].map(function (v, i) {
            let url = staticBase + v.name + '.png';
            let res = '<img src="' + url + '" alt="'+v.name+'" title="'+v.name+'" width="32" height="32">';
            if (v.isCerain == 0) {
              res += '?';
            }
            return res;
          }).join(', ');
          paragraph += '</td>';
        }
      }
      paragraph += '</tbody></table>';
      continue;
    }

    if (userSelectedDisplay[j] === 'signature_text') {
      if (signatureId in aliasByParent) {
        columnData += ' (' + aliasByParent[signatureId].join('|') + ')';
      }
    }

    if (columnData == '' && showHeaders) {
      columnData = '<i>Absent</i>';
    }
    paragraph += columnData;
  }
  paragraph += '</article>';

  renderParams.mainDisplay.innerHTML += paragraph;

  // prepare for the next run
  renderParams.curRowIdx += 1;
  gSingleRenderIsDone = true;
  setTimeout(signatureRenderHelper, 10, renderParams);
}

/* Find all crosses related to particular metaId.
 * Returned variable is a multidimensional array. Dimensions:
 * 1. First dimension contains individual crosses.
 * 2. Second dimension denotes cross form group. There could only be 8 groups.
 * 3. Third dimension contains objects with 2 data fields (name, isCertain). Each object represents a particular cross form in a group.
 *    Note that some groups can be empty.
 */
function crossesForMeta(metaId) {
  // we do not check that this meta contains any crosses. This should be done in parent call
  let cc = db.exec("SELECT id FROM crosses WHERE meta_id = '" + metaId + "'");
  let contents = db.exec("SELECT cross_id, cross_forms.id, cross_forms.name, cross_forms.group_id, cross_definitions.is_certain FROM cross_definitions INNER JOIN cross_forms ON (cross_definitions.form_id = cross_forms.id) WHERE cross_id IN (SELECT id FROM crosses WHERE meta_id = '" + metaId + "') ORDER BY cross_id");
  if (!contents)
    return [];

  let lastCrossId = -1;
  let crosses = [];

  for (let i = 0; i < contents[0].values.length; i++) {
    let crossId = parseInt(contents[0].values[i][0], 10);
    if (crossId != lastCrossId) {
      lastCrossId = crossId;
      crosses.push(Array.apply(null, Array(8)).map(function() {return [];}));
    }

    let formName = contents[0].values[i][2];
    let groupId = contents[0].values[i][3];
    let isCertain = contents[0].values[i][4];

    crosses[crosses.length - 1][parseInt(groupId, 10)].push({name: formName, isCertain: isCertain});
  }
  return crosses;
}

function displayFields() {
  let displayOptions = [
    {
      value: 'signature_text',
      text: 'Signature',
    },
    {
      value: 'found_location',
      text: 'Found location',
    },
    {
      value: 'parish',
      text: 'Parish',
    },
    {
      value: 'district',
      text: 'District',
    },
    {
      value: 'municipality',
      text: 'Municipality',
    },
    {
      value: 'current_location',
      text: 'Current location',
    },
    {
      value: 'original_site',
      text: 'Original site',
    },
    {
      value: 'parish_code',
      text: 'Parish code',
    },
    {
      value: 'rune_type',
      text: 'Rune type',
    },
    {
      value: 'dating',
      text: 'Dating',
    },
    {
      value: 'style',
      text: 'Style',
    },
    {
      value: 'carver',
      text: 'Carver',
    },
    {
      value: 'material',
      text: 'Material',
    },
    {
      value: 'material_type',
      text: 'Material type',
    },
    {
      value: 'objectInfo',
      text: 'Object information',
    },
    {
      value: 'reference',
      text: 'References',
    },
    {
      value: 'additional',
      text: 'Other information',
    },
    {
      value: 'normalisation_norse',
      text: 'Normalization to Old West Norse',
    },
    {
      value: 'normalisation_scandinavian',
      text: 'Normalisation to Old Scandinavian',
    },
    {
      value: 'english_translation',
      text: 'Translation to English',
    },
    {
      value: 'transliteration',
      text: 'Transliterated runic text',
    },
    {
      value: 'num_crosses',
      text: 'Number of crosses',
    },
    {
      value: 'crosses',
      text: 'Cross form',
    },
    {
      value: 'images',
      text: 'Images',
    },
  ];
  let sortOrder = ['signature_text', 'transliteration', 'normalisation_scandinavian', 'normalisation_norse',
    'english_translation', 'found_location', 'parish', 'municipality', 'district', 'current_location',
    'original_site', 'images', 'rune_type', 'carver', 'num_crosses', 'crosses', 'dating', 'style',
    'material_type', 'material', 'objectInfo', 'reference', 'additional'];
  let sortValue = 1;
  sortOrder.forEach(function (val) {
    let idx = displayOptions.findIndex(o => o.value === val);
    if (idx != -1) {
      displayOptions[idx].sortValue = sortValue;
      sortValue += 1;
    }
  });
  return displayOptions;
}

function humanNames() {
  let namesMap = [
    {
      value: 'runes_personalname',
      text: 'Personal Name'
    },
    {
      value: 'search_transliteration',
      text: 'Transliterated runic text'
    },
    {
      value: 'normalisation_search_norse',
      text: 'Normalization to Old West Norse'
    },
    {
      value: 'normalisation_search_scandinavian',
      text: 'Normalisation to Old Scandinavian'
    },
  ];
  return namesMap;
}

function humanNameForColumnName(columnName) {
  let a = displayFields().find(x => x.value === columnName);
  if (a) {
    return a.text;
  }
  a = humanNames().find(x => x.value === columnName);
  if (a) {
    return a.text;
  }
  return "Undefined";
  //return displayFields().find(x => x.value === columnName).text;
}

function initMultiselect() {
  var displayOptions = displayFields();

  $.each(displayOptions, function (i, item) {
      if (jQuery.inArray(item.value, userSelectedDisplay) != -1) {
        $('#multiselect_to').append($('<option>', {
            value: item.value,
            text : item.text,
            sortValue: item.sortValue,
        }));
        return;
      }
      $('#multiselect').append($('<option>', {
          value: item.value,
          text : item.text,
          sortValue: item.sortValue,
      }));
  });

  $('#multiselect').multiselect({
    keepRenderingSortRight: true,
    skipInitSortRight: false,
    sort: {
      left: function (a, b) {
        aValue = parseInt($(a).attr('sortValue'));
        bValue = parseInt($(b).attr('sortValue'));

        return aValue > bValue ? 1 : -1;
      },
      right: function (a, b) {
        aValue = parseInt($(a).attr('sortValue'));
        bValue = parseInt($(b).attr('sortValue'));

        return aValue > bValue ? 1 : -1;
      }
    }
  });
  formatDialog = $('#divFormatDialog');
}

function setTooltip(btn, message) {
  let that = $(btn);
  that.attr('data-original-title', message).tooltip('show');
  // do not care about multiple calls to setTimeout
  setTimeout(function() {
    that.tooltip('hide');
  }, 500);
}

// Import list of signatures provided from a file
// Function argument fileContent is the actual file content.
function importSignaturesHandler(fileContent) {
  if (fileContent === null) {
    return;
  }
  if (/[\x00-\x08\x0E-\x1F]/.test(fileContent)) {
    alert("Seems like the file you've selected is not textual. Please select a different file.");
    $('#loading').hide();
    return;
  }

  var csvData = Papa.parse(fileContent);
  var numLines = csvData.data.length;
  let firstDataRow = 0;
  let signatureColumn = 0;
  let rules = [];
  let multiline = false;
  let numEntries = 0;
  let maxEntries = 200;

  if (numLines > 1) {
    let signatureCandidate = csvData.data[0].findIndex(item => 'signature' === item.toLowerCase());
    if (signatureCandidate != -1) {
      firstDataRow = 1;
      signatureColumn = signatureCandidate;
    }

    numEntries = csvData.data.length;
    if (numEntries > maxEntries) {
      numEntries = maxEntries;
      alert('You are trying to import more than ' + maxEntries + ' signatures. This is currently \
        not supported and your import will be limited to the first ' + maxEntries + ' signatures.');
    }
    for (var i = firstDataRow; i < numEntries; i++) {
      // iterate over rows
      var rule = {
        id: "signature_text",
        field: "signature_text",
        type: "string",
        input: "text",
        operator: "equal",
      };

      rule.value = csvData.data[i][signatureColumn].trim();

      rules.push(rule);
    }
  } else {
    // single line, treat every value as a signature
    numEntries = csvData.data[0].length;
    if (numEntries > maxEntries) {
      numEntries = maxEntries;
      alert('You are trying to import more than ' + maxEntries + ' signatures. This is currently \
        not supported and your import will be limited to the first ' + maxEntries + ' signatures.');
    }
    for (var i = 0; i < numEntries; i++) {
      // iterate over columns
      var rule = {
        id: "signature_text",
        field: "signature_text",
        type: "string",
        input: "text",
        operator: "equal",
      };

      rule.value = csvData.data[0][i].trim();

      rules.push(rule);
    }
  }

  var allRules = {
    condition: 'OR',
    rules: rules,
    not: false,
  };

  $('#builder').queryBuilder('setRules', allRules, true);
  $('#loading').hide();
}

function showLoading() {
  $('#loading').show();
}

function hideLoading() {
  $('#loading').hide();
}

var clipboard = [];
$(function() {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', "{% static 'runes/runes.sqlite3' %}?v=1.1.4", true);
  xhr.responseType = 'arraybuffer';
  xhr.addEventListener("load", onDbLoaded);
  xhr.send();

  initMultiselect();
  formatDialog.hide();
  $('#alertObj').hide();
  $('#containerRuleIo').hide();
  $('#containerImportSignatures').hide();

  $('.clip').each(function (i) {
    // prepare buttons for clipboard library
    $(this).attr('data-clipboard-text', $(this).html());
  });
  $('.clip').tooltip({
    container: 'body',
    placement: 'bottom',
    title: 'Copied123!',
    trigger: 'manual',
    delay: 10,
  });
  clipboard = new ClipboardJS('.btn');
  clipboard.on('success', function(e) {
    setTooltip(e.trigger, 'Copied!');
  });
  clipboard.on('error', function(e) {
    setTooltip(e.trigger, 'Failed!');
  });

  myMap = L.map('mapDisplay').setView([56.607512, 16.439838], 8);
  let osmAttrib = '© <a href="https://openstreetmap.org">OpenStreetMap</a> contributors';
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    {
      maxZoom: 18,
      attribution: osmAttrib
    }
  ).addTo(myMap);
  markers = L.markerClusterGroup({
    showCoverageOnHover: false,
    chunkedLoading: true,
  });
  markers.on('click', function (a) {
    scrollToInscription(a.layer.options.signature, a.layer.options.id);
  });
  markers.addTo(myMap);

  // Next phase, jstree creation/initialization
  $('#jstree')
  .on('ready.jstree', function () {
      if (gMainClusterize === null) {
        gMainClusterize = new Clusterize({
          rows: inscriptions2markup(),
          scrollId: 'mainScrollArea',
          contentId: 'mainDisplay',
          callbacks: {
            clusterChanged: function () {
              onMainClusterChanged(gClusterizeParams);
            }
          },
        });
      } else {
        gMainClusterize.update(inscriptions2markup());
      }
      clearMarkers();
      makeMarkers();
      displayStatistics();

      $('#loading').hide();
  })
  .on('changed.jstree', function(node, eventObj) {
    if (eventObj.action == 'select_node') {
      if (eventObj.selected.length == 0)
        return;
      let inscriptionId = parseInt(eventObj.node.id, 10);
      scrollToInscription(eventObj.node.original.signature, inscriptionId, false);
      if (inscriptionId in mapMarkers) {
        marker = mapMarkers[inscriptionId];

        myMap.setView(marker.getLatLng(), 18);
      }
    }
  })
  .jstree({
      'core': {
          'animation': 0,
          'data': fetchTreeData,
      }
  });

  $('#btnRuleExporter').on('click', function() {
    $('#containerRuleIo').toggle();
    if ($('#containerRuleIo').is(':visible')) {
      $('#btnRuleExporter').html('Hide rule manager');
    } else {
      $('#btnRuleExporter').html('Show rule manager');
    }
  });
  $('#btnClearRules').on('click', function() {
    $('#builder').queryBuilder('reset');
  });

  $('#btnRulesExport').on('click', function() {
    var result = $('#builder').queryBuilder('getRules');

    if (!$.isEmptyObject(result)) {
      $('#ruleIo').val(JSON.stringify(result, null, 2));
    }
  });

  $('#btnRulesImport').on('click', function() {
    var rules = JSON.parse($('#ruleIo').val());
    $('#builder').queryBuilder('setRules', rules, true);
  });

  $('#btnSearch').on('click', function() {
    if (applyFilters()) {
      gMainClusterize.update(inscriptions2markup());
      clearMarkers();
      makeMarkers();

      $('#jstree').jstree(true).refresh();
      displayStatistics();
    }
  });
  $('#btnResetSearch').on('click', function() {
    gRootsJson = gOriginalData;
    gMainClusterize.update(inscriptions2markup());
    resetSearchStats();
    $('#jstree').jstree(true).refresh();
    clearMarkers();
    makeMarkers();

    displayStatistics();
    setTimeout(scrollToSelectedSignature, 600);
  });

  function onCsvWorkerMessage(e) {
    var csvBody = e.data.csv;
    var columns = e.data.columns;
    var csv = '\ufeff'; // add unicode BOM
    for (var i = 0; i < columns.length; i++) {
      csv += humanNameForColumnName(columns[i]) + ',';
      if (columns[i] === 'signature_text') {
        csv += 'Alternative signatures' + ',';
      }
    }
    csv = csv.slice(0, -1) + '\r\n';
    csv += csvBody;

    var exportedFilename = 'rundata_results.csv';
    var blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    if (navigator.msSaveBlob) { // IE 10+
        navigator.msSaveBlob(blob, exportedFilename);
    } else {
      var link = document.createElement("a");
      if (link.download !== undefined) { // feature detection
          // Browsers that support HTML5 download attribute
          var url = URL.createObjectURL(blob);
          link.setAttribute("href", url);
          link.setAttribute("download", exportedFilename);
          link.style.visibility = 'hidden';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
      }
    }
  }

  $('#btnImportResults').on('click', function() {
    var obj = $('#containerImportSignatures');
    obj.toggle();
    if (obj.is(':visible')) {
      $('#btnImportResults').html('Hide import tool');
    } else {
      $('#btnImportResults').html('Show import tool');
    }
  });
  $('#btnExportResults').on('click', function() {
    var myWorker = new Worker("{% static 'runes/csv.worker.js' %}");
    myWorker.onmessage = onCsvWorkerMessage;
    myWorker.postMessage({
      inscriptions: gDbAsMap,
      rows: gRootsJson,
      columns: userSelectedDisplay
    });
  });

  let dropArea = document.getElementById('drop-area');
  ;['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    dropArea.addEventListener(eventName, preventDefaults, false)
  })
  ;['dragenter', 'dragover'].forEach(eventName => {
    dropArea.addEventListener(eventName, highlight, false)
  })

  ;['dragleave', 'drop'].forEach(eventName => {
    dropArea.addEventListener(eventName, unhighlight, false)
  })
  dropArea.addEventListener('drop', handleDrop, false)
  document.getElementById('fileElem').addEventListener('change', handleImportWrapper, false);

  function handleDrop(e) {
    let dt = e.dataTransfer;
    let files = dt.files;

    handleFiles(files);
  }
  // Event handler that stops event propagation. Used for drag and drop support
  function preventDefaults (e) {
    e.preventDefault()
    e.stopPropagation()
  }
  function highlight(e) {
    dropArea.classList.add('highlight')
  }

  function unhighlight(e) {
    dropArea.classList.remove('highlight')
  }
  function handleImportWrapper(evt) {
    handleFiles(evt.target.files);
  }
  function handleFiles(files) {
    //([...files]).forEach(uploadFile)
    if (files.length == 0) {
      return;
    }
    var fileReader = new FileReader();
    var file = files[0]; // be sure to take just a single file
    fileReader.onloadend = function(evt) {
      if (evt.target.readyState == FileReader.DONE) {
        $('#loading-sub-text').html('This dialog will disappear once data is ready');
        showLoading();
        setTimeout(importSignaturesHandler, 10, evt.target.result);
      }
    }
    fileReader.readAsText(file);
  }
});

// 45 sec timeout
var gLoadingTimer = setTimeout(function() {
  if ($('#loading').is(':visible')) {
    $(document.body).html("Seems that something went wrong and the app is not usable. Try to refresh the page or come later.");
    alert('Seems that something went wrong and the app is not usable. Try to refresh the page or come later.');
  }
}, 45000);
// $('#loading').hide();
</script>

</body>
</html>
