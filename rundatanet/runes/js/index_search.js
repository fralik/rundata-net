/*
This file contains code to do search in the inscriptions
*/

/**
 * JavaScript processor for jQuery QueryBuilder rules.
 * This module allows searching through data using rules
 * generated by jQuery QueryBuilder's getRules() function.
 */

export class QueryBuilderParser {
  /**
   * Initialize the parser with standard operators
   */
  constructor(customSearchFunctions = {}) {
    // Dictionary mapping operator names to functions
    this.operators = {
      equal: (a, b) => a == b,
      not_equal: (a, b) => a != b,
      in: (a, b) => b.includes(a),
      not_in: (a, b) => !b.includes(a),
      less: (a, b) => a < b,
      less_or_equal: (a, b) => a <= b,
      greater: (a, b) => a > b,
      greater_or_equal: (a, b) => a >= b,
      between: (a, b) => b[0] <= a && a <= b[1],
      not_between: (a, b) => !(b[0] <= a && a <= b[1]),
      begins_with: (a, b) => String(a).startsWith(String(b)),
      not_begins_with: (a, b) => !String(a).startsWith(String(b)),
      contains: (a, b) => String(a).includes(String(b)),
      not_contains: (a, b) => !String(a).includes(String(b)),
      ends_with: (a, b) => String(a).endsWith(String(b)),
      not_ends_with: (a, b) => !String(a).endsWith(String(b)),
      is_empty: (a) => a === '' || a === null || a === undefined || (Array.isArray(a) && a.length === 0),
      is_not_empty: (a) => a !== '' && a !== null && a !== undefined && (!Array.isArray(a) || a.length > 0),
      is_null: (a) => a === null || a === undefined,
      is_not_null: (a) => a !== null && a !== undefined,
      in_separated_list: (a, b) => { return false;},
    };
    this.customSearchFunctions = customSearchFunctions;
  
    // Type converters for handling different data types
    this.typeConverters = {
      string: (x) => String(x),
      integer: (x) => parseInt(x, 10),
      double: (x) => parseFloat(x),
      date: (x) => {
        if (x instanceof Date) return x;
        return new Date(x);
      },
      time: (x) => {
        if (typeof x === 'string') {
          const [hours, minutes] = x.split(':').map(Number);
          const date = new Date();
          date.setHours(hours, minutes, 0, 0);
          return date;
        }
        return x;
      },
      datetime: (x) => {
        if (x instanceof Date) return x;
        return new Date(x);
      },
      boolean: (x) => {
        if (typeof x === 'string') {
          return ['true', 'yes', '1'].includes(x.toLowerCase());
        }
        return Boolean(x);
      }
    };
  }
  
  /**
   * Apply rules from jQuery QueryBuilder to filter a list of data.
   *
   * @param {Object} rules - Rules object from jQuery QueryBuilder's getRules() method
   * @param {Array} data - Array of objects (records) to filter
   * @returns {Array} Filtered list of records that match the rules
   */
  parseRules(rules, data) {
    if (!rules || !data) {
      return [];
    }

    // If rules are invalid, return empty array
    if (rules.valid === false) {
      return [];
    }

  const result = [];
  // If data is an array, use filter directly
  if (Array.isArray(data)) {
    return data.filter((item) => this._evaluateGroup(rules, item));
  } 
  // If data is any iterable (e.g. a generator, Set, etc.)
  else if (typeof data[Symbol.iterator] === 'function') {
    for (const item of data) {
      if (this._evaluateGroup(rules, item)) {
        result.push(item);
      }
    }
  } 
  // Fallback: if data implements the iterator protocol (has a next() method)
  else if (typeof data.next === 'function') {
    let nextItem = data.next();
    while (!nextItem.done) {
      if (this._evaluateGroup(rules, nextItem.value)) {
        result.push(nextItem.value);
      }
      nextItem = data.next();
    }
  } else {
    throw new Error('Data is not iterable. It must be an array or implement the iterator protocol.');
  }

  return result;
}
  
  /**
   * Recursively evaluate a group of rules.
   *
   * @param {Object} group - Group object with condition and rules
   * @param {Object} record - Data record to evaluate against
   * @returns {boolean} True if record matches group conditions, False otherwise
   * @private
   */
  _evaluateGroup(group, record) {
    if (!group.condition || !group.rules) {
      return false;
    }

    const condition = group.condition.toUpperCase();
    const rules = group.rules;

    if (!rules || !rules.length) {
      return true;
    }

    const results = rules.map(rule => {
      // If it's a nested group
      if (rule.rules) {
        return this._evaluateGroup(rule, record);
      }
      // It's a rule
      else if (rule.id && rule.operator) {
        return this._evaluateRule(rule, record);
      }
      return false;
    });

    if (condition === 'AND') {
      return results.every(result => result);
    } else if (condition === 'OR') {
      return results.some(result => result);
    } else {
      throw new Error(`Unknown condition: ${condition}`);
    }
  }
  
  /**
   * Evaluate a single rule against a record.
   *
   * @param {Object} rule - Rule object with id, operator, and value
   * @param {Object} record - Data record to check against
   * @returns {boolean} True if the record matches the rule, False otherwise
   * @private
   */
  _evaluateRule(rule, record) {
    const field = rule.field || rule.id;
    // Check if this is a special multi-field rule
    const isMultiFieldRule = rule.data.multiField === true;

    // For standard single-field rules, verify the field exists
    if (!isMultiFieldRule && !(field in record)) {
      return false;
    }

    const operatorName = rule.operator;
    if (!this.operators[operatorName]) {
      throw new Error(`Unknown operator: ${operatorName}`);
    }

    // For multi-field rules, pass the entire record
    // Otherwise, get the specific field value
    const fieldValue = isMultiFieldRule ? record : record[field];

    // Handle special operators that don't need a value
    if (['is_empty', 'is_not_empty', 'is_null', 'is_not_null'].includes(operatorName)) {
      return this.operators[operatorName](fieldValue);
    }

    // Get the rule value
    const ruleValue = rule.value;
    if (ruleValue === null || ruleValue === undefined) {
      return false;
    }

    // For multi-field rules, skip type conversion as it would be
    // handled by the custom function
    let convertedFieldValue = fieldValue;
    let convertedRuleValue = ruleValue;

    if (!isMultiFieldRule) {
      const valueType = rule.type;
      if (valueType && this.typeConverters[valueType]) {
        const converter = this.typeConverters[valueType];
        try {
          if (Array.isArray(ruleValue)) {
            convertedRuleValue = ruleValue.map(v => converter(v));
          } else {
            convertedRuleValue = converter(ruleValue);
          }
          
          if (!Array.isArray(fieldValue)) {
            convertedFieldValue = converter(fieldValue);
          }
        } catch (e) {
          return false;
        }
      }
    }

    // If a custom search function exists for this rule id and operator, call it.
    if (
      rule.id &&
      customSearchFunctions[rule.id] &&
      typeof customSearchFunctions[rule.id][operatorName] === "function"
    ) {
      return customSearchFunctions[rule.id][operatorName](convertedFieldValue, convertedRuleValue);
    }

    // For multi-field rules without a custom function, return false
    // as we don't know how to handle them with standard operators
    if (isMultiFieldRule) {
      return false;
    }

    // Apply the operator
    return this.operators[operatorName](convertedFieldValue, convertedRuleValue);
  }
  
  /**
   * Add a custom operator function.
   *
   * @param {string} name - Name of the operator
   * @param {Function} func - Function that takes two arguments (fieldValue, ruleValue) and returns boolean
   */
  addOperator(name, func) {
    this.operators[name] = func;
  }

  /**
   * Add a custom type converter.
   *
   * @param {string} typeName - Name of the type
   * @param {Function} func - Function that converts a value to the specified type
   */
  addTypeConverter(typeName, func) {
    this.typeConverters[typeName] = func;
  }
}

const searchViaList = (fieldValue, ruleValue) => {
  const items = ruleValue.split('|');
  return items.some(item => item === fieldValue);
};

const doWordSearch = (entry, ruleValue, searchDirection, searchMode) => {
  const isAHit = getWordSearchFunction(searchMode);
  const normalisationQuery = ruleValue['normalization'];
  const transliterationQuery = ruleValue['transliteration'];
  const namesMode = ruleValue['namesMode'];

  // Determine which normalization field to use
  let normalizationField;
  if (searchDirection.includes('norse')) {
    normalizationField = 'normalisation_norse';
  } else {
    normalizationField = 'normalisation_scandinavian';
  }

  const normalWords = entry[`${normalizationField}_words`];
  const normalisationText = entry[normalizationField];
  const transliterationWords = entry['transliteration_words'];
  const transliterationText = entry['transliteration'];

  let matchFound = false;
  let matchedWords = [];
  let numFoundNames = 0;
  let personalNamePresent = false;

  if (normalisationQuery && transliterationQuery) {
    for (let i = 0; i < Math.min(normalWords.length, transliterationWords.length); i++) {
      if (isAHit(normalWords[i], normalisationQuery) && isAHit(transliterationWords[i], transliterationQuery)) {
        personalNamePresent = isPersonalName(normalWords[i]);
        if (namesMode === 'excludeNames' && personalNamePresent) {
          continue;
        }
        if (namesMode === 'namesOnly' && !personalNamePresent) {
          continue;
        }

        matchFound = true;
        matchedWords.push(i);
        if (personalNamePresent) {
          numFoundNames++;
        }
      }
    }
  } else {
    if (normalisationQuery) {
      normalWords.forEach((word, i) => {
        if (isAHit(word, normalisationQuery)) {
          personalNamePresent = isPersonalName(word);
          if (namesMode === 'excludeNames' && personalNamePresent) {
            return;
          }
          if (namesMode === 'namesOnly' && !personalNamePresent) {
            return;
          }

          matchFound = true;
          matchedWords.push(i);
          if (personalNamePresent) {
            numFoundNames++;
          }
        }
      });
    }
    if (transliterationQuery) {
      transliterationWords.forEach((word, i) => {
        if (isAHit(word, transliterationQuery)) {
          // transliterated words do not contain personal name annotation, use normalised word instead
          personalNamePresent = true ? (i < normalWords.length) && isPersonalName(normalWords[i]) : false;

          if (namesMode == 'excludeNames' && personalNamePresent) {
            return;
          }
          if (namesMode == 'namesOnly' && !personalNamePresent) {
            return;
          }
          matchFound = true;
          matchedWords.push(i);
          if (personalNamePresent) {
            numFoundNames++;
          }
        }
      });
    }
  }

  return matchFound;
};

const customSearchFunctions = {
  signature_text: {
    in: searchViaList,
    in_separated_list: searchViaList,
  },
  normalization_norse_to_transliteration: {
    contains: (fieldValue, ruleValue) => {
      return doWordSearch(fieldValue, ruleValue, 'norseToTransliteration', 'includes');
    }
  },
};

/**
 * Returns a word search function based on the specified search mode
 * @param {string} searchMode - The search mode ('exact', 'beginsWith', 'endsWith', 'regex', 'includes')
 * @param {Object} options - Additional options
 * @param {boolean} [options.ignoreCase=false] - Whether to ignore case when searching
 * @returns {Function} A search function that takes (word, query) parameters
 * @throws {Error} When an invalid regex pattern is provided in regex mode
 */
export function getWordSearchFunction(searchMode, options = {}) {
  const { ignoreCase = false } = options;
  
  // Create a function to handle case sensitivity
  const prepareString = ignoreCase 
    ? str => String(str).toLowerCase() 
    : str => String(str);
  
  switch (searchMode) {
    case 'exact':
      return (word, query) => prepareString(word) === prepareString(query);
      
    case 'beginsWith':
      return (word, query) => prepareString(word).startsWith(prepareString(query));
      
    case 'endsWith':
      return (word, query) => prepareString(word).endsWith(prepareString(query));
      
    case 'regex': {
      return (word, query) => {
        try {
          const flags = ignoreCase ? 'i' : '';
          // Create RegExp only once per query
          const regex = new RegExp(query, flags);
          return regex.test(word);
        } catch (error) {
          throw new Error(`Invalid regex pattern: ${query}`);
        }
      };
    }
      
    case 'includes':
    default:
      return (word, query) => prepareString(word).includes(prepareString(query));
  }
}


export function doSearch(rules, dbMap) {
  const parser = new QueryBuilderParser(customSearchFunctions);
  const results = parser.parseRules(rules, dbMap);
  return results;
}